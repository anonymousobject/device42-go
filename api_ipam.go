
/*
 * Device42 API
 *
 * <b><h2>API Overview</h2></b><br>Restful API are supported in Device42 as one of the primary methods of entering, editing and retrieving data.<br><br> The API documentation has samples in curl for now and we will be adding other programming languages in future. You can refer to our github repositories at https://github.com/device42 for some sample code in python.<br><br> The RESTful API's enforce the role-based security that is created with the Device42 app. If you want a user to have access via the API, but not via the UI - deselect 'Staff Status' for that user from UI Tools > Admins & Permissions > Administrators.<br><br>If you'd like to see your changes on our UI, please visit http://swaggerdemo.device42.com and use credentials 'guest:device42_rocks!'. Please be aware that every 30 minutes our database resets and all data entered with POST/PUT calls from this page will be lost.<br><br>If you have any questions/suggestions, please send us a note to support at device42.com below. <br><h2><a id = 'Sample_API_Code'><b>Sample API Code</b></a></h2> <b>Sample Code with API Calls in the Python and .Net Programming Languages.</b><br>The following programs written in the Python programming language are available at <a href= 'https://github.com/device42/Device42-AutoDiscovery-Scripts'>Device42 sample programs</a><br><ul><li>api-sample.py: Runs against a single Windows system and uploads info to device42 appliance.</li><li>ad-sample.py: Can run against Active directory computers, servers or a given list and upload discovered systems’ info to device42 appliance.</li><li>d42_api_linux_upload_sample_script.py: Runs on a single *nix based system and uploads info to device42 appliance.</li><li>sample-script-facter-facts-to-d42: Runs on puppet master and uploads nodes info from facter fact files to device42 appliance.</li><li>d42_api_solaris_sample_script.py: Runs on an individual solaris system and uploads info to device42 appliance.</li></ul>The csv2d42apis.py sample program shows how to create a CSV file of data to import into device42. It reads a CSV file, matches columns to arguments for APIs and sends data to device42 via POST or PUT. This program can be found at: <a href= 'https://github.com/device42/API_Helpers'> Device42 sample CSV importer</a>.<br><br>The Auto Discovery Client source code can be found at Device42 <a href='https://docs.device42.com/auto-discovery/'>Auto Discovery Client</a>. This is a .net program that uses the device42 Restful API’s to load the discovered data.<h2><a id = 'Response_Status_Messages'><b>Response & Status Messages</b></a></h2><b>Responses</b><br>The response to most POST calls will have the following format: <br>{'msg':['PartModel added/updated', 17, 'RAM Acme 123456', true, true], 'code':0}<br><br>Using the example above:<br>'17' = ID of the object<br>'RAM Acme 123456' = representation of the object<br> 'true, true' = object added and is new.<br>'true, false' = object updated.<br>'false, false' = no changes.<br><br><b>Status Codes</b><br><u>Code 0</u><br>Success! e.g. = {'msg': 'device added or updated', <b>code:0</b>}<br><br><u>'HTTP/1.1 200 OK'</u><br>Success! All other responses are errors and will display an error code e.g.: 400, 401, 403, 405, 410, 500, 503. These are explained in each call.<br><br>Please let us know if you notice something odd with a response and we will fix it! :) <h2><a id = 'Get_Limits_Offsets'><b>API Get Limits and Offsets</b></a></h2>In Device42’s global settings we have the option to enforce API GET limits and this setting is recommended for better performance. To set this value from Device42, go to Tools>Settings>Global Settings and the click Edit in the top right. Toward the bottom of the screen you will see the API section. First check the “Enforce API GET Limits” checkbox, then enter a value for API GET Limit. A good limit to start with is 500 or 1000, depending on the performance you experience.<br><br>After setting this limit all GET calls below can have the results augmented via “offset” and “limit” parameters to tell Device42 which value to start returning results from, and how many results to return at maximum.<br>Examples:<br><br>'/?limit=50' returns the first 50 results.<br><br> '/?offset=100' will start at the 101st result. <br><br>'/?offset=42&limit=42' returns 42 results, starting at the 43rd.<br><br> Note that offset is used for paging - that is, the offset is only applied when the total number of objects returned exceeds the limit that is returned.
 *
 * API version: 2.0
 * Contact: support@device42.com
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package swagger

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"fmt"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type IPAMApiService service

/* 
IPAMApiService Delete DNS Records
This API is used to delete the DNS record with the DNS Record id supplied as the required argument.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id DNS Record id

@return interface{}
*/
func (a *IPAMApiService) DeleteIPAMDnsRecords(ctx context.Context, id int32) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/dns/records/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
IPAMApiService Delete DNS Zones
This API is used to delete the DNS zone with the DNS zone id supplied as the required argument.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id DNS zone id

@return interface{}
*/
func (a *IPAMApiService) DeleteIPAMDnsZones(ctx context.Context, id int32) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/dns/zones/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
IPAMApiService This API is used to delete the IP NAT.
Delete IP NAT
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Name of Id

@return interface{}
*/
func (a *IPAMApiService) DeleteIPAMIpnat(ctx context.Context, id string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/ipnat/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
IPAMApiService Delete IP Address
This API is used to delete an IP Address with the IP Address id supplied as the required argument.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id IP Address id

@return interface{}
*/
func (a *IPAMApiService) DeleteIPAMIps(ctx context.Context, id int32) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/ips/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
IPAMApiService Delete Mac Address
This API is used to delete the mac address with the mac address id supplied as the required argument.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Mac address id

@return interface{}
*/
func (a *IPAMApiService) DeleteIPAMMacsId(ctx context.Context, id int32) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/macs/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
IPAMApiService Delete Switchport
This API is used to delete the switch port with the switch port id supplied as the required argument.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Switch port id

@return interface{}
*/
func (a *IPAMApiService) DeleteIPAMSwitchports(ctx context.Context, id int32) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/switchports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
IPAMApiService Delete Subnet Category
This API is used to delete the subnet category with the subnet category id supplied as the required argument.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Subnet category id

@return interface{}
*/
func (a *IPAMApiService) DeleteIPAMsubnetcategory(ctx context.Context, id int32) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/subnet_category/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
IPAMApiService Delete Subnet
This API is used to delete the subnet with the subnet id supplied as the required argument.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param subnetId subnet id

@return interface{}
*/
func (a *IPAMApiService) DeleteIPAMsubnets(ctx context.Context, subnetId int32) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/subnets/{subnet_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"subnet_id"+"}", fmt.Sprintf("%v", subnetId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
IPAMApiService Delete VLAN
This API is used to delete the vlan with the vlan id supplied as the required argument.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id vlan id (This is Device42 ID of the VLAN)

@return interface{}
*/
func (a *IPAMApiService) DeleteIPAMvlans(ctx context.Context, id int32) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/vlans/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
IPAMApiService Delete VRF Group
This API is used to delete the vrf group with the vrf group id supplied as the required argument.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id VRF group

@return interface{}
*/
func (a *IPAMApiService) DeleteIPAMvrfgroupId(ctx context.Context, id string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/vrfgroup/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
IPAMApiService GET method retrieves all Subnets by customer ID #.
Get all Subnets by Customer
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param customerId Customer Id

@return []InlineResponse2007
*/
func (a *IPAMApiService) GetIPAMCustomerId(ctx context.Context, customerId int32) ([]InlineResponse2007, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []InlineResponse2007
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/subnets/customer_id/{customer_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"customer_id"+"}", fmt.Sprintf("%v", customerId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []InlineResponse2007
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
IPAMApiService GET method retrieves all DNS Records. (Added in v6.5.0)
Get DNS Records
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *IPAMApiGetIPAMDnsRecordsOpts - Optional Parameters:
     * @param "Domain" (optional.String) -  name of the domain
     * @param "Type_" (optional.String) -  type of the record. e.g. AAAA
     * @param "Name" (optional.String) -  filter by name (Added in v6.0.0)
     * @param "Nameserver" (optional.String) -  Nameserver
     * @param "Content" (optional.String) -  Content (e.g. IP address for type A)
     * @param "Tags" (optional.String) -  filter by tags. comma separated for multiple tags (This is an OR filter, gets all the devices for all comma separated tags)
     * @param "TagsAnd" (optional.String) -  filter by all the tags, separated by comma. (This is an AND filter and all tags have to match for filter, this was added in v6.3.1)
     * @param "DnsZone" (optional.String) - 
     * @param "Ttl" (optional.String) -  TTL value.
     * @param "ChangeDate" (optional.String) - 

@return interface{}
*/

type IPAMApiGetIPAMDnsRecordsOpts struct { 
	Domain optional.String
	Type_ optional.String
	Name optional.String
	Nameserver optional.String
	Content optional.String
	Tags optional.String
	TagsAnd optional.String
	DnsZone optional.String
	Ttl optional.String
	ChangeDate optional.String
}

func (a *IPAMApiService) GetIPAMDnsRecords(ctx context.Context, localVarOptionals *IPAMApiGetIPAMDnsRecordsOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/dns/records/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Domain.IsSet() {
		localVarQueryParams.Add("domain", parameterToString(localVarOptionals.Domain.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarQueryParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Nameserver.IsSet() {
		localVarQueryParams.Add("nameserver", parameterToString(localVarOptionals.Nameserver.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Content.IsSet() {
		localVarQueryParams.Add("content", parameterToString(localVarOptionals.Content.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tags.IsSet() {
		localVarQueryParams.Add("tags", parameterToString(localVarOptionals.Tags.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TagsAnd.IsSet() {
		localVarQueryParams.Add("tags_and", parameterToString(localVarOptionals.TagsAnd.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DnsZone.IsSet() {
		localVarQueryParams.Add("dns_zone", parameterToString(localVarOptionals.DnsZone.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Ttl.IsSet() {
		localVarQueryParams.Add("ttl", parameterToString(localVarOptionals.Ttl.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ChangeDate.IsSet() {
		localVarQueryParams.Add("change_date", parameterToString(localVarOptionals.ChangeDate.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
IPAMApiService GET method retrieves all Switch Templates.
Get all IP NAT Records
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

@return interface{}
*/
func (a *IPAMApiService) GetIPAMIpnat(ctx context.Context) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/ipnat/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
IPAMApiService Get all IPs
GET method retrieves all IPs. (Added in v5.9.3) By default the limit is maximum 1000 IPs per call. Use total_count and offset if over 1000 IPs.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *IPAMApiGetIPAMIpsOpts - Optional Parameters:
     * @param "Offset" (optional.String) -  start with this device (e.g. limit&#x3D;100&amp;offset&#x3D;50 means start with the 50th device and return the next 100 devices)
     * @param "Limit" (optional.String) -  return this number of devices
     * @param "SubnetId" (optional.String) -  ID of the subnet (added in v7.2.0)
     * @param "Subnet" (optional.String) -  name of the subnet
     * @param "Device" (optional.String) -  Device name
     * @param "Mac" (optional.String) -  mac address
     * @param "Available" (optional.String) -  could be yes or no
     * @param "Type_" (optional.String) - 
     * @param "LastUpdatedLt" (optional.String) -  last updated less than date YYYY-MM-DD format
     * @param "LastUpdatedGt" (optional.String) -  last updated greater than date YYYY-MM-DD format
     * @param "Ip" (optional.String) -  ip address (added in v6.3.0)
     * @param "FirstAddedLt" (optional.String) -  first added less than date YYYY-MM-DD format
     * @param "FirstAddedGt" (optional.String) -  first added greater date YYYY-MM-DD format
     * @param "IpId" (optional.String) -  D42 ID of the IP
     * @param "Label" (optional.String) - 
     * @param "Tags" (optional.String) -  filter by tags. comma separated for multiple tags (This is an OR filter, gets all the devices for all comma separated tags)
     * @param "TagsAnd" (optional.String) -  filter by all the tags, separated by comma. (This is an AND filter and all tags have to match for filter, this was added in v6.3.1)
     * @param "CustomFieldsAnd" (optional.String) -  filter by custom fields, and filter, format of key1:value1,key2:value2
     * @param "CustomFieldsOr" (optional.String) -  filter by custom fields, or filter, format of key1:value1,key2:value2
     * @param "TotalCount" (optional.String) -  Count of IPs returned (use with offset as max results are limited to 1000)
     * @param "Ips" (optional.String) -  Details for all the IPs

@return interface{}
*/

type IPAMApiGetIPAMIpsOpts struct { 
	Offset optional.String
	Limit optional.String
	SubnetId optional.String
	Subnet optional.String
	Device optional.String
	Mac optional.String
	Available optional.String
	Type_ optional.String
	LastUpdatedLt optional.String
	LastUpdatedGt optional.String
	Ip optional.String
	FirstAddedLt optional.String
	FirstAddedGt optional.String
	IpId optional.String
	Label optional.String
	Tags optional.String
	TagsAnd optional.String
	CustomFieldsAnd optional.String
	CustomFieldsOr optional.String
	TotalCount optional.String
	Ips optional.String
}

func (a *IPAMApiService) GetIPAMIps(ctx context.Context, localVarOptionals *IPAMApiGetIPAMIpsOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/ips/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SubnetId.IsSet() {
		localVarQueryParams.Add("subnet_id", parameterToString(localVarOptionals.SubnetId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Subnet.IsSet() {
		localVarQueryParams.Add("subnet", parameterToString(localVarOptionals.Subnet.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Device.IsSet() {
		localVarQueryParams.Add("device", parameterToString(localVarOptionals.Device.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Mac.IsSet() {
		localVarQueryParams.Add("mac", parameterToString(localVarOptionals.Mac.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Available.IsSet() {
		localVarQueryParams.Add("available", parameterToString(localVarOptionals.Available.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarQueryParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLt.IsSet() {
		localVarQueryParams.Add("last_updated_lt", parameterToString(localVarOptionals.LastUpdatedLt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGt.IsSet() {
		localVarQueryParams.Add("last_updated_gt", parameterToString(localVarOptionals.LastUpdatedGt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Ip.IsSet() {
		localVarQueryParams.Add("ip", parameterToString(localVarOptionals.Ip.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FirstAddedLt.IsSet() {
		localVarQueryParams.Add("first_added_lt", parameterToString(localVarOptionals.FirstAddedLt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FirstAddedGt.IsSet() {
		localVarQueryParams.Add("first_added_gt", parameterToString(localVarOptionals.FirstAddedGt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IpId.IsSet() {
		localVarQueryParams.Add("ip_id", parameterToString(localVarOptionals.IpId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Label.IsSet() {
		localVarQueryParams.Add("label", parameterToString(localVarOptionals.Label.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tags.IsSet() {
		localVarQueryParams.Add("tags", parameterToString(localVarOptionals.Tags.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TagsAnd.IsSet() {
		localVarQueryParams.Add("tags_and", parameterToString(localVarOptionals.TagsAnd.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CustomFieldsAnd.IsSet() {
		localVarQueryParams.Add("custom_fields_and", parameterToString(localVarOptionals.CustomFieldsAnd.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CustomFieldsOr.IsSet() {
		localVarQueryParams.Add("custom_fields_or", parameterToString(localVarOptionals.CustomFieldsOr.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TotalCount.IsSet() {
		localVarQueryParams.Add("total_count", parameterToString(localVarOptionals.TotalCount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Ips.IsSet() {
		localVarQueryParams.Add("ips", parameterToString(localVarOptionals.Ips.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
IPAMApiService GET method retrieves all IPs by Subnet ID.
Get all IPs in a Subnet
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param subnetId

@return interface{}
*/
func (a *IPAMApiService) GetIPAMIpsSubnetId(ctx context.Context, subnetId int32) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/ips/subnet_id/{subnet_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"subnet_id"+"}", fmt.Sprintf("%v", subnetId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
IPAMApiService GET method retrieves all MAC Addresses.
Get all MAC Addresses
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *IPAMApiGetIPAMMacsOpts - Optional Parameters:
     * @param "Mac" (optional.String) -  mac address
     * @param "Device" (optional.String) -  Device name
     * @param "DeviceId" (optional.String) -  Device ID
     * @param "LastUpdatedLt" (optional.String) -  last updated less than date YYYY-MM-DD format
     * @param "LastUpdatedGt" (optional.String) -  last updated greater than date YYYY-MM-DD format

@return interface{}
*/

type IPAMApiGetIPAMMacsOpts struct { 
	Mac optional.String
	Device optional.String
	DeviceId optional.String
	LastUpdatedLt optional.String
	LastUpdatedGt optional.String
}

func (a *IPAMApiService) GetIPAMMacs(ctx context.Context, localVarOptionals *IPAMApiGetIPAMMacsOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/macs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Mac.IsSet() {
		localVarQueryParams.Add("mac", parameterToString(localVarOptionals.Mac.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Device.IsSet() {
		localVarQueryParams.Add("device", parameterToString(localVarOptionals.Device.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceId.IsSet() {
		localVarQueryParams.Add("device_id", parameterToString(localVarOptionals.DeviceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLt.IsSet() {
		localVarQueryParams.Add("last_updated_lt", parameterToString(localVarOptionals.LastUpdatedLt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGt.IsSet() {
		localVarQueryParams.Add("last_updated_gt", parameterToString(localVarOptionals.LastUpdatedGt.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
IPAMApiService GET method retrieves MAC address by specific MAC ID.
Get MAC Address with ID
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id

@return interface{}
*/
func (a *IPAMApiService) GetIPAMMacsId(ctx context.Context, id int32) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/macs/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
IPAMApiService Find a specific IP Address.
Find Specific IP Address
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param query enter “ip”
 * @param string_ the IP address to search for

@return interface{}
*/
func (a *IPAMApiService) GetIPAMSearch(ctx context.Context, query string, string_ string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/search/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("query", parameterToString(query, ""))
	localVarQueryParams.Add("string", parameterToString(string_, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
IPAMApiService Get Subnet by Subnet ID
GET method retrieves the subnet with the specified subnet id.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param subnetId Subnet Id

@return IpaMsubnets
*/
func (a *IPAMApiService) GetIPAMSubnetId(ctx context.Context, subnetId int32) (IpaMsubnets, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue IpaMsubnets
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/subnets/{subnet_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"subnet_id"+"}", fmt.Sprintf("%v", subnetId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v IpaMsubnets
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
IPAMApiService Suggest next available IP Address. Can be IPv4 or IPv6.
Suggest next available IP Address
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param maskBits mask bits (added in v7.2.0)
 * @param optional nil or *IPAMApiGetIPAMSuggestIpOpts - Optional Parameters:
     * @param "SubnetId" (optional.String) -  ID of the subnet (added in v7.2.0)
     * @param "Subnet" (optional.String) -  name of the subnet
     * @param "Name" (optional.String) -  filter by name (Added in v6.0.0)
     * @param "VrfGroupId" (optional.String) -  ID of the VRF group
     * @param "VrfGroup" (optional.String) -  VRF group name
     * @param "ReserveIp" (optional.String) -  If value of yes is passed, the suggested IP is reserved. Return value also adds reserved as yes or no. (added in v7.2.0)
     * @param "Number" (optional.String) -  vlan number

@return interface{}
*/

type IPAMApiGetIPAMSuggestIpOpts struct { 
	SubnetId optional.String
	Subnet optional.String
	Name optional.String
	VrfGroupId optional.String
	VrfGroup optional.String
	ReserveIp optional.String
	Number optional.String
}

func (a *IPAMApiService) GetIPAMSuggestIp(ctx context.Context, maskBits string, localVarOptionals *IPAMApiGetIPAMSuggestIpOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/suggest_ip/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.SubnetId.IsSet() {
		localVarQueryParams.Add("subnet_id", parameterToString(localVarOptionals.SubnetId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Subnet.IsSet() {
		localVarQueryParams.Add("subnet", parameterToString(localVarOptionals.Subnet.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VrfGroupId.IsSet() {
		localVarQueryParams.Add("vrf_group_id", parameterToString(localVarOptionals.VrfGroupId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VrfGroup.IsSet() {
		localVarQueryParams.Add("vrf_group", parameterToString(localVarOptionals.VrfGroup.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReserveIp.IsSet() {
		localVarQueryParams.Add("reserve_ip", parameterToString(localVarOptionals.ReserveIp.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Number.IsSet() {
		localVarQueryParams.Add("number", parameterToString(localVarOptionals.Number.Value(), ""))
	}
	localVarQueryParams.Add("mask_bits", parameterToString(maskBits, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
IPAMApiService Suggest next available subnet.
Suggest next available Subnet
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id ID of the parent subnet
 * @param maskBits mask bits (added in v7.2.0)
 * @param optional nil or *IPAMApiGetIPAMSuggestSubnetIdOpts - Optional Parameters:
     * @param "Subnet" (optional.String) -  name of the subnet
     * @param "SubnetId" (optional.String) -  ID of the subnet (added in v7.2.0)
     * @param "VrfGroupId" (optional.String) -  ID of the VRF group
     * @param "VrfGroup" (optional.String) -  VRF group name
     * @param "Name" (optional.String) -  filter by name (Added in v6.0.0)
     * @param "IfParentAssigned" (optional.String) -  yes or no
     * @param "IfParentAllocated" (optional.String) -  yes or no

@return interface{}
*/

type IPAMApiGetIPAMSuggestSubnetIdOpts struct { 
	Subnet optional.String
	SubnetId optional.String
	VrfGroupId optional.String
	VrfGroup optional.String
	Name optional.String
	IfParentAssigned optional.String
	IfParentAllocated optional.String
}

func (a *IPAMApiService) GetIPAMSuggestSubnetId(ctx context.Context, id int32, maskBits string, localVarOptionals *IPAMApiGetIPAMSuggestSubnetIdOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/suggest_subnet/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("mask_bits", parameterToString(maskBits, ""))
	if localVarOptionals != nil && localVarOptionals.Subnet.IsSet() {
		localVarQueryParams.Add("subnet", parameterToString(localVarOptionals.Subnet.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SubnetId.IsSet() {
		localVarQueryParams.Add("subnet_id", parameterToString(localVarOptionals.SubnetId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VrfGroupId.IsSet() {
		localVarQueryParams.Add("vrf_group_id", parameterToString(localVarOptionals.VrfGroupId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VrfGroup.IsSet() {
		localVarQueryParams.Add("vrf_group", parameterToString(localVarOptionals.VrfGroup.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IfParentAssigned.IsSet() {
		localVarQueryParams.Add("if_parent_assigned", parameterToString(localVarOptionals.IfParentAssigned.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IfParentAllocated.IsSet() {
		localVarQueryParams.Add("if_parent_allocated", parameterToString(localVarOptionals.IfParentAllocated.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
IPAMApiService GET method retrieves all Switch Templates.
Get all Switch Templates
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

@return []InlineResponse20010
*/
func (a *IPAMApiService) GetIPAMSwitchTemplates(ctx context.Context) ([]InlineResponse20010, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []InlineResponse20010
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/switch_templates/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []InlineResponse20010
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
IPAMApiService GET method retrieves all Switch Ports.
Get all Switch Ports
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *IPAMApiGetIPAMSwitchportsOpts - Optional Parameters:
     * @param "SwitchId" (optional.String) -  ID of the network device port is on
     * @param "Switch2Id" (optional.String) -  ID of the 2nd network device port is on
     * @param "LastUpdatedLt" (optional.String) -  last updated less than date YYYY-MM-DD format
     * @param "LastUpdatedGt" (optional.String) -  last updated greater than date YYYY-MM-DD format
     * @param "FirstAddedLt" (optional.String) -  first added less than date YYYY-MM-DD format
     * @param "FirstAddedGt" (optional.String) -  first added greater date YYYY-MM-DD format
     * @param "Tags" (optional.String) -  filter by tags. comma separated for multiple tags (This is an OR filter, gets all the devices for all comma separated tags)
     * @param "TagsAnd" (optional.String) -  filter by all the tags, separated by comma. (This is an AND filter and all tags have to match for filter, this was added in v6.3.1)
     * @param "IncludeCols" (optional.String) -  do not return all columns just the ones specified. For example, ?include_cols&#x3D;name, device_id, rack will only result in name, device_id, and rack included in the output. The following column names can be part of include_cols: name, device_id, rack, name, device_id, serial_no, asset_no, uuid, notes, in_service, service_level, type, id, last_updated, tags, customer_id, customer, hw_model, hw_size, manufacturer, hw_depth, rack, start_at, rack_id, orientation, row, room, building, blade_host_name, blade_host_id, slot_number, virtual_host_name, location, device_sub_type, os, osarch, osver, osverno, custom_fields, device_purchase_line_items, device_external_links, ip_addresses, mac_addresses, cpucount, cpucore, cpuspeed, ram, hddcount, hddsize, hddraid, hddraid_type, hdd_details, pdu_mapping_url,modules, vms, devices, aliases, xpos, ucs_manager

@return interface{}
*/

type IPAMApiGetIPAMSwitchportsOpts struct { 
	SwitchId optional.String
	Switch2Id optional.String
	LastUpdatedLt optional.String
	LastUpdatedGt optional.String
	FirstAddedLt optional.String
	FirstAddedGt optional.String
	Tags optional.String
	TagsAnd optional.String
	IncludeCols optional.String
}

func (a *IPAMApiService) GetIPAMSwitchports(ctx context.Context, localVarOptionals *IPAMApiGetIPAMSwitchportsOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/switchports"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.SwitchId.IsSet() {
		localVarQueryParams.Add("switch_id", parameterToString(localVarOptionals.SwitchId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Switch2Id.IsSet() {
		localVarQueryParams.Add("switch2_id", parameterToString(localVarOptionals.Switch2Id.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLt.IsSet() {
		localVarQueryParams.Add("last_updated_lt", parameterToString(localVarOptionals.LastUpdatedLt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGt.IsSet() {
		localVarQueryParams.Add("last_updated_gt", parameterToString(localVarOptionals.LastUpdatedGt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FirstAddedLt.IsSet() {
		localVarQueryParams.Add("first_added_lt", parameterToString(localVarOptionals.FirstAddedLt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FirstAddedGt.IsSet() {
		localVarQueryParams.Add("first_added_gt", parameterToString(localVarOptionals.FirstAddedGt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tags.IsSet() {
		localVarQueryParams.Add("tags", parameterToString(localVarOptionals.Tags.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TagsAnd.IsSet() {
		localVarQueryParams.Add("tags_and", parameterToString(localVarOptionals.TagsAnd.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludeCols.IsSet() {
		localVarQueryParams.Add("include_cols", parameterToString(localVarOptionals.IncludeCols.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
IPAMApiService GET method retrieves all TAP Ports.
Get Tap Ports
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *IPAMApiGetIPAMTapPortsOpts - Optional Parameters:
     * @param "Id" (optional.String) -  id of the tap port

@return interface{}
*/

type IPAMApiGetIPAMTapPortsOpts struct { 
	Id optional.String
}

func (a *IPAMApiService) GetIPAMTapPorts(ctx context.Context, localVarOptionals *IPAMApiGetIPAMTapPortsOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/tap_ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
IPAMApiService GET method retrieves all Subnet Categories.
Get all Subnet Categories
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

@return []InlineResponse2005
*/
func (a *IPAMApiService) GetIPAMsubnetcategory(ctx context.Context) ([]InlineResponse2005, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []InlineResponse2005
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/subnet_category/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []InlineResponse2005
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
IPAMApiService GET method retrieves all Subnets.
Get all Subnets - Filter parameters are below.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *IPAMApiGetIPAMsubnetsOpts - Optional Parameters:
     * @param "Name" (optional.String) -  name of the subnet
     * @param "VrfGroupId" (optional.String) -  ID of the VRF group
     * @param "VrfGroup" (optional.String) -  VRF group name
     * @param "ParentSubnetId" (optional.String) -  ID of the parent subnet
     * @param "ParentSubnet" (optional.String) -  parent subnet name
     * @param "CustomerId" (optional.String) -  ID of the customer (Added in v6.3.0)
     * @param "Customer" (optional.String) -  filter by customer name
     * @param "SubnetId" (optional.String) -  ID of the subnet (added in v7.2.0)
     * @param "MaskBits" (optional.String) -  mask bits
     * @param "MaskBitsLt" (optional.String) -  less than mask bits (added in v7.2.0)
     * @param "MaskBitsGt" (optional.String) -  greater than mask bits (added in v7.2.0)
     * @param "Description" (optional.String) -  matching description (added in v7.2.0)
     * @param "RangeBegin" (optional.String) -  Range Begin (added in v7.2.0)
     * @param "RangeEnd" (optional.String) -  Range End (added in v7.2.0)
     * @param "Gateway" (optional.String) -  Gateway (added in v7.2.0)
     * @param "Tags" (optional.String) -  filter by tags. comma separated for multiple tags (This is an OR filter, gets all the devices for all comma separated tags)
     * @param "TagsAnd" (optional.String) -  filter by all the tags, separated by comma. (This is an AND filter and all tags have to match for filter, this was added in v6.3.1)
     * @param "CustomFieldsAnd" (optional.String) -  filter by custom fields, and filter, format of key1:value1,key2:value2
     * @param "CustomFieldsOr" (optional.String) -  filter by custom fields, or filter, format of key1:value1,key2:value2
     * @param "ServiceLevel" (optional.String) -  filter by service level name
     * @param "Category" (optional.String) -  name of the category
     * @param "CategoryId" (optional.String) -  ID of the category
     * @param "VlanId" (optional.String) -  ID of the vlan
     * @param "Network" (optional.String) -  Optional

@return InlineResponse2006
*/

type IPAMApiGetIPAMsubnetsOpts struct { 
	Name optional.String
	VrfGroupId optional.String
	VrfGroup optional.String
	ParentSubnetId optional.String
	ParentSubnet optional.String
	CustomerId optional.String
	Customer optional.String
	SubnetId optional.String
	MaskBits optional.String
	MaskBitsLt optional.String
	MaskBitsGt optional.String
	Description optional.String
	RangeBegin optional.String
	RangeEnd optional.String
	Gateway optional.String
	Tags optional.String
	TagsAnd optional.String
	CustomFieldsAnd optional.String
	CustomFieldsOr optional.String
	ServiceLevel optional.String
	Category optional.String
	CategoryId optional.String
	VlanId optional.String
	Network optional.String
}

func (a *IPAMApiService) GetIPAMsubnets(ctx context.Context, localVarOptionals *IPAMApiGetIPAMsubnetsOpts) (InlineResponse2006, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponse2006
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/subnets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VrfGroupId.IsSet() {
		localVarQueryParams.Add("vrf_group_id", parameterToString(localVarOptionals.VrfGroupId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VrfGroup.IsSet() {
		localVarQueryParams.Add("vrf_group", parameterToString(localVarOptionals.VrfGroup.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ParentSubnetId.IsSet() {
		localVarQueryParams.Add("parent_subnet_id", parameterToString(localVarOptionals.ParentSubnetId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ParentSubnet.IsSet() {
		localVarQueryParams.Add("parent_subnet", parameterToString(localVarOptionals.ParentSubnet.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CustomerId.IsSet() {
		localVarQueryParams.Add("customer_id", parameterToString(localVarOptionals.CustomerId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Customer.IsSet() {
		localVarQueryParams.Add("customer", parameterToString(localVarOptionals.Customer.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SubnetId.IsSet() {
		localVarQueryParams.Add("subnet_id", parameterToString(localVarOptionals.SubnetId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaskBits.IsSet() {
		localVarQueryParams.Add("mask_bits", parameterToString(localVarOptionals.MaskBits.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaskBitsLt.IsSet() {
		localVarQueryParams.Add("mask_bits_lt", parameterToString(localVarOptionals.MaskBitsLt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaskBitsGt.IsSet() {
		localVarQueryParams.Add("mask_bits_gt", parameterToString(localVarOptionals.MaskBitsGt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarQueryParams.Add("description", parameterToString(localVarOptionals.Description.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RangeBegin.IsSet() {
		localVarQueryParams.Add("range_begin", parameterToString(localVarOptionals.RangeBegin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RangeEnd.IsSet() {
		localVarQueryParams.Add("range_end", parameterToString(localVarOptionals.RangeEnd.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Gateway.IsSet() {
		localVarQueryParams.Add("gateway", parameterToString(localVarOptionals.Gateway.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tags.IsSet() {
		localVarQueryParams.Add("tags", parameterToString(localVarOptionals.Tags.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TagsAnd.IsSet() {
		localVarQueryParams.Add("tags_and", parameterToString(localVarOptionals.TagsAnd.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CustomFieldsAnd.IsSet() {
		localVarQueryParams.Add("custom_fields_and", parameterToString(localVarOptionals.CustomFieldsAnd.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CustomFieldsOr.IsSet() {
		localVarQueryParams.Add("custom_fields_or", parameterToString(localVarOptionals.CustomFieldsOr.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ServiceLevel.IsSet() {
		localVarQueryParams.Add("service_level", parameterToString(localVarOptionals.ServiceLevel.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Category.IsSet() {
		localVarQueryParams.Add("category", parameterToString(localVarOptionals.Category.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CategoryId.IsSet() {
		localVarQueryParams.Add("category_id", parameterToString(localVarOptionals.CategoryId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VlanId.IsSet() {
		localVarQueryParams.Add("vlan_id", parameterToString(localVarOptionals.VlanId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Network.IsSet() {
		localVarQueryParams.Add("network", parameterToString(localVarOptionals.Network.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v InlineResponse2006
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
IPAMApiService GET method retrieves all VLANs.
Get all VLANs
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *IPAMApiGetIPAMvlansOpts - Optional Parameters:
     * @param "VlanId" (optional.String) -  ID of the vlan
     * @param "Number" (optional.String) -  vlan number
     * @param "Tags" (optional.String) -  filter by tags. comma separated for multiple tags (This is an OR filter, gets all the devices for all comma separated tags)
     * @param "TagsAnd" (optional.String) -  filter by all the tags, separated by comma. (This is an AND filter and all tags have to match for filter, this was added in v6.3.1)

@return InlineResponse2009
*/

type IPAMApiGetIPAMvlansOpts struct { 
	VlanId optional.String
	Number optional.String
	Tags optional.String
	TagsAnd optional.String
}

func (a *IPAMApiService) GetIPAMvlans(ctx context.Context, localVarOptionals *IPAMApiGetIPAMvlansOpts) (InlineResponse2009, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponse2009
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/vlans/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.VlanId.IsSet() {
		localVarQueryParams.Add("vlan_id", parameterToString(localVarOptionals.VlanId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Number.IsSet() {
		localVarQueryParams.Add("number", parameterToString(localVarOptionals.Number.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tags.IsSet() {
		localVarQueryParams.Add("tags", parameterToString(localVarOptionals.Tags.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TagsAnd.IsSet() {
		localVarQueryParams.Add("tags_and", parameterToString(localVarOptionals.TagsAnd.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v InlineResponse2009
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
IPAMApiService Get VLAN by ID
GET method retrieves VLAN by specific VLAN ID.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id

@return IpaMvlans
*/
func (a *IPAMApiService) GetIPAMvlansId(ctx context.Context, id int32) (IpaMvlans, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue IpaMvlans
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/vlans/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v IpaMvlans
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
IPAMApiService GET method retrieves all VRF Groups.
Get all VRF Groups
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

@return []InlineResponse2004
*/
func (a *IPAMApiService) GetIPAMvrfgroup(ctx context.Context) ([]InlineResponse2004, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []InlineResponse2004
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/vrfgroup/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []InlineResponse2004
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
IPAMApiService Create DNS Records.
Create / Update DNS Records
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param domain name of the domain
 * @param type_ Type of record
 * @param optional nil or *IPAMApiPostIPAMDnsRecordsOpts - Optional Parameters:
     * @param "Nameserver" (optional.String) -  If you have overlapping domain names, this is required to differentiate between the two
     * @param "Name" (optional.String) -  Record value (e.g. www) use @ for blank.
     * @param "Content" (optional.String) -  Content (e.g. IP address for type A)
     * @param "Prio" (optional.String) -  Priority for MX record.
     * @param "Ttl" (optional.String) -  TTL Value
     * @param "Tags" (optional.String) -  set tags for record
     * @param "TagsRemove" (optional.String) -  remove tags for record

@return interface{}
*/

type IPAMApiPostIPAMDnsRecordsOpts struct { 
	Nameserver optional.String
	Name optional.String
	Content optional.String
	Prio optional.String
	Ttl optional.String
	Tags optional.String
	TagsRemove optional.String
}

func (a *IPAMApiService) PostIPAMDnsRecords(ctx context.Context, domain string, type_ string, localVarOptionals *IPAMApiPostIPAMDnsRecordsOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/dns/records/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("domain", parameterToString(domain, ""))
	localVarFormParams.Add("type", parameterToString(type_, ""))
	if localVarOptionals != nil && localVarOptionals.Nameserver.IsSet() {
		localVarFormParams.Add("nameserver", parameterToString(localVarOptionals.Nameserver.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarFormParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Content.IsSet() {
		localVarFormParams.Add("content", parameterToString(localVarOptionals.Content.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Prio.IsSet() {
		localVarFormParams.Add("prio", parameterToString(localVarOptionals.Prio.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Ttl.IsSet() {
		localVarFormParams.Add("ttl", parameterToString(localVarOptionals.Ttl.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tags.IsSet() {
		localVarFormParams.Add("tags", parameterToString(localVarOptionals.Tags.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TagsRemove.IsSet() {
		localVarFormParams.Add("tags_remove", parameterToString(localVarOptionals.TagsRemove.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
IPAMApiService Create DNS Zones.
Create / Update DNS Zones
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Name of DNS zone
 * @param nameserver IP Address/hostname of name server
 * @param optional nil or *IPAMApiPostIPAMDnsZonesOpts - Optional Parameters:
     * @param "Notes" (optional.String) -  Any additional notes
     * @param "VrfGroup" (optional.String) -  VRF group name
     * @param "VrfGroupId" (optional.String) -  ID of the VRF group
     * @param "Tags" (optional.String) -  Tags for grouping zone entries
     * @param "TagsRemove" (optional.String) -  remove tags from grouping zone entries

@return interface{}
*/

type IPAMApiPostIPAMDnsZonesOpts struct { 
	Notes optional.String
	VrfGroup optional.String
	VrfGroupId optional.String
	Tags optional.String
	TagsRemove optional.String
}

func (a *IPAMApiService) PostIPAMDnsZones(ctx context.Context, name string, nameserver string, localVarOptionals *IPAMApiPostIPAMDnsZonesOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/dns/zones/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("name", parameterToString(name, ""))
	localVarFormParams.Add("nameserver", parameterToString(nameserver, ""))
	if localVarOptionals != nil && localVarOptionals.Notes.IsSet() {
		localVarFormParams.Add("notes", parameterToString(localVarOptionals.Notes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VrfGroup.IsSet() {
		localVarFormParams.Add("vrf_group", parameterToString(localVarOptionals.VrfGroup.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VrfGroupId.IsSet() {
		localVarFormParams.Add("vrf_group_id", parameterToString(localVarOptionals.VrfGroupId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tags.IsSet() {
		localVarFormParams.Add("tags", parameterToString(localVarOptionals.Tags.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TagsRemove.IsSet() {
		localVarFormParams.Add("tags_remove", parameterToString(localVarOptionals.TagsRemove.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
IPAMApiService Create IP NAT.
Create IP NAT
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Name of the NAT IP entry
 * @param ipAddressFrom The external IP address
 * @param ipAddressTo The internal IP address
 * @param optional nil or *IPAMApiPostIPAMIpnatOpts - Optional Parameters:
     * @param "IpAddressFromEnd" (optional.String) -  used for mapping a range of addresses rather than a single IP
     * @param "SourcePortStart" (optional.String) -  Starting port for source IP range
     * @param "SourcePortEnd" (optional.String) -  used for mapping a range of ports rather than a single port
     * @param "IpAddressToEnd" (optional.String) -  used for mapping a range of addresses rather than a single IP
     * @param "TargetPortStart" (optional.String) -  Starting port for target IP range
     * @param "TargetPortEnd" (optional.String) -  used for mapping a range of ports rather than a single port
     * @param "TwoWayRelation" (optional.String) -  true if the internal IP addressed is masked with the external IP address for outbound traffic in addition to inbound traffic. Default is false.
     * @param "Protocol" (optional.String) -  the transport protocol, ie TCP
     * @param "Notes" (optional.String) -  Any additional notes
     * @param "VrfGroupFrom" (optional.String) -  Originating VRF Group Name
     * @param "VrfGroupIdFrom" (optional.String) -  Originating VRF Group ID
     * @param "VrfGroupTo" (optional.String) -  Destination VRF Group Name
     * @param "VrfGroupIdTo" (optional.String) -  Destination VRF Group ID

@return interface{}
*/

type IPAMApiPostIPAMIpnatOpts struct { 
	IpAddressFromEnd optional.String
	SourcePortStart optional.String
	SourcePortEnd optional.String
	IpAddressToEnd optional.String
	TargetPortStart optional.String
	TargetPortEnd optional.String
	TwoWayRelation optional.String
	Protocol optional.String
	Notes optional.String
	VrfGroupFrom optional.String
	VrfGroupIdFrom optional.String
	VrfGroupTo optional.String
	VrfGroupIdTo optional.String
}

func (a *IPAMApiService) PostIPAMIpnat(ctx context.Context, name string, ipAddressFrom string, ipAddressTo string, localVarOptionals *IPAMApiPostIPAMIpnatOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/ipnat/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("name", parameterToString(name, ""))
	localVarFormParams.Add("ip_address_from", parameterToString(ipAddressFrom, ""))
	if localVarOptionals != nil && localVarOptionals.IpAddressFromEnd.IsSet() {
		localVarFormParams.Add("ip_address_from_end", parameterToString(localVarOptionals.IpAddressFromEnd.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SourcePortStart.IsSet() {
		localVarFormParams.Add("source_port_start", parameterToString(localVarOptionals.SourcePortStart.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SourcePortEnd.IsSet() {
		localVarFormParams.Add("source_port_end", parameterToString(localVarOptionals.SourcePortEnd.Value(), ""))
	}
	localVarFormParams.Add("ip_address_to", parameterToString(ipAddressTo, ""))
	if localVarOptionals != nil && localVarOptionals.IpAddressToEnd.IsSet() {
		localVarFormParams.Add("ip_address_to_end", parameterToString(localVarOptionals.IpAddressToEnd.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TargetPortStart.IsSet() {
		localVarFormParams.Add("target_port_start", parameterToString(localVarOptionals.TargetPortStart.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TargetPortEnd.IsSet() {
		localVarFormParams.Add("target_port_end", parameterToString(localVarOptionals.TargetPortEnd.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TwoWayRelation.IsSet() {
		localVarFormParams.Add("two_way_relation", parameterToString(localVarOptionals.TwoWayRelation.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Protocol.IsSet() {
		localVarFormParams.Add("protocol", parameterToString(localVarOptionals.Protocol.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Notes.IsSet() {
		localVarFormParams.Add("notes", parameterToString(localVarOptionals.Notes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VrfGroupFrom.IsSet() {
		localVarFormParams.Add("vrf_group_from", parameterToString(localVarOptionals.VrfGroupFrom.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VrfGroupIdFrom.IsSet() {
		localVarFormParams.Add("vrf_group_id_from", parameterToString(localVarOptionals.VrfGroupIdFrom.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VrfGroupTo.IsSet() {
		localVarFormParams.Add("vrf_group_to", parameterToString(localVarOptionals.VrfGroupTo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VrfGroupIdTo.IsSet() {
		localVarFormParams.Add("vrf_group_id_to", parameterToString(localVarOptionals.VrfGroupIdTo.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
IPAMApiService Create / Update IP Addresses.
Create / Update IP Addresses
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param ipaddress If a matching IP address is found, it will update the first matched IP address(unless you specify a vrf_group or vrf_group_id, then it matches or adds IP to that VRF group)
 * @param optional nil or *IPAMApiPostIPAMIpsOpts - Optional Parameters:
     * @param "Label" (optional.String) -  label for the interface (tag still works for backward compatibility)
     * @param "Subnet" (optional.String) -  name of the subnet you want to add the IP to. Must be unique. The reason it must be unique is to handle overlapping subnet ranges. The unique name enable selection of the correct subnet. Ignored if vrf_group_id or vrf_group is present in the arguments. Works only when adding a new IP. For existing IPs, use VRF group parameters.
     * @param "Macaddress" (optional.String) -  MAC address – can be new or existing
     * @param "Device" (optional.String) -  device name, can be new or existing
     * @param "Type_" (optional.String) - 
     * @param "Notes" (optional.String) -  Any additional notes
     * @param "VrfGroupId" (optional.String) -  ID of the VRF group
     * @param "VrfGroup" (optional.String) -  VRF group name
     * @param "Available" (optional.String) - 
     * @param "ClearAll" (optional.String) -  If yes - then IP is marked as available and device and mac address associations are cleared. Also notes and label fields are cleared. Added in v5.7.2
     * @param "Tags" (optional.String) -  Update IP address tags (note, different than the antiquated tag endpoint. See label parameter above)

@return interface{}
*/

type IPAMApiPostIPAMIpsOpts struct { 
	Label optional.String
	Subnet optional.String
	Macaddress optional.String
	Device optional.String
	Type_ optional.String
	Notes optional.String
	VrfGroupId optional.String
	VrfGroup optional.String
	Available optional.String
	ClearAll optional.String
	Tags optional.String
}

func (a *IPAMApiService) PostIPAMIps(ctx context.Context, ipaddress string, localVarOptionals *IPAMApiPostIPAMIpsOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/ips/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("ipaddress", parameterToString(ipaddress, ""))
	if localVarOptionals != nil && localVarOptionals.Label.IsSet() {
		localVarFormParams.Add("label", parameterToString(localVarOptionals.Label.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Subnet.IsSet() {
		localVarFormParams.Add("subnet", parameterToString(localVarOptionals.Subnet.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Macaddress.IsSet() {
		localVarFormParams.Add("macaddress", parameterToString(localVarOptionals.Macaddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Device.IsSet() {
		localVarFormParams.Add("device", parameterToString(localVarOptionals.Device.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarFormParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Notes.IsSet() {
		localVarFormParams.Add("notes", parameterToString(localVarOptionals.Notes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VrfGroupId.IsSet() {
		localVarFormParams.Add("vrf_group_id", parameterToString(localVarOptionals.VrfGroupId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VrfGroup.IsSet() {
		localVarFormParams.Add("vrf_group", parameterToString(localVarOptionals.VrfGroup.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Available.IsSet() {
		localVarFormParams.Add("available", parameterToString(localVarOptionals.Available.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ClearAll.IsSet() {
		localVarFormParams.Add("clear_all", parameterToString(localVarOptionals.ClearAll.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tags.IsSet() {
		localVarFormParams.Add("tags", parameterToString(localVarOptionals.Tags.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
IPAMApiService Create / Update MAC Addresses.
Create / Update MAC Addresses. Deprecated since v12.0. Please use /switchports/ for more detailed information.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *IPAMApiPostIPAMMacsOpts - Optional Parameters:
     * @param "Macaddress" (optional.String) -  MAC address – can be new or existing
     * @param "PortName" (optional.String) -  Interface name. (Please note: This is NOT the switchport name.)
     * @param "Override" (optional.String) -  smart – will detect if the port_name passed exist or not, if not – it is added to the current port name. Helpful, if you want to track all the port names for that mac address (e.g. eth0 &amp; bond0).&lt;br&gt;yes – change the port name. This is default behavior even if you don’t pass this parameter&lt;br&gt;no – will not change the port name
     * @param "VlanId" (optional.String) -  ID of the vlan
     * @param "Device" (optional.String) -  name of the device
     * @param "PortId" (optional.String) -  Use this parameter or a combination of port and switch to specify the port.
     * @param "Port" (optional.String) -  Refers to the switchport name (not the interface name) - Use with parameter switch
     * @param "Switch_" (optional.String) -  Refers to the device name of the switch

@return interface{}
*/

type IPAMApiPostIPAMMacsOpts struct { 
	Macaddress optional.String
	PortName optional.String
	Override optional.String
	VlanId optional.String
	Device optional.String
	PortId optional.String
	Port optional.String
	Switch_ optional.String
}

func (a *IPAMApiService) PostIPAMMacs(ctx context.Context, localVarOptionals *IPAMApiPostIPAMMacsOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/macs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Macaddress.IsSet() {
		localVarFormParams.Add("macaddress", parameterToString(localVarOptionals.Macaddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PortName.IsSet() {
		localVarFormParams.Add("port_name", parameterToString(localVarOptionals.PortName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Override.IsSet() {
		localVarFormParams.Add("override", parameterToString(localVarOptionals.Override.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VlanId.IsSet() {
		localVarFormParams.Add("vlan_id", parameterToString(localVarOptionals.VlanId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Device.IsSet() {
		localVarFormParams.Add("device", parameterToString(localVarOptionals.Device.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PortId.IsSet() {
		localVarFormParams.Add("port_id", parameterToString(localVarOptionals.PortId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Port.IsSet() {
		localVarFormParams.Add("port", parameterToString(localVarOptionals.Port.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Switch_.IsSet() {
		localVarFormParams.Add("switch", parameterToString(localVarOptionals.Switch_.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
IPAMApiService Create child Subnet.
Create Child Subnet. Required parameters: &lt;ul&gt;&lt;li&gt;mask_bits&lt;/li&gt; &lt;li&gt;parent_subnet_id &lt;b&gt;OR&lt;/b&gt; vrf_group &lt;b&gt;OR&lt;/b&gt; vrf_group_id&lt;/li&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param maskBits e.g. 24
 * @param optional nil or *IPAMApiPostIPAMSubnetsCreateChildOpts - Optional Parameters:
     * @param "ParentSubnetId" (optional.String) -  ID of the parent subnet. Can be obtained via /api/api/1.0/subnets/ or Tools &gt; Export &gt; Subnet. Required if vrf_group and vrf_group_id are not present.
     * @param "VrfGroup" (optional.String) -  Name of the VRF group. Required if parent_subnet_id or vrf_group_id are not present.
     * @param "VrfGroupId" (optional.String) -  ID of the VRF group. Required if parent_subnet_id or vrf_group are not present.
     * @param "ParentMaskBits" (optional.String) -  only if searching within a VRF and you want to restrict to certain parents with particular mask bits (added in v9.0.0)
     * @param "Ipv6" (optional.String) -  Required if creating an ipv6 subnet
     * @param "Network" (optional.String) - 
     * @param "SubnetId" (optional.String) - 

@return InlineResponse2008
*/

type IPAMApiPostIPAMSubnetsCreateChildOpts struct { 
	ParentSubnetId optional.String
	VrfGroup optional.String
	VrfGroupId optional.String
	ParentMaskBits optional.String
	Ipv6 optional.String
	Network optional.String
	SubnetId optional.String
}

func (a *IPAMApiService) PostIPAMSubnetsCreateChild(ctx context.Context, maskBits string, localVarOptionals *IPAMApiPostIPAMSubnetsCreateChildOpts) (InlineResponse2008, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue InlineResponse2008
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/subnets/create_child/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("mask_bits", parameterToString(maskBits, ""))
	if localVarOptionals != nil && localVarOptionals.ParentSubnetId.IsSet() {
		localVarFormParams.Add("parent_subnet_id", parameterToString(localVarOptionals.ParentSubnetId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VrfGroup.IsSet() {
		localVarFormParams.Add("vrf_group", parameterToString(localVarOptionals.VrfGroup.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VrfGroupId.IsSet() {
		localVarFormParams.Add("vrf_group_id", parameterToString(localVarOptionals.VrfGroupId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ParentMaskBits.IsSet() {
		localVarFormParams.Add("parent_mask_bits", parameterToString(localVarOptionals.ParentMaskBits.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Ipv6.IsSet() {
		localVarFormParams.Add("ipv6", parameterToString(localVarOptionals.Ipv6.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Network.IsSet() {
		localVarFormParams.Add("network", parameterToString(localVarOptionals.Network.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SubnetId.IsSet() {
		localVarFormParams.Add("subnet_id", parameterToString(localVarOptionals.SubnetId.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v InlineResponse2008
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
IPAMApiService Add Switch/Switch Ports w/ Templates.
Create or update using Switch Templates. Required parameters: &lt;ul&gt;&lt;li&gt;device &lt;b&gt;OR&lt;/b&gt; device_id&lt;/li&gt; &lt;li&gt;switch_template_id&lt;/li&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param switchTemplateId GET all Switch Templates
 * @param optional nil or *IPAMApiPostIPAMSwitchesOpts - Optional Parameters:
     * @param "Device" (optional.String) -  Name of new or existing device. Existing device must be a network switch. If stacked switches, must be of type &#39;cluster&#39;
     * @param "DeviceId" (optional.String) -  ID of existing device. Existing device must be a network switch. IF stacked switches, must be of type &#39;cluster&#39;
     * @param "Devices" (optional.String) -  comma separated names of new devices.
     * @param "DeviceIds" (optional.String) -  comma separated values of existing devices.
     * @param "Assets" (optional.String) -  comma separated names of new assets.
     * @param "AssetIds" (optional.String) -  comma separated values of existing assets.

@return interface{}
*/

type IPAMApiPostIPAMSwitchesOpts struct { 
	Device optional.String
	DeviceId optional.String
	Devices optional.String
	DeviceIds optional.String
	Assets optional.String
	AssetIds optional.String
}

func (a *IPAMApiService) PostIPAMSwitches(ctx context.Context, switchTemplateId string, localVarOptionals *IPAMApiPostIPAMSwitchesOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/switches/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Device.IsSet() {
		localVarFormParams.Add("device", parameterToString(localVarOptionals.Device.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceId.IsSet() {
		localVarFormParams.Add("device_id", parameterToString(localVarOptionals.DeviceId.Value(), ""))
	}
	localVarFormParams.Add("switch_template_id", parameterToString(switchTemplateId, ""))
	if localVarOptionals != nil && localVarOptionals.Devices.IsSet() {
		localVarFormParams.Add("devices", parameterToString(localVarOptionals.Devices.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceIds.IsSet() {
		localVarFormParams.Add("device_ids", parameterToString(localVarOptionals.DeviceIds.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Assets.IsSet() {
		localVarFormParams.Add("assets", parameterToString(localVarOptionals.Assets.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AssetIds.IsSet() {
		localVarFormParams.Add("asset_ids", parameterToString(localVarOptionals.AssetIds.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
IPAMApiService Create / Update Switch Port by Port.
Create / Update Switch Ports. &lt;b&gt;port&lt;/b&gt; or &lt;b&gt;hwaddress&lt;/b&gt; are required.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *IPAMApiPostIPAMSwitchportsOpts - Optional Parameters:
     * @param "Port" (optional.String) -  child is optional assuming you have a parent created. Required if no hwaddress&lt;br&gt;Note: Do not use a port alias for the port name.
     * @param "Hwaddress" (optional.String) -  mac or wwn. Required if no port.
     * @param "NewPort" (optional.String) -  rename exisiting port
     * @param "Switch_" (optional.String) -  d42 will look for existing port and switch combination and if it exists, will update that port.
     * @param "Description" (optional.String) - 
     * @param "Type_" (optional.String) -  Must exist in device42 (add via UI)
     * @param "VlanId" (optional.String) -  ID of the vlan
     * @param "Up" (optional.String) -  &#x3D; yes for up. &#x3D; no for down.
     * @param "UpAdmin" (optional.String) -  Whether port is administratively up or down. &#x3D; yes for up. &#x3D; no for down.
     * @param "Count" (optional.String) -  Whether to include the port in total count or not.
     * @param "RemotePortId" (optional.String) -  ID of the remote connected switch port.
     * @param "RemoteDevice" (optional.String) -  Name of the switch for remote connected switch port.
     * @param "RemotePort" (optional.String) -  Name of the port for remote connected switch port.
     * @param "Module" (optional.String) -  name of the blade that port belongs to. Blade device must be part of the switch. (added in v5.8.1)
     * @param "Device2" (optional.String) -  name of the device2 that port belongs to. (added in v5.8.1)
     * @param "Device" (optional.String) -  name of the direcly connected device (Added in v5.8.2) (used to connect remote port for legacy support)
     * @param "Label" (optional.String) - 
     * @param "Tags" (optional.String) -  add or update tags to a switchport
     * @param "TagsRemove" (optional.String) -  remove tags from a switchport
     * @param "Mtu" (optional.String) -  add value for mtu
     * @param "Name" (optional.String) -  add name of port
     * @param "Speed" (optional.String) -  update port speed
     * @param "RemotePortClear" (optional.String) -  if set to yes, will clear the remote port
     * @param "ParentPort" (optional.String) - 
     * @param "ParentPortDevice" (optional.String) - 
     * @param "SlavePorts" (optional.String) -  comma separated port names

@return interface{}
*/

type IPAMApiPostIPAMSwitchportsOpts struct { 
	Port optional.String
	Hwaddress optional.String
	NewPort optional.String
	Switch_ optional.String
	Description optional.String
	Type_ optional.String
	VlanId optional.String
	Up optional.String
	UpAdmin optional.String
	Count optional.String
	RemotePortId optional.String
	RemoteDevice optional.String
	RemotePort optional.String
	Module optional.String
	Device2 optional.String
	Device optional.String
	Label optional.String
	Tags optional.String
	TagsRemove optional.String
	Mtu optional.String
	Name optional.String
	Speed optional.String
	RemotePortClear optional.String
	ParentPort optional.String
	ParentPortDevice optional.String
	SlavePorts optional.String
}

func (a *IPAMApiService) PostIPAMSwitchports(ctx context.Context, localVarOptionals *IPAMApiPostIPAMSwitchportsOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/switchports"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Port.IsSet() {
		localVarFormParams.Add("port", parameterToString(localVarOptionals.Port.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Hwaddress.IsSet() {
		localVarFormParams.Add("hwaddress", parameterToString(localVarOptionals.Hwaddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NewPort.IsSet() {
		localVarFormParams.Add("new_port", parameterToString(localVarOptionals.NewPort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Switch_.IsSet() {
		localVarFormParams.Add("switch", parameterToString(localVarOptionals.Switch_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarFormParams.Add("description", parameterToString(localVarOptionals.Description.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarFormParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VlanId.IsSet() {
		localVarFormParams.Add("vlan_id", parameterToString(localVarOptionals.VlanId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Up.IsSet() {
		localVarFormParams.Add("up", parameterToString(localVarOptionals.Up.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UpAdmin.IsSet() {
		localVarFormParams.Add("up_admin", parameterToString(localVarOptionals.UpAdmin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Count.IsSet() {
		localVarFormParams.Add("count", parameterToString(localVarOptionals.Count.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RemotePortId.IsSet() {
		localVarFormParams.Add("remote_port_id", parameterToString(localVarOptionals.RemotePortId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RemoteDevice.IsSet() {
		localVarFormParams.Add("remote_device", parameterToString(localVarOptionals.RemoteDevice.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RemotePort.IsSet() {
		localVarFormParams.Add("remote_port", parameterToString(localVarOptionals.RemotePort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Module.IsSet() {
		localVarFormParams.Add("module", parameterToString(localVarOptionals.Module.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Device2.IsSet() {
		localVarFormParams.Add("device2", parameterToString(localVarOptionals.Device2.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Device.IsSet() {
		localVarFormParams.Add("device", parameterToString(localVarOptionals.Device.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Label.IsSet() {
		localVarFormParams.Add("label", parameterToString(localVarOptionals.Label.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tags.IsSet() {
		localVarFormParams.Add("tags", parameterToString(localVarOptionals.Tags.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TagsRemove.IsSet() {
		localVarFormParams.Add("tags_remove", parameterToString(localVarOptionals.TagsRemove.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Mtu.IsSet() {
		localVarFormParams.Add("mtu", parameterToString(localVarOptionals.Mtu.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarFormParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Speed.IsSet() {
		localVarFormParams.Add("speed", parameterToString(localVarOptionals.Speed.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RemotePortClear.IsSet() {
		localVarFormParams.Add("remote_port_clear", parameterToString(localVarOptionals.RemotePortClear.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ParentPort.IsSet() {
		localVarFormParams.Add("parent_port", parameterToString(localVarOptionals.ParentPort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ParentPortDevice.IsSet() {
		localVarFormParams.Add("parent_port_device", parameterToString(localVarOptionals.ParentPortDevice.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SlavePorts.IsSet() {
		localVarFormParams.Add("slave_ports", parameterToString(localVarOptionals.SlavePorts.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
IPAMApiService Create / Update TAP Ports
Create / Update TAP Ports. Required parameters: &lt;ul&gt;&lt;li&gt;id &lt;b&gt;OR&lt;/b&gt; name&lt;/li&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *IPAMApiPostIPAMTapPortsOpts - Optional Parameters:
     * @param "Id" (optional.String) -  Tap Port ID
     * @param "Name" (optional.String) - 
     * @param "Label" (optional.String) - 
     * @param "MonitorDirection" (optional.String) -  Direction - to, both (optional, only for PortCap: Monitor)
     * @param "MonitorPort1Id" (optional.String) - 
     * @param "MonitorPort2Id" (optional.String) - 
     * @param "MorrorPort" (optional.String) - 
     * @param "NetportId" (optional.String) - 
     * @param "PatchPanelPortId" (optional.String) - 
     * @param "PortCapability" (optional.String) -  Port Capability - Device, Monitor
     * @param "PortToFromId" (optional.String) - 
     * @param "PortType" (optional.String) -  Port Type name - RJ45, RJ11, Fiber SC, Fiber FC
     * @param "PortTypeId" (optional.String) - 

@return interface{}
*/

type IPAMApiPostIPAMTapPortsOpts struct { 
	Id optional.String
	Name optional.String
	Label optional.String
	MonitorDirection optional.String
	MonitorPort1Id optional.String
	MonitorPort2Id optional.String
	MorrorPort optional.String
	NetportId optional.String
	PatchPanelPortId optional.String
	PortCapability optional.String
	PortToFromId optional.String
	PortType optional.String
	PortTypeId optional.String
}

func (a *IPAMApiService) PostIPAMTapPorts(ctx context.Context, localVarOptionals *IPAMApiPostIPAMTapPortsOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/tap_ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarFormParams.Add("id", parameterToString(localVarOptionals.Id.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarFormParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Label.IsSet() {
		localVarFormParams.Add("label", parameterToString(localVarOptionals.Label.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MonitorDirection.IsSet() {
		localVarFormParams.Add("monitor_direction", parameterToString(localVarOptionals.MonitorDirection.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MonitorPort1Id.IsSet() {
		localVarFormParams.Add("monitor_port_1_id", parameterToString(localVarOptionals.MonitorPort1Id.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MonitorPort2Id.IsSet() {
		localVarFormParams.Add("monitor_port_2_id", parameterToString(localVarOptionals.MonitorPort2Id.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MorrorPort.IsSet() {
		localVarFormParams.Add("morror_port", parameterToString(localVarOptionals.MorrorPort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NetportId.IsSet() {
		localVarFormParams.Add("netport_id", parameterToString(localVarOptionals.NetportId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PatchPanelPortId.IsSet() {
		localVarFormParams.Add("patch_panel_port_id", parameterToString(localVarOptionals.PatchPanelPortId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PortCapability.IsSet() {
		localVarFormParams.Add("port_capability", parameterToString(localVarOptionals.PortCapability.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PortToFromId.IsSet() {
		localVarFormParams.Add("port_to_from_id", parameterToString(localVarOptionals.PortToFromId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PortType.IsSet() {
		localVarFormParams.Add("port_type", parameterToString(localVarOptionals.PortType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PortTypeId.IsSet() {
		localVarFormParams.Add("port_type_id", parameterToString(localVarOptionals.PortTypeId.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
IPAMApiService
Create Subnet Category.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Name of the Subnet Category you want to add edit or create
 * @param optional nil or *IPAMApiPostIPAMsubnetcategoryOpts - Optional Parameters:
     * @param "Description" (optional.String) - 
     * @param "IsItDefault" (optional.String) -  Defaults to no. Only one category can be yes. If yes, this is the subnet category to use if none specified in an API or auto-discovery update.
     * @param "Groups" (optional.String) -  If multitenancy is on, admin groups that have access to this object are specified here, e.g. Prod_East:no,Corp:yes specifies that the admin groups for this object are Prod_East with view only permission and Corp with change permission. If this parameter is present with no value, all groups are deleted.


*/

type IPAMApiPostIPAMsubnetcategoryOpts struct { 
	Description optional.String
	IsItDefault optional.String
	Groups optional.String
}

func (a *IPAMApiService) PostIPAMsubnetcategory(ctx context.Context, name string, localVarOptionals *IPAMApiPostIPAMsubnetcategoryOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/subnet_category/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("name", parameterToString(name, ""))
	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarFormParams.Add("description", parameterToString(localVarOptionals.Description.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsItDefault.IsSet() {
		localVarFormParams.Add("is_it_default", parameterToString(localVarOptionals.IsItDefault.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Groups.IsSet() {
		localVarFormParams.Add("groups", parameterToString(localVarOptionals.Groups.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
IPAMApiService Create / Update Subnets.
Create / Update Subnets
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param network Required for creation, cannot be modified after subnet creation.
 * @param maskBits Cannot be modified after subnet creation
 * @param optional nil or *IPAMApiPostIPAMsubnetsOpts - Optional Parameters:
     * @param "VrfGroupId" (optional.String) -  ID of the VRF group
     * @param "VrfGroup" (optional.String) -  VRF group name
     * @param "Name" (optional.String) - 
     * @param "Description" (optional.String) - 
     * @param "Gateway" (optional.String) -  Gateway (added in v7.2.0)
     * @param "RangeBegin" (optional.String) -  Range Begin (added in v7.2.0)
     * @param "RangeEnd" (optional.String) -  Range End (added in v7.2.0)
     * @param "ParentVlanId" (optional.String) - 
     * @param "ParentSubnetId" (optional.String) -  Change the parent subnet of the subnet. Note: must be valid parent.
     * @param "CustomerId" (optional.String) - 
     * @param "Notes" (optional.String) -  Any additional notes
     * @param "ServiceLevel" (optional.String) -  Must already exist
     * @param "Assigned" (optional.String) -  ‘yes’ if assigned. ‘no’ (default) if unassigned.
     * @param "Allocated" (optional.String) -  ‘yes’ if allocated. ‘no’ (default) if unallocated.
     * @param "AutoAddIps" (optional.String) -  If ‘yes’, addresses within subnet will be automatically added to Device42. (Only available in POST)
     * @param "Category" (optional.String) -  If multitenancy is on, admin groups that have access to this object are specified here, e.g. Prod_East:no, Corp:yes specifies that the admin groups for this object are Prod_East with view only permission and Corp with change permission. Use for initial insert.
     * @param "NewCategory" (optional.String) -  Use new_category to update an existing category.
     * @param "CategoryId" (optional.String) -  ID of the category - use for initial insert.
     * @param "NewCategoryId" (optional.String) -  Use new_category_id to update an existing category ID.

@return interface{}
*/

type IPAMApiPostIPAMsubnetsOpts struct { 
	VrfGroupId optional.String
	VrfGroup optional.String
	Name optional.String
	Description optional.String
	Gateway optional.String
	RangeBegin optional.String
	RangeEnd optional.String
	ParentVlanId optional.String
	ParentSubnetId optional.String
	CustomerId optional.String
	Notes optional.String
	ServiceLevel optional.String
	Assigned optional.String
	Allocated optional.String
	AutoAddIps optional.String
	Category optional.String
	NewCategory optional.String
	CategoryId optional.String
	NewCategoryId optional.String
}

func (a *IPAMApiService) PostIPAMsubnets(ctx context.Context, network string, maskBits string, localVarOptionals *IPAMApiPostIPAMsubnetsOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/subnets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("network", parameterToString(network, ""))
	localVarFormParams.Add("mask_bits", parameterToString(maskBits, ""))
	if localVarOptionals != nil && localVarOptionals.VrfGroupId.IsSet() {
		localVarFormParams.Add("vrf_group_id", parameterToString(localVarOptionals.VrfGroupId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VrfGroup.IsSet() {
		localVarFormParams.Add("vrf_group", parameterToString(localVarOptionals.VrfGroup.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarFormParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarFormParams.Add("description", parameterToString(localVarOptionals.Description.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Gateway.IsSet() {
		localVarFormParams.Add("gateway", parameterToString(localVarOptionals.Gateway.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RangeBegin.IsSet() {
		localVarFormParams.Add("range_begin", parameterToString(localVarOptionals.RangeBegin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RangeEnd.IsSet() {
		localVarFormParams.Add("range_end", parameterToString(localVarOptionals.RangeEnd.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ParentVlanId.IsSet() {
		localVarFormParams.Add("parent_vlan_id", parameterToString(localVarOptionals.ParentVlanId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ParentSubnetId.IsSet() {
		localVarFormParams.Add("parent_subnet_id", parameterToString(localVarOptionals.ParentSubnetId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CustomerId.IsSet() {
		localVarFormParams.Add("customer_id", parameterToString(localVarOptionals.CustomerId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Notes.IsSet() {
		localVarFormParams.Add("notes", parameterToString(localVarOptionals.Notes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ServiceLevel.IsSet() {
		localVarFormParams.Add("service_level", parameterToString(localVarOptionals.ServiceLevel.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Assigned.IsSet() {
		localVarFormParams.Add("assigned", parameterToString(localVarOptionals.Assigned.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Allocated.IsSet() {
		localVarFormParams.Add("allocated", parameterToString(localVarOptionals.Allocated.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AutoAddIps.IsSet() {
		localVarFormParams.Add("auto_add_ips", parameterToString(localVarOptionals.AutoAddIps.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Category.IsSet() {
		localVarFormParams.Add("category", parameterToString(localVarOptionals.Category.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NewCategory.IsSet() {
		localVarFormParams.Add("new_category", parameterToString(localVarOptionals.NewCategory.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CategoryId.IsSet() {
		localVarFormParams.Add("category_id", parameterToString(localVarOptionals.CategoryId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NewCategoryId.IsSet() {
		localVarFormParams.Add("new_category_id", parameterToString(localVarOptionals.NewCategoryId.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
IPAMApiService Create VLANS.
Create VLANS
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param number VLAN
 * @param optional nil or *IPAMApiPostIPAMvlansOpts - Optional Parameters:
     * @param "Name" (optional.String) -  If left blank, name will be created as VLANxxxx, e.g. VLAN# 342 will be named VLAN0342
     * @param "Description" (optional.String) - 
     * @param "SwitchId" (optional.String) -  Comma separated values for switch_ids
     * @param "Notes" (optional.String) -  Any additional notes
     * @param "Groups" (optional.String) -  If multitenancy is on, admin groups that have access to this object are specified here, e.g. Prod_East:no,Corp:yes specifies that the admin groups for this object are Prod_East with view only permission and Corp with change permission. If this parameter is present with no value, all groups are deleted.

@return interface{}
*/

type IPAMApiPostIPAMvlansOpts struct { 
	Name optional.String
	Description optional.String
	SwitchId optional.String
	Notes optional.String
	Groups optional.String
}

func (a *IPAMApiService) PostIPAMvlans(ctx context.Context, number string, localVarOptionals *IPAMApiPostIPAMvlansOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/vlans/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("number", parameterToString(number, ""))
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarFormParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarFormParams.Add("description", parameterToString(localVarOptionals.Description.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SwitchId.IsSet() {
		localVarFormParams.Add("switch_id", parameterToString(localVarOptionals.SwitchId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Notes.IsSet() {
		localVarFormParams.Add("notes", parameterToString(localVarOptionals.Notes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Groups.IsSet() {
		localVarFormParams.Add("groups", parameterToString(localVarOptionals.Groups.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
IPAMApiService Update VLANS by ID in url.
Smart Merge VLANS
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *IPAMApiPostIPAMvlansSmartMergeAllOpts - Optional Parameters:
     * @param "Number" (optional.String) -  vlan number
     * @param "Name" (optional.String) - 
     * @param "Description" (optional.String) - 
     * @param "SwitchId" (optional.String) -  Comma separated values for switch_ids
     * @param "Notes" (optional.String) -  Any additional notes
     * @param "Groups" (optional.String) -  If multitenancy is on, admin groups that have access to this object are specified here, e.g. Prod_East:no,Corp:yes specifies that the admin groups for this object are Prod_East with view only permission and Corp with change permission. If this parameter is present with no value, all groups are deleted.

@return interface{}
*/

type IPAMApiPostIPAMvlansSmartMergeAllOpts struct { 
	Number optional.String
	Name optional.String
	Description optional.String
	SwitchId optional.String
	Notes optional.String
	Groups optional.String
}

func (a *IPAMApiService) PostIPAMvlansSmartMergeAll(ctx context.Context, localVarOptionals *IPAMApiPostIPAMvlansSmartMergeAllOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/vlans/smart_merge_all/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Number.IsSet() {
		localVarFormParams.Add("number", parameterToString(localVarOptionals.Number.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarFormParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarFormParams.Add("description", parameterToString(localVarOptionals.Description.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SwitchId.IsSet() {
		localVarFormParams.Add("switch_id", parameterToString(localVarOptionals.SwitchId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Notes.IsSet() {
		localVarFormParams.Add("notes", parameterToString(localVarOptionals.Notes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Groups.IsSet() {
		localVarFormParams.Add("groups", parameterToString(localVarOptionals.Groups.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
IPAMApiService Create/Update VRF Group.
Create/Update VRF Group
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Name of the VRF Group you want to add edit or create
 * @param optional nil or *IPAMApiPostIPAMvrfgroupOpts - Optional Parameters:
     * @param "Description" (optional.String) - 
     * @param "Groups" (optional.String) -  If multitenancy is on, admin groups that have access to this object are specified here, e.g. Prod_East:no,Corp:yes specifies that the admin groups for this object are Prod_East with view only permission and Corp with change permission. If this parameter is present with no value, all groups are deleted.
     * @param "Buildings" (optional.String) -  list of building names for the VRF Group

@return interface{}
*/

type IPAMApiPostIPAMvrfgroupOpts struct { 
	Description optional.String
	Groups optional.String
	Buildings optional.String
}

func (a *IPAMApiService) PostIPAMvrfgroup(ctx context.Context, name string, localVarOptionals *IPAMApiPostIPAMvrfgroupOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/vrfgroup/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("name", parameterToString(name, ""))
	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarFormParams.Add("description", parameterToString(localVarOptionals.Description.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Groups.IsSet() {
		localVarFormParams.Add("groups", parameterToString(localVarOptionals.Groups.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Buildings.IsSet() {
		localVarFormParams.Add("buildings", parameterToString(localVarOptionals.Buildings.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
IPAMApiService Create/update custom fields for subnets.
Subnet Custom Fields
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param ipAddress IP address
 * @param subnetId Subnet ID
 * @param key Can be new or existing. This is the custom field name.
 * @param optional nil or *IPAMApiPutIPAMCustomFIipAddressOpts - Optional Parameters:
     * @param "Type_" (optional.String) -  this is the custom field type. If left blank, default is text. Additional options: number,date(text formatted yyyy-mm-dd), related_field(with related_field_name), boolean or url
     * @param "RelatedFieldName" (optional.String) -  The existing field to relate this custom field to. Can be: appcomp (for application components), asset, building, certificate, circuit, cusotmer, device, endusers, hardware (for device hardware models), ip_address, natip, netport (for ports), os, part, partmodel, password, pdu (for power units), pdu_model (for power unit models), ports, purchase, purchaselineitem (for a line item on a purchase order), rack, room, software, vlan (for subnets), switch_vlan (for vlans), vrfgroup
     * @param "AddToPicklist" (optional.String) -  Comma separated values to add to picklist. If type is picklist and custom field is new, this is a required field. Duplicates will be ignored.
     * @param "Value" (optional.String) -  Value of the custom field.
     * @param "ClearValue" (optional.String) -  yes to clear existing value for that field
     * @param "Notes" (optional.String) -  Any additional notes.
     * @param "ClearNotes" (optional.String) -  Yes to clear any existing notes.
     * @param "BulkFields" (optional.String) -  comma separated key value pairs, with key and value separated by colon. e.g.key1:value1, key2:value2

@return interface{}
*/

type IPAMApiPutIPAMCustomFIipAddressOpts struct { 
	Type_ optional.String
	RelatedFieldName optional.String
	AddToPicklist optional.String
	Value optional.String
	ClearValue optional.String
	Notes optional.String
	ClearNotes optional.String
	BulkFields optional.String
}

func (a *IPAMApiService) PutIPAMCustomFIipAddress(ctx context.Context, ipAddress string, subnetId string, key string, localVarOptionals *IPAMApiPutIPAMCustomFIipAddressOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/custom_fields/ip_address/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("ip_address", parameterToString(ipAddress, ""))
	localVarFormParams.Add("subnet_id", parameterToString(subnetId, ""))
	localVarFormParams.Add("key", parameterToString(key, ""))
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarFormParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RelatedFieldName.IsSet() {
		localVarFormParams.Add("related_field_name", parameterToString(localVarOptionals.RelatedFieldName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AddToPicklist.IsSet() {
		localVarFormParams.Add("add_to_picklist", parameterToString(localVarOptionals.AddToPicklist.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Value.IsSet() {
		localVarFormParams.Add("value", parameterToString(localVarOptionals.Value.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ClearValue.IsSet() {
		localVarFormParams.Add("clear_value", parameterToString(localVarOptionals.ClearValue.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Notes.IsSet() {
		localVarFormParams.Add("notes", parameterToString(localVarOptionals.Notes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ClearNotes.IsSet() {
		localVarFormParams.Add("clear_notes", parameterToString(localVarOptionals.ClearNotes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BulkFields.IsSet() {
		localVarFormParams.Add("bulk_fields", parameterToString(localVarOptionals.BulkFields.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
IPAMApiService Create/update custom fields for subnets.
Subnet Custom Fields
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param network Network IP
 * @param maskBits
 * @param vrfGroup VRF group name
 * @param key Can be new or existing. This is the custom field name.
 * @param optional nil or *IPAMApiPutIPAMCustomFIsubnetOpts - Optional Parameters:
     * @param "Type_" (optional.String) -  this is the custom field type. If left blank, default is text. Additional options: number,date(text formatted yyyy-mm-dd), related_field(with related_field_name), boolean or url
     * @param "RelatedFieldName" (optional.String) -  The existing field to relate this custom field to. Can be: appcomp (for application components), asset, building, certificate, circuit, cusotmer, device, endusers, hardware (for device hardware models), ip_address, natip, netport (for ports), os, part, partmodel, password, pdu (for power units), pdu_model (for power unit models), ports, purchase, purchaselineitem (for a line item on a purchase order), rack, room, software, vlan (for subnets), switch_vlan (for vlans), vrfgroup
     * @param "AddToPicklist" (optional.String) -  Comma separated values to add to picklist. If type is picklist and custom field is new, this is a required field. Duplicates will be ignored.
     * @param "Value" (optional.String) -  Value of the custom field.
     * @param "ClearValue" (optional.String) -  Yes to clear the existing value for that field.
     * @param "Notes" (optional.String) -  Any additional notes.
     * @param "ClearNotes" (optional.String) -  Yes to clear any existing notes.
     * @param "BulkFields" (optional.String) -  comma separated key value pairs, with key and value separated by colon. e.g.key1:value1, key2:value2

@return interface{}
*/

type IPAMApiPutIPAMCustomFIsubnetOpts struct { 
	Type_ optional.String
	RelatedFieldName optional.String
	AddToPicklist optional.String
	Value optional.String
	ClearValue optional.String
	Notes optional.String
	ClearNotes optional.String
	BulkFields optional.String
}

func (a *IPAMApiService) PutIPAMCustomFIsubnet(ctx context.Context, network string, maskBits string, vrfGroup string, key string, localVarOptionals *IPAMApiPutIPAMCustomFIsubnetOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/custom_fields/subnet/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("key", parameterToString(key, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("network", parameterToString(network, ""))
	localVarFormParams.Add("mask_bits", parameterToString(maskBits, ""))
	localVarFormParams.Add("vrf_group", parameterToString(vrfGroup, ""))
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarFormParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RelatedFieldName.IsSet() {
		localVarFormParams.Add("related_field_name", parameterToString(localVarOptionals.RelatedFieldName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AddToPicklist.IsSet() {
		localVarFormParams.Add("add_to_picklist", parameterToString(localVarOptionals.AddToPicklist.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Value.IsSet() {
		localVarFormParams.Add("value", parameterToString(localVarOptionals.Value.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ClearValue.IsSet() {
		localVarFormParams.Add("clear_value", parameterToString(localVarOptionals.ClearValue.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Notes.IsSet() {
		localVarFormParams.Add("notes", parameterToString(localVarOptionals.Notes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ClearNotes.IsSet() {
		localVarFormParams.Add("clear_notes", parameterToString(localVarOptionals.ClearNotes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BulkFields.IsSet() {
		localVarFormParams.Add("bulk_fields", parameterToString(localVarOptionals.BulkFields.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
IPAMApiService Create / Update Switch Port Custom Fields
Required parameters: &lt;ul&gt;&lt;li&gt;id &lt;b&gt;OR&lt;/b&gt; port &lt;b&gt;AND&lt;/b&gt; device_name&lt;/li&gt; &lt;li&gt;key&lt;/li&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param key Can be new or existing. This is the custom field name.
 * @param optional nil or *IPAMApiPutIPAMCustomFIswitchportOpts - Optional Parameters:
     * @param "Id" (optional.String) -  ID of the switchport
     * @param "Port" (optional.String) -  required if ID is not used
     * @param "DeviceName" (optional.String) -  required if switchport ID not used
     * @param "Type_" (optional.String) -  this is the custom field type. If left blank, default is text. Date should be formatted as YYYY-MM-DD
     * @param "RelatedFieldName" (optional.String) -  Required if type &#x3D; related field.
     * @param "AddToPicklist" (optional.String) -  Comma separated values to add to picklist. If type is picklist and custom field is new, this is a required field. Duplicates will be ignored.
     * @param "Value" (optional.String) -  This will set the value of the custom field for the specific object.
     * @param "ClearValue" (optional.String) -  yes to clear existing value for that field
     * @param "Notes" (optional.String) -  Any additional notes
     * @param "ClearNotes" (optional.String) -  Yes to clear any existing notes.
     * @param "BulkFields" (optional.String) -  comma separated key value pairs, with key and value separated by colon. e.g.key1:value1, key2:value2

@return interface{}
*/

type IPAMApiPutIPAMCustomFIswitchportOpts struct { 
	Id optional.String
	Port optional.String
	DeviceName optional.String
	Type_ optional.String
	RelatedFieldName optional.String
	AddToPicklist optional.String
	Value optional.String
	ClearValue optional.String
	Notes optional.String
	ClearNotes optional.String
	BulkFields optional.String
}

func (a *IPAMApiService) PutIPAMCustomFIswitchport(ctx context.Context, key string, localVarOptionals *IPAMApiPutIPAMCustomFIswitchportOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/custom_fields/switchport/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarFormParams.Add("id", parameterToString(localVarOptionals.Id.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Port.IsSet() {
		localVarFormParams.Add("port", parameterToString(localVarOptionals.Port.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceName.IsSet() {
		localVarFormParams.Add("device_name", parameterToString(localVarOptionals.DeviceName.Value(), ""))
	}
	localVarFormParams.Add("key", parameterToString(key, ""))
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarFormParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RelatedFieldName.IsSet() {
		localVarFormParams.Add("related_field_name", parameterToString(localVarOptionals.RelatedFieldName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AddToPicklist.IsSet() {
		localVarFormParams.Add("add_to_picklist", parameterToString(localVarOptionals.AddToPicklist.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Value.IsSet() {
		localVarFormParams.Add("value", parameterToString(localVarOptionals.Value.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ClearValue.IsSet() {
		localVarFormParams.Add("clear_value", parameterToString(localVarOptionals.ClearValue.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Notes.IsSet() {
		localVarFormParams.Add("notes", parameterToString(localVarOptionals.Notes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ClearNotes.IsSet() {
		localVarFormParams.Add("clear_notes", parameterToString(localVarOptionals.ClearNotes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BulkFields.IsSet() {
		localVarFormParams.Add("bulk_fields", parameterToString(localVarOptionals.BulkFields.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
IPAMApiService VRF Group Custom Fields
Create/update custom fields for VRF groups. Required parameters: &lt;ul&gt;&lt;li&gt;name &lt;b&gt;OR&lt;/b&gt; ID&lt;/li&gt; &lt;li&gt;key&lt;/li&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param key Can be new or existing. This is the custom field name.
 * @param optional nil or *IPAMApiPutIPAMCustomFIvrfgroupOpts - Optional Parameters:
     * @param "Name" (optional.String) -  Required if ID not present
     * @param "Id" (optional.String) -  Required if name not present
     * @param "Value" (optional.String) -  Value of the custom field
     * @param "ClearValue" (optional.String) -  Yes to clear the existing value for that field.
     * @param "Notes" (optional.String) -  Any additional notes.
     * @param "ClearNotes" (optional.String) -  Yes to clear any existing notes.

@return interface{}
*/

type IPAMApiPutIPAMCustomFIvrfgroupOpts struct { 
	Name optional.String
	Id optional.String
	Value optional.String
	ClearValue optional.String
	Notes optional.String
	ClearNotes optional.String
}

func (a *IPAMApiService) PutIPAMCustomFIvrfgroup(ctx context.Context, key string, localVarOptionals *IPAMApiPutIPAMCustomFIvrfgroupOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/custom_fields/vrfgroup/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarFormParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarFormParams.Add("id", parameterToString(localVarOptionals.Id.Value(), ""))
	}
	localVarFormParams.Add("key", parameterToString(key, ""))
	if localVarOptionals != nil && localVarOptionals.Value.IsSet() {
		localVarFormParams.Add("value", parameterToString(localVarOptionals.Value.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ClearValue.IsSet() {
		localVarFormParams.Add("clear_value", parameterToString(localVarOptionals.ClearValue.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Notes.IsSet() {
		localVarFormParams.Add("notes", parameterToString(localVarOptionals.Notes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ClearNotes.IsSet() {
		localVarFormParams.Add("clear_notes", parameterToString(localVarOptionals.ClearNotes.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
IPAMApiService Update IP NAT (Added in v7.0.0)
Update IP NAT
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id ID of the NAT entry - Required if not in the URL
 * @param optional nil or *IPAMApiPutIPAMIpnatOpts - Optional Parameters:
     * @param "Name" (optional.String) -  Name of the NAT IP entry
     * @param "IpAddressFrom" (optional.String) -  The external IP address
     * @param "IpAddressTo" (optional.String) -  The internal IP address
     * @param "TwoWayRelation" (optional.String) -  true if the internal IP addressed is masked with the external IP address for outbound traffic in addition to inbound traffic. Default is false.
     * @param "Notes" (optional.String) -  Any additional notes

@return interface{}
*/

type IPAMApiPutIPAMIpnatOpts struct { 
	Name optional.String
	IpAddressFrom optional.String
	IpAddressTo optional.String
	TwoWayRelation optional.String
	Notes optional.String
}

func (a *IPAMApiService) PutIPAMIpnat(ctx context.Context, id string, localVarOptionals *IPAMApiPutIPAMIpnatOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/ipnat/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("id", parameterToString(id, ""))
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarFormParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IpAddressFrom.IsSet() {
		localVarFormParams.Add("ip_address_from", parameterToString(localVarOptionals.IpAddressFrom.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IpAddressTo.IsSet() {
		localVarFormParams.Add("ip_address_to", parameterToString(localVarOptionals.IpAddressTo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TwoWayRelation.IsSet() {
		localVarFormParams.Add("two_way_relation", parameterToString(localVarOptionals.TwoWayRelation.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Notes.IsSet() {
		localVarFormParams.Add("notes", parameterToString(localVarOptionals.Notes.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
IPAMApiService Create Subnet Category.
Update a Specific Subnet Category
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Name of the Subnet Category
 * @param optional nil or *IPAMApiPutIPAMsubnetcategoryOpts - Optional Parameters:
     * @param "Description" (optional.String) - 
     * @param "IsItDefault" (optional.String) -  yes or no. Defaults to no. Only one category can be yes. If yes, this is the subnet category to use if none specified in an API or auto-discovery update.
     * @param "Groups" (optional.String) -  If multitenancy is on, admin groups that have access to this object are specified here, e.g. Prod_East:no,Corp:yes specifies that the admin groups for this object are Prod_East with view only permission and Corp with change permission. If this parameter is present with no value, all groups are deleted.

@return interface{}
*/

type IPAMApiPutIPAMsubnetcategoryOpts struct { 
	Description optional.String
	IsItDefault optional.String
	Groups optional.String
}

func (a *IPAMApiService) PutIPAMsubnetcategory(ctx context.Context, name string, localVarOptionals *IPAMApiPutIPAMsubnetcategoryOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/subnet_category/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("name", parameterToString(name, ""))
	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarFormParams.Add("description", parameterToString(localVarOptionals.Description.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsItDefault.IsSet() {
		localVarFormParams.Add("is_it_default", parameterToString(localVarOptionals.IsItDefault.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Groups.IsSet() {
		localVarFormParams.Add("groups", parameterToString(localVarOptionals.Groups.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
IPAMApiService Create / Update Subnets.
Update a Specific Subnet
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param network Required for creation, cannot be modified after subnet creation.
 * @param maskBits Cannot be modified after subnet creation
 * @param optional nil or *IPAMApiPutIPAMsubnetsOpts - Optional Parameters:
     * @param "VrfGroupId" (optional.String) -  ID of the VRF group
     * @param "VrfGroup" (optional.String) -  VRF group name
     * @param "Name" (optional.String) - 
     * @param "Description" (optional.String) - 
     * @param "Gateway" (optional.String) -  Gateway (added in v7.2.0)
     * @param "RangeBegin" (optional.String) -  Range Begin (added in v7.2.0)
     * @param "RangeEnd" (optional.String) -  Range End (added in v7.2.0)
     * @param "ParentVlanId" (optional.String) - 
     * @param "ParentSubnetId" (optional.String) -  Change the parent subnet of the subnet. Note: must be valid parent.
     * @param "CustomerId" (optional.String) - 
     * @param "Notes" (optional.String) -  Any additional notes
     * @param "ServiceLevel" (optional.String) -  Must already exist
     * @param "Assigned" (optional.String) -  ‘yes’ if assigned. ‘no’ (default) if unassigned.
     * @param "Allocated" (optional.String) -  ‘yes’ if allocated. ‘no’ (default) if unallocated.
     * @param "AutoAddIps" (optional.String) -  If ‘yes’, addresses within subnet will be automatically added to Device42. (Only available in POST)
     * @param "Category" (optional.String) -  If multitenancy is on, admin groups that have access to this object are specified here, e.g. Prod_East:no, Corp:yes specifies that the admin groups for this object are Prod_East with view only permission and Corp with change permission. Use for initial insert.
     * @param "CategoryId" (optional.String) -  ID of the category - use for initial insert.

@return interface{}
*/

type IPAMApiPutIPAMsubnetsOpts struct { 
	VrfGroupId optional.String
	VrfGroup optional.String
	Name optional.String
	Description optional.String
	Gateway optional.String
	RangeBegin optional.String
	RangeEnd optional.String
	ParentVlanId optional.String
	ParentSubnetId optional.String
	CustomerId optional.String
	Notes optional.String
	ServiceLevel optional.String
	Assigned optional.String
	Allocated optional.String
	AutoAddIps optional.String
	Category optional.String
	CategoryId optional.String
}

func (a *IPAMApiService) PutIPAMsubnets(ctx context.Context, network string, maskBits string, localVarOptionals *IPAMApiPutIPAMsubnetsOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/subnets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("network", parameterToString(network, ""))
	localVarFormParams.Add("mask_bits", parameterToString(maskBits, ""))
	if localVarOptionals != nil && localVarOptionals.VrfGroupId.IsSet() {
		localVarFormParams.Add("vrf_group_id", parameterToString(localVarOptionals.VrfGroupId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VrfGroup.IsSet() {
		localVarFormParams.Add("vrf_group", parameterToString(localVarOptionals.VrfGroup.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarFormParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarFormParams.Add("description", parameterToString(localVarOptionals.Description.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Gateway.IsSet() {
		localVarFormParams.Add("gateway", parameterToString(localVarOptionals.Gateway.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RangeBegin.IsSet() {
		localVarFormParams.Add("range_begin", parameterToString(localVarOptionals.RangeBegin.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RangeEnd.IsSet() {
		localVarFormParams.Add("range_end", parameterToString(localVarOptionals.RangeEnd.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ParentVlanId.IsSet() {
		localVarFormParams.Add("parent_vlan_id", parameterToString(localVarOptionals.ParentVlanId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ParentSubnetId.IsSet() {
		localVarFormParams.Add("parent_subnet_id", parameterToString(localVarOptionals.ParentSubnetId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CustomerId.IsSet() {
		localVarFormParams.Add("customer_id", parameterToString(localVarOptionals.CustomerId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Notes.IsSet() {
		localVarFormParams.Add("notes", parameterToString(localVarOptionals.Notes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ServiceLevel.IsSet() {
		localVarFormParams.Add("service_level", parameterToString(localVarOptionals.ServiceLevel.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Assigned.IsSet() {
		localVarFormParams.Add("assigned", parameterToString(localVarOptionals.Assigned.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Allocated.IsSet() {
		localVarFormParams.Add("allocated", parameterToString(localVarOptionals.Allocated.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AutoAddIps.IsSet() {
		localVarFormParams.Add("auto_add_ips", parameterToString(localVarOptionals.AutoAddIps.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Category.IsSet() {
		localVarFormParams.Add("category", parameterToString(localVarOptionals.Category.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CategoryId.IsSet() {
		localVarFormParams.Add("category_id", parameterToString(localVarOptionals.CategoryId.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
IPAMApiService Update VLANS by ID in url.
Update VLANS
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id
 * @param optional nil or *IPAMApiPutIPAMvlansOpts - Optional Parameters:
     * @param "Number" (optional.String) -  vlan number
     * @param "Name" (optional.String) -  If left blank, name will be created as VLANxxxx, e.g. VLAN# 342 will be named VLAN0342
     * @param "Description" (optional.String) - 
     * @param "SwitchId" (optional.String) -  Comma separated values for switch_ids
     * @param "Notes" (optional.String) -  Any additional notes
     * @param "Groups" (optional.String) -  If multitenancy is on, admin groups that have access to this object are specified here, e.g. Prod_East:no,Corp:yes specifies that the admin groups for this object are Prod_East with view only permission and Corp with change permission. If this parameter is present with no value, all groups are deleted.

@return interface{}
*/

type IPAMApiPutIPAMvlansOpts struct { 
	Number optional.String
	Name optional.String
	Description optional.String
	SwitchId optional.String
	Notes optional.String
	Groups optional.String
}

func (a *IPAMApiService) PutIPAMvlans(ctx context.Context, id int32, localVarOptionals *IPAMApiPutIPAMvlansOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/vlans/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Number.IsSet() {
		localVarFormParams.Add("number", parameterToString(localVarOptionals.Number.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarFormParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarFormParams.Add("description", parameterToString(localVarOptionals.Description.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SwitchId.IsSet() {
		localVarFormParams.Add("switch_id", parameterToString(localVarOptionals.SwitchId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Notes.IsSet() {
		localVarFormParams.Add("notes", parameterToString(localVarOptionals.Notes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Groups.IsSet() {
		localVarFormParams.Add("groups", parameterToString(localVarOptionals.Groups.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
IPAMApiService Update VRF Group
Update a Specific VRF Group
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *IPAMApiPutIPAMvrfgroupOpts - Optional Parameters:
     * @param "Name" (optional.String) -  Name of the VRF Group
     * @param "Description" (optional.String) - 
     * @param "Groups" (optional.String) -  If multitenancy is on, admin groups that have access to this object are specified here, e.g. Prod_East:no,Corp:yes specifies that the admin groups for this object are Prod_East with view only permission and Corp with change permission. If this parameter is present with no value, all groups are deleted.
     * @param "Buildings" (optional.String) -  list of building names for the VRF Group

@return interface{}
*/

type IPAMApiPutIPAMvrfgroupOpts struct { 
	Name optional.String
	Description optional.String
	Groups optional.String
	Buildings optional.String
}

func (a *IPAMApiService) PutIPAMvrfgroup(ctx context.Context, localVarOptionals *IPAMApiPutIPAMvrfgroupOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/vrfgroup/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarFormParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarFormParams.Add("description", parameterToString(localVarOptionals.Description.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Groups.IsSet() {
		localVarFormParams.Add("groups", parameterToString(localVarOptionals.Groups.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Buildings.IsSet() {
		localVarFormParams.Add("buildings", parameterToString(localVarOptionals.Buildings.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
