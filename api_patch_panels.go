
/*
 * Device42 API
 *
 * <b><h2>API Overview</h2></b><br>Restful API are supported in Device42 as one of the primary methods of entering, editing and retrieving data.<br><br> The API documentation has samples in curl for now and we will be adding other programming languages in future. You can refer to our github repositories at https://github.com/device42 for some sample code in python.<br><br> The RESTful API's enforce the role-based security that is created with the Device42 app. If you want a user to have access via the API, but not via the UI - deselect 'Staff Status' for that user from UI Tools > Admins & Permissions > Administrators.<br><br>If you'd like to see your changes on our UI, please visit http://swaggerdemo.device42.com and use credentials 'guest:device42_rocks!'. Please be aware that every 30 minutes our database resets and all data entered with POST/PUT calls from this page will be lost.<br><br>If you have any questions/suggestions, please send us a note to support at device42.com below. <br><h2><a id = 'Sample_API_Code'><b>Sample API Code</b></a></h2> <b>Sample Code with API Calls in the Python and .Net Programming Languages.</b><br>The following programs written in the Python programming language are available at <a href= 'https://github.com/device42/Device42-AutoDiscovery-Scripts'>Device42 sample programs</a><br><ul><li>api-sample.py: Runs against a single Windows system and uploads info to device42 appliance.</li><li>ad-sample.py: Can run against Active directory computers, servers or a given list and upload discovered systems’ info to device42 appliance.</li><li>d42_api_linux_upload_sample_script.py: Runs on a single *nix based system and uploads info to device42 appliance.</li><li>sample-script-facter-facts-to-d42: Runs on puppet master and uploads nodes info from facter fact files to device42 appliance.</li><li>d42_api_solaris_sample_script.py: Runs on an individual solaris system and uploads info to device42 appliance.</li></ul>The csv2d42apis.py sample program shows how to create a CSV file of data to import into device42. It reads a CSV file, matches columns to arguments for APIs and sends data to device42 via POST or PUT. This program can be found at: <a href= 'https://github.com/device42/API_Helpers'> Device42 sample CSV importer</a>.<br><br>The Auto Discovery Client source code can be found at Device42 <a href='https://docs.device42.com/auto-discovery/'>Auto Discovery Client</a>. This is a .net program that uses the device42 Restful API’s to load the discovered data.<h2><a id = 'Response_Status_Messages'><b>Response & Status Messages</b></a></h2><b>Responses</b><br>The response to most POST calls will have the following format: <br>{'msg':['PartModel added/updated', 17, 'RAM Acme 123456', true, true], 'code':0}<br><br>Using the example above:<br>'17' = ID of the object<br>'RAM Acme 123456' = representation of the object<br> 'true, true' = object added and is new.<br>'true, false' = object updated.<br>'false, false' = no changes.<br><br><b>Status Codes</b><br><u>Code 0</u><br>Success! e.g. = {'msg': 'device added or updated', <b>code:0</b>}<br><br><u>'HTTP/1.1 200 OK'</u><br>Success! All other responses are errors and will display an error code e.g.: 400, 401, 403, 405, 410, 500, 503. These are explained in each call.<br><br>Please let us know if you notice something odd with a response and we will fix it! :) <h2><a id = 'Get_Limits_Offsets'><b>API Get Limits and Offsets</b></a></h2>In Device42’s global settings we have the option to enforce API GET limits and this setting is recommended for better performance. To set this value from Device42, go to Tools>Settings>Global Settings and the click Edit in the top right. Toward the bottom of the screen you will see the API section. First check the “Enforce API GET Limits” checkbox, then enter a value for API GET Limit. A good limit to start with is 500 or 1000, depending on the performance you experience.<br><br>After setting this limit all GET calls below can have the results augmented via “offset” and “limit” parameters to tell Device42 which value to start returning results from, and how many results to return at maximum.<br>Examples:<br><br>'/?limit=50' returns the first 50 results.<br><br> '/?offset=100' will start at the 101st result. <br><br>'/?offset=42&limit=42' returns 42 results, starting at the 43rd.<br><br> Note that offset is used for paging - that is, the offset is only applied when the total number of objects returned exceeds the limit that is returned.
 *
 * API version: 2.0
 * Contact: support@device42.com
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package swagger

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"fmt"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type PatchPanelsApiService service

/* 
PatchPanelsApiService Get Patch Panel details by ID
Retrieve detailed information about a specific Patch Panel by Patch Panel ID. This also includes end point connections.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param iD The ID of the Patch Panel to retrieve

@return PatchPanel
*/
func (a *PatchPanelsApiService) GetPatchPanelID(ctx context.Context, iD int32) (PatchPanel, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PatchPanel
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/patch_panel/{ID}/"
	localVarPath = strings.Replace(localVarPath, "{"+"ID"+"}", fmt.Sprintf("%v", iD), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v PatchPanel
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
PatchPanelsApiService Retrieves all patch panel models.
Get all Patch Panel Models
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *PatchPanelsApiGetPatchPanelModelsOpts - Optional Parameters:
     * @param "Name" (optional.String) -  filter by name

@return []InlineResponse2002
*/

type PatchPanelsApiGetPatchPanelModelsOpts struct { 
	Name optional.String
}

func (a *PatchPanelsApiService) GetPatchPanelModels(ctx context.Context, localVarOptionals *PatchPanelsApiGetPatchPanelModelsOpts) ([]InlineResponse2002, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []InlineResponse2002
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/patch_panel_models/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []InlineResponse2002
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
PatchPanelsApiService Retrieves all patch panel module models.
Get all Patch Panel Module Models
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

@return []InlineResponse2003
*/
func (a *PatchPanelsApiService) GetPatchPanelModuleModels(ctx context.Context) ([]InlineResponse2003, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []InlineResponse2003
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/patch_panel_module_models/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []InlineResponse2003
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
PatchPanelsApiService Retrieves patch panel ports for specified patch panel.
Get all Patch Panel Ports
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param patchPanelId Patch panel id

@return []InlineResponse200
*/
func (a *PatchPanelsApiService) GetPatchPanelPortsPatchPanelId(ctx context.Context, patchPanelId int32) ([]InlineResponse200, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []InlineResponse200
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/patch_panel_ports/{patch_panel_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"patch_panel_id"+"}", fmt.Sprintf("%v", patchPanelId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []InlineResponse200
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
PatchPanelsApiService Create Patch Panel Model.
Create/Update Patch Panel Model. Required parameters: &lt;ul&gt;&lt;li&gt;patch_panel_model_id &lt;b&gt;OR&lt;/b&gt; name&lt;/li&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *PatchPanelsApiPostPatchPanelModelsOpts - Optional Parameters:
     * @param "PatchPanelModelId" (optional.String) -  Patch Panel Model ID or UI Tools &gt; Export &gt; Patch Panel Model
     * @param "Name" (optional.String) -  Name of the patch panel model you want to edit or create.
     * @param "Manufacturer" (optional.String) -  name of the hardware/software manufacturer.
     * @param "Type_" (optional.String) - 
     * @param "PortType" (optional.String) -  name of the port type. created if it doesn&#39;t exist already
     * @param "PairedPorts" (optional.String) - 
     * @param "ImgfileId" (optional.String) -  image file id. You can see these from Tools &gt; Import &gt; Hardware Import for now.
     * @param "Imgfile" (optional.String) -  name of the image file (Added in v5.8.2). Use instead of imgfile_id
     * @param "NumberOfPorts" (optional.String) -  number of ports. required for creating a new patch panel type singular. Ignored for patch panel type modular
     * @param "NumberOfPortsInRow" (optional.String) -  number of ports in a row. required for creating a new patch panel type singular. Ignored for patch panel type modular
     * @param "ModulePosition" (optional.String) -  for Modular Patch Panel Models. Possible values are horizontal or vertical (Added in v5.8.2)

@return interface{}
*/

type PatchPanelsApiPostPatchPanelModelsOpts struct { 
	PatchPanelModelId optional.String
	Name optional.String
	Manufacturer optional.String
	Type_ optional.String
	PortType optional.String
	PairedPorts optional.String
	ImgfileId optional.String
	Imgfile optional.String
	NumberOfPorts optional.String
	NumberOfPortsInRow optional.String
	ModulePosition optional.String
}

func (a *PatchPanelsApiService) PostPatchPanelModels(ctx context.Context, localVarOptionals *PatchPanelsApiPostPatchPanelModelsOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/patch_panel_models/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.PatchPanelModelId.IsSet() {
		localVarFormParams.Add("patch_panel_model_id", parameterToString(localVarOptionals.PatchPanelModelId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarFormParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Manufacturer.IsSet() {
		localVarFormParams.Add("manufacturer", parameterToString(localVarOptionals.Manufacturer.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarFormParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PortType.IsSet() {
		localVarFormParams.Add("port_type", parameterToString(localVarOptionals.PortType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PairedPorts.IsSet() {
		localVarFormParams.Add("paired_ports", parameterToString(localVarOptionals.PairedPorts.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ImgfileId.IsSet() {
		localVarFormParams.Add("imgfile_id", parameterToString(localVarOptionals.ImgfileId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Imgfile.IsSet() {
		localVarFormParams.Add("imgfile", parameterToString(localVarOptionals.Imgfile.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NumberOfPorts.IsSet() {
		localVarFormParams.Add("number_of_ports", parameterToString(localVarOptionals.NumberOfPorts.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NumberOfPortsInRow.IsSet() {
		localVarFormParams.Add("number_of_ports_in_row", parameterToString(localVarOptionals.NumberOfPortsInRow.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ModulePosition.IsSet() {
		localVarFormParams.Add("module_position", parameterToString(localVarOptionals.ModulePosition.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
PatchPanelsApiService Create/Update Patch Panel Module Model.
Create/Update Patch Panel Module Model. Required parameters: &lt;ul&gt;&lt;li&gt;patch_panel_module_model_id &lt;b&gt;OR&lt;/b&gt; name&lt;/li&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *PatchPanelsApiPostPatchPanelModuleModelsOpts - Optional Parameters:
     * @param "PatchPanelModuleModelId" (optional.String) - 
     * @param "Name" (optional.String) -  Name of the patch panel module model you want to edit or create.
     * @param "PortType" (optional.String) -  name of the port type. created if it doesn&#39;t exist already
     * @param "PairedPorts" (optional.String) - 
     * @param "NumberOfPorts" (optional.String) -  number of ports. required for creating a new patch panel type singular. Ignored for patch panel type modular
     * @param "NumberOfPortsInRow" (optional.String) -  number of ports in a row. required for creating a new patch panel type singular. Ignored for patch panel type modular

@return interface{}
*/

type PatchPanelsApiPostPatchPanelModuleModelsOpts struct { 
	PatchPanelModuleModelId optional.String
	Name optional.String
	PortType optional.String
	PairedPorts optional.String
	NumberOfPorts optional.String
	NumberOfPortsInRow optional.String
}

func (a *PatchPanelsApiService) PostPatchPanelModuleModels(ctx context.Context, localVarOptionals *PatchPanelsApiPostPatchPanelModuleModelsOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/patch_panel_module_models/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.PatchPanelModuleModelId.IsSet() {
		localVarFormParams.Add("patch_panel_module_model_id", parameterToString(localVarOptionals.PatchPanelModuleModelId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarFormParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PortType.IsSet() {
		localVarFormParams.Add("port_type", parameterToString(localVarOptionals.PortType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PairedPorts.IsSet() {
		localVarFormParams.Add("paired_ports", parameterToString(localVarOptionals.PairedPorts.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NumberOfPorts.IsSet() {
		localVarFormParams.Add("number_of_ports", parameterToString(localVarOptionals.NumberOfPorts.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NumberOfPortsInRow.IsSet() {
		localVarFormParams.Add("number_of_ports_in_row", parameterToString(localVarOptionals.NumberOfPortsInRow.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
PatchPanelsApiService Update Patch Panel Ports
Update Patch Panel Ports. Requires the following parameters: &lt;ul&gt;&lt;li&gt;patch_panel_id &lt;b&gt;OR&lt;/b&gt; patch_panel&lt;/li&gt; &lt;li&gt;number&lt;/li&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param number Port number for the patch panel
 * @param optional nil or *PatchPanelsApiPostPatchPanelPortsPatchPanelIdOpts - Optional Parameters:
     * @param "PatchPanelId" (optional.String) -  Patch panel id
     * @param "PatchPanel" (optional.String) -  Must be a unique asset name for this to work (Added in v5.8.2)
     * @param "ModuleSlot" (optional.String) -  change patch panel port for a certain module slot # (Added in v5.8.2)
     * @param "MacId" (optional.String) -  mac_id references port_id value. mac_id available via GET at /api/api/1.0/macs/ or Tools &gt; Export &gt; MAC Address * Please see note below
     * @param "MacAddress" (optional.String) -  mac_address or hwaddress
     * @param "SwitchportId" (optional.String) -  ID for the switch port. Available via GET at /api/api/1.0/switchports/ or Tools &gt; Export &gt; Switch Port
     * @param "Switch_" (optional.String) -  Must be used with switchport if switchport_id is not used.
     * @param "Switchport" (optional.String) -  Must be used with switch if switchport_id is not used.
     * @param "PatchPanelPortId" (optional.String) -  Or use front_patch_panel and front_port combination
     * @param "FrontPatchPanelId" (optional.String) -  Name of the front patch panel - if a patch panel port is connected in front (Added in v5.8.2)
     * @param "FrontPatchPanel" (optional.String) -  Name of the front patch panel - if a patch panel port is connected in front (Added in v5.8.2)
     * @param "FrontPort" (optional.String) -  Number of the port on the front patch panel - if a patch panel port is connected in front (Added in v5.8.2)
     * @param "Label" (optional.String) - 
     * @param "ObjLabel1" (optional.String) -  object label 1
     * @param "ObjLabel2" (optional.String) -  object label 2
     * @param "BackConnectionId" (optional.String) -  ID for the back connection port. Available via GET at /api/api/1.0/patch_panel_ports// or Tools &gt; Export &gt; Patch Panel Port
     * @param "BackSwitchportId" (optional.String) -  Used if back connection type is switch.
     * @param "BackSwitch" (optional.String) -  If back connection type is switch, use switch and switchport names in combination.
     * @param "BackSwitchport" (optional.String) -  Use if back connection type is switch - use in combination with back_switch.
     * @param "BackPatchPanelId" (optional.String) -  ID of the back patch panel - if a patch panel port is connected in back (Added in v5.8.2)
     * @param "BackPatchPanel" (optional.String) -  Name of the back patch panel - if a patch panel port is connected in back (Added in v5.8.2)
     * @param "BackPort" (optional.String) -  Number of the port on the back patch panel - if a patch panel port is connected in back (Added in v5.8.2)
     * @param "ClearFront" (optional.String) -  “yes” will clear front connection for port
     * @param "ClearBack" (optional.String) -  “yes” will clear back connection on port
     * @param "CableType" (optional.String) -  named value of the cable type. Must already exist.

@return []InlineResponse2001
*/

type PatchPanelsApiPostPatchPanelPortsPatchPanelIdOpts struct { 
	PatchPanelId optional.String
	PatchPanel optional.String
	ModuleSlot optional.String
	MacId optional.String
	MacAddress optional.String
	SwitchportId optional.String
	Switch_ optional.String
	Switchport optional.String
	PatchPanelPortId optional.String
	FrontPatchPanelId optional.String
	FrontPatchPanel optional.String
	FrontPort optional.String
	Label optional.String
	ObjLabel1 optional.String
	ObjLabel2 optional.String
	BackConnectionId optional.String
	BackSwitchportId optional.String
	BackSwitch optional.String
	BackSwitchport optional.String
	BackPatchPanelId optional.String
	BackPatchPanel optional.String
	BackPort optional.String
	ClearFront optional.String
	ClearBack optional.String
	CableType optional.String
}

func (a *PatchPanelsApiService) PostPatchPanelPortsPatchPanelId(ctx context.Context, number string, localVarOptionals *PatchPanelsApiPostPatchPanelPortsPatchPanelIdOpts) ([]InlineResponse2001, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []InlineResponse2001
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/patch_panel_ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.BackConnectionId.IsSet() {
		localVarQueryParams.Add("back_connection_id", parameterToString(localVarOptionals.BackConnectionId.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.PatchPanelId.IsSet() {
		localVarFormParams.Add("patch_panel_id", parameterToString(localVarOptionals.PatchPanelId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PatchPanel.IsSet() {
		localVarFormParams.Add("patch_panel", parameterToString(localVarOptionals.PatchPanel.Value(), ""))
	}
	localVarFormParams.Add("number", parameterToString(number, ""))
	if localVarOptionals != nil && localVarOptionals.ModuleSlot.IsSet() {
		localVarFormParams.Add("module_slot", parameterToString(localVarOptionals.ModuleSlot.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MacId.IsSet() {
		localVarFormParams.Add("mac_id", parameterToString(localVarOptionals.MacId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MacAddress.IsSet() {
		localVarFormParams.Add("mac_address", parameterToString(localVarOptionals.MacAddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SwitchportId.IsSet() {
		localVarFormParams.Add("switchport_id", parameterToString(localVarOptionals.SwitchportId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Switch_.IsSet() {
		localVarFormParams.Add("switch", parameterToString(localVarOptionals.Switch_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Switchport.IsSet() {
		localVarFormParams.Add("switchport", parameterToString(localVarOptionals.Switchport.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PatchPanelPortId.IsSet() {
		localVarFormParams.Add("patch_panel_port_id", parameterToString(localVarOptionals.PatchPanelPortId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FrontPatchPanelId.IsSet() {
		localVarFormParams.Add("front_patch_panel_id", parameterToString(localVarOptionals.FrontPatchPanelId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FrontPatchPanel.IsSet() {
		localVarFormParams.Add("front_patch_panel", parameterToString(localVarOptionals.FrontPatchPanel.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FrontPort.IsSet() {
		localVarFormParams.Add("front_port", parameterToString(localVarOptionals.FrontPort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Label.IsSet() {
		localVarFormParams.Add("label", parameterToString(localVarOptionals.Label.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ObjLabel1.IsSet() {
		localVarFormParams.Add("obj_label1", parameterToString(localVarOptionals.ObjLabel1.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ObjLabel2.IsSet() {
		localVarFormParams.Add("obj_label2", parameterToString(localVarOptionals.ObjLabel2.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BackSwitchportId.IsSet() {
		localVarFormParams.Add("back_switchport_id", parameterToString(localVarOptionals.BackSwitchportId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BackSwitch.IsSet() {
		localVarFormParams.Add("back_switch", parameterToString(localVarOptionals.BackSwitch.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BackSwitchport.IsSet() {
		localVarFormParams.Add("back_switchport", parameterToString(localVarOptionals.BackSwitchport.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BackPatchPanelId.IsSet() {
		localVarFormParams.Add("back_patch_panel_id", parameterToString(localVarOptionals.BackPatchPanelId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BackPatchPanel.IsSet() {
		localVarFormParams.Add("back_patch_panel", parameterToString(localVarOptionals.BackPatchPanel.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BackPort.IsSet() {
		localVarFormParams.Add("back_port", parameterToString(localVarOptionals.BackPort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ClearFront.IsSet() {
		localVarFormParams.Add("clear_front", parameterToString(localVarOptionals.ClearFront.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ClearBack.IsSet() {
		localVarFormParams.Add("clear_back", parameterToString(localVarOptionals.ClearBack.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CableType.IsSet() {
		localVarFormParams.Add("cable_type", parameterToString(localVarOptionals.CableType.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []InlineResponse2001
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
