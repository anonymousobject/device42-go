
/*
 * Device42 API
 *
 * <b><h2>API Overview</h2></b><br>Restful API are supported in Device42 as one of the primary methods of entering, editing and retrieving data.<br><br> The API documentation has samples in curl for now and we will be adding other programming languages in future. You can refer to our github repositories at https://github.com/device42 for some sample code in python.<br><br> The RESTful API's enforce the role-based security that is created with the Device42 app. If you want a user to have access via the API, but not via the UI - deselect 'Staff Status' for that user from UI Tools > Admins & Permissions > Administrators.<br><br>If you'd like to see your changes on our UI, please visit http://swaggerdemo.device42.com and use credentials 'guest:device42_rocks!'. Please be aware that every 30 minutes our database resets and all data entered with POST/PUT calls from this page will be lost.<br><br>If you have any questions/suggestions, please send us a note to support at device42.com below. <br><h2><a id = 'Sample_API_Code'><b>Sample API Code</b></a></h2> <b>Sample Code with API Calls in the Python and .Net Programming Languages.</b><br>The following programs written in the Python programming language are available at <a href= 'https://github.com/device42/Device42-AutoDiscovery-Scripts'>Device42 sample programs</a><br><ul><li>api-sample.py: Runs against a single Windows system and uploads info to device42 appliance.</li><li>ad-sample.py: Can run against Active directory computers, servers or a given list and upload discovered systems’ info to device42 appliance.</li><li>d42_api_linux_upload_sample_script.py: Runs on a single *nix based system and uploads info to device42 appliance.</li><li>sample-script-facter-facts-to-d42: Runs on puppet master and uploads nodes info from facter fact files to device42 appliance.</li><li>d42_api_solaris_sample_script.py: Runs on an individual solaris system and uploads info to device42 appliance.</li></ul>The csv2d42apis.py sample program shows how to create a CSV file of data to import into device42. It reads a CSV file, matches columns to arguments for APIs and sends data to device42 via POST or PUT. This program can be found at: <a href= 'https://github.com/device42/API_Helpers'> Device42 sample CSV importer</a>.<br><br>The Auto Discovery Client source code can be found at Device42 <a href='https://docs.device42.com/auto-discovery/'>Auto Discovery Client</a>. This is a .net program that uses the device42 Restful API’s to load the discovered data.<h2><a id = 'Response_Status_Messages'><b>Response & Status Messages</b></a></h2><b>Responses</b><br>The response to most POST calls will have the following format: <br>{'msg':['PartModel added/updated', 17, 'RAM Acme 123456', true, true], 'code':0}<br><br>Using the example above:<br>'17' = ID of the object<br>'RAM Acme 123456' = representation of the object<br> 'true, true' = object added and is new.<br>'true, false' = object updated.<br>'false, false' = no changes.<br><br><b>Status Codes</b><br><u>Code 0</u><br>Success! e.g. = {'msg': 'device added or updated', <b>code:0</b>}<br><br><u>'HTTP/1.1 200 OK'</u><br>Success! All other responses are errors and will display an error code e.g.: 400, 401, 403, 405, 410, 500, 503. These are explained in each call.<br><br>Please let us know if you notice something odd with a response and we will fix it! :) <h2><a id = 'Get_Limits_Offsets'><b>API Get Limits and Offsets</b></a></h2>In Device42’s global settings we have the option to enforce API GET limits and this setting is recommended for better performance. To set this value from Device42, go to Tools>Settings>Global Settings and the click Edit in the top right. Toward the bottom of the screen you will see the API section. First check the “Enforce API GET Limits” checkbox, then enter a value for API GET Limit. A good limit to start with is 500 or 1000, depending on the performance you experience.<br><br>After setting this limit all GET calls below can have the results augmented via “offset” and “limit” parameters to tell Device42 which value to start returning results from, and how many results to return at maximum.<br>Examples:<br><br>'/?limit=50' returns the first 50 results.<br><br> '/?offset=100' will start at the 101st result. <br><br>'/?offset=42&limit=42' returns 42 results, starting at the 43rd.<br><br> Note that offset is used for paging - that is, the offset is only applied when the total number of objects returned exceeds the limit that is returned.
 *
 * API version: 2.0
 * Contact: support@device42.com
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package swagger

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"fmt"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type DevicesApiService service

/* 
DevicesApiService Delete device mountpoints
Delete Device Mountpoints
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id id of the mountpoint to delete

@return interface{}
*/
func (a *DevicesApiService) DeleteDeviceMountpoints(ctx context.Context, id int32) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/device/mountpoints/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
DevicesApiService Remove/Delete a device from a rack
This API call will remove/delete a device from a rack (Introduced in v6.3.2)
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param deviceId ID of the device to be removed from the rack

@return interface{}
*/
func (a *DevicesApiService) DeleteDeviceRackDeviceId(ctx context.Context, deviceId int32) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/device/rack/{device_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"device_id"+"}", fmt.Sprintf("%v", deviceId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
DevicesApiService Delete a device url
This API call will delete a device url (Introduced in v7.0.0)
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id

@return interface{}
*/
func (a *DevicesApiService) DeleteDeviceUrl(ctx context.Context, id int32) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/device/url/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
DevicesApiService Delete a device attachment by Device Id and Attachment Id.
Delete a file attachment for a specific device using device Id and the attachment Id.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param deviceId
 * @param id ID of the attachment to delete.

@return interface{}
*/
func (a *DevicesApiService) DeleteDevicesAttachment(ctx context.Context, deviceId int32, id int32) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/devices/id/{device-id}/attachments/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("device-id", parameterToString(deviceId, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
DevicesApiService Delete Device
This API is used to delete a device with the device id supplied as the required argument.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Device id

@return interface{}
*/
func (a *DevicesApiService) DeleteDevicesId(ctx context.Context, id int32) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/devices/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
DevicesApiService Get all attachments for a Device by Device Id.
Retrieve all the file attachments for a specific device using device id.&lt;br&gt; Returns a zip file of all the attachments associated with the device with the specified ID in URL.&lt;br&gt; Note that this implementation of Swagger does not support file download - use another mechanism such as cULR.&lt;br&gt; &lt;br&gt;cURL example:&lt;br&gt; curl -X GET \\&lt;br&gt; URL/api/1.0/devices/id/3/attachments \\&lt;br&gt; -H &#39;Authorization: Basic YWRtaW46YWRtIW5kNDI&#x3D;&#39;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param deviceId

@return interface{}
*/
func (a *DevicesApiService) GetAllDevicesAttachments(ctx context.Context, deviceId int32) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/devices/id/{device-id}/attachments/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("device-id", parameterToString(deviceId, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
DevicesApiService Get device mountpoints - introduced in version 10.5.0
Get Device Mountpoints
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DevicesApiGetDeviceMountpointsOpts - Optional Parameters:
     * @param "DeviceId" (optional.String) -  id of the device

@return interface{}
*/

type DevicesApiGetDeviceMountpointsOpts struct { 
	DeviceId optional.String
}

func (a *DevicesApiService) GetDeviceMountpoints(ctx context.Context, localVarOptionals *DevicesApiGetDeviceMountpointsOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/device/mountpoints/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.DeviceId.IsSet() {
		localVarQueryParams.Add("device_id", parameterToString(localVarOptionals.DeviceId.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
DevicesApiService Get device URLs - introduced in version 7.0.0
Get Device URLs
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DevicesApiGetDeviceUrlOpts - Optional Parameters:
     * @param "Device" (optional.String) -  name of the device

@return interface{}
*/

type DevicesApiGetDeviceUrlOpts struct { 
	Device optional.String
}

func (a *DevicesApiService) GetDeviceUrl(ctx context.Context, localVarOptionals *DevicesApiGetDeviceUrlOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/device/url/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Device.IsSet() {
		localVarQueryParams.Add("device", parameterToString(localVarOptionals.Device.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
DevicesApiService Retrieve basic information about all devices.
Get All Devices With Brief Output
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DevicesApiGetDevicesOpts - Optional Parameters:
     * @param "Type_" (optional.String) -  filter by device type (physical, virtual, blade, other, cluster, or unknown)
     * @param "DeviceSubType" (optional.String) -  filter by device sub type (Added in v14.7.2)
     * @param "DeviceSubTypeId" (optional.String) -  filter by device sub type id (Added in v14.7.2)
     * @param "ServiceLevel" (optional.String) -  filter by service level name
     * @param "InService" (optional.String) -  filter by whether in service or not. Use yes or no.
     * @param "Customer" (optional.String) -  filter by customer name
     * @param "Tags" (optional.String) -  filter by tags. comma separated for multiple tags (This is an OR filter, gets all the devices for all comma separated tags)
     * @param "BladeHostName" (optional.String) -  filter by blade host name
     * @param "VirtualHostName" (optional.String) -  filter by virtual host name
     * @param "BuildingId" (optional.String) -  filter by building ID (Added in v5.9.0)
     * @param "Building" (optional.String) -  filter by building name
     * @param "RoomId" (optional.String) -  filter by room ID (Added in v5.9.0)
     * @param "Room" (optional.String) -  filter by room name. Only works if room ID is not present (Added in v5.9.0)
     * @param "RackId" (optional.String) -  filter by rack ID (Added in v5.9.0)
     * @param "Rack" (optional.String) -  filter by rack name. Only works if rack ID is not present (Added in v5.9.0)
     * @param "SerialNo" (optional.String) -  filter by serial # (Added in v6.0.0)
     * @param "SerialNoContains" (optional.String) -  filter by partial serial match (Added in 9.7.1)
     * @param "ObjectCategory" (optional.String) -  filter by object category
     * @param "ObjectCategoryId" (optional.String) -  filter by object category ID
     * @param "AssetNo" (optional.String) -  filter by asset # (Added in v6.0.0)
     * @param "Name" (optional.String) -  filter by name (Added in v6.0.0)
     * @param "TagsAnd" (optional.String) -  filter by all the tags, separated by comma. (This is an AND filter and all tags have to match for filter, this was added in v6.3.1)
     * @param "Uuid" (optional.String) -  filter by uuid (exact match) (Added in v6.3.2)
     * @param "IsItSwitch" (optional.String) -  filter by whether switch or not. Use yes or no. (Added in v6.3.2)
     * @param "IsItVirtualHost" (optional.String) -  filter by whether virtual host or not. Use yes or no. (Added in v6.3.2)
     * @param "IsItBladeHost" (optional.String) -  filter by whether blade host or not. Use yes or no. (Added in v6.3.2)
     * @param "Hardware" (optional.String) -  filter by name of hardware model, comma separated for multiple hardware models (or filter). (Added in v6.3.2)
     * @param "HardwareIds" (optional.String) -  filter by ID of hardware models, comma separated
     * @param "Os" (optional.String) -  filter by OS name (added in v8.3.0)
     * @param "VirtualSubtype" (optional.String) -  filter by virtual subtype (added in v8.3.2)
     * @param "LastUpdatedLt" (optional.String) -  last updated less than date YYYY-MM-DD format
     * @param "LastUpdatedGt" (optional.String) -  last updated greater than date YYYY-MM-DD format
     * @param "FirstAddedLt" (optional.String) -  first added less than date YYYY-MM-DD format
     * @param "FirstAddedGt" (optional.String) -  first added greater date YYYY-MM-DD format
     * @param "CustomFieldsAnd" (optional.String) -  filter by custom fields, and filter, format of key1:value1,key2:value2
     * @param "CustomFieldsOr" (optional.String) -  filter by custom fields, or filter, format of key1:value1,key2:value2

@return interface{}
*/

type DevicesApiGetDevicesOpts struct { 
	Type_ optional.String
	DeviceSubType optional.String
	DeviceSubTypeId optional.String
	ServiceLevel optional.String
	InService optional.String
	Customer optional.String
	Tags optional.String
	BladeHostName optional.String
	VirtualHostName optional.String
	BuildingId optional.String
	Building optional.String
	RoomId optional.String
	Room optional.String
	RackId optional.String
	Rack optional.String
	SerialNo optional.String
	SerialNoContains optional.String
	ObjectCategory optional.String
	ObjectCategoryId optional.String
	AssetNo optional.String
	Name optional.String
	TagsAnd optional.String
	Uuid optional.String
	IsItSwitch optional.String
	IsItVirtualHost optional.String
	IsItBladeHost optional.String
	Hardware optional.String
	HardwareIds optional.String
	Os optional.String
	VirtualSubtype optional.String
	LastUpdatedLt optional.String
	LastUpdatedGt optional.String
	FirstAddedLt optional.String
	FirstAddedGt optional.String
	CustomFieldsAnd optional.String
	CustomFieldsOr optional.String
}

func (a *DevicesApiService) GetDevices(ctx context.Context, localVarOptionals *DevicesApiGetDevicesOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/devices/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarQueryParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceSubType.IsSet() {
		localVarQueryParams.Add("device_sub_type", parameterToString(localVarOptionals.DeviceSubType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceSubTypeId.IsSet() {
		localVarQueryParams.Add("device_sub_type_id", parameterToString(localVarOptionals.DeviceSubTypeId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ServiceLevel.IsSet() {
		localVarQueryParams.Add("service_level", parameterToString(localVarOptionals.ServiceLevel.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InService.IsSet() {
		localVarQueryParams.Add("in_service", parameterToString(localVarOptionals.InService.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Customer.IsSet() {
		localVarQueryParams.Add("customer", parameterToString(localVarOptionals.Customer.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tags.IsSet() {
		localVarQueryParams.Add("tags", parameterToString(localVarOptionals.Tags.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BladeHostName.IsSet() {
		localVarQueryParams.Add("blade_host_name", parameterToString(localVarOptionals.BladeHostName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VirtualHostName.IsSet() {
		localVarQueryParams.Add("virtual_host_name", parameterToString(localVarOptionals.VirtualHostName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BuildingId.IsSet() {
		localVarQueryParams.Add("building_id", parameterToString(localVarOptionals.BuildingId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Building.IsSet() {
		localVarQueryParams.Add("building", parameterToString(localVarOptionals.Building.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RoomId.IsSet() {
		localVarQueryParams.Add("room_id", parameterToString(localVarOptionals.RoomId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Room.IsSet() {
		localVarQueryParams.Add("room", parameterToString(localVarOptionals.Room.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RackId.IsSet() {
		localVarQueryParams.Add("rack_id", parameterToString(localVarOptionals.RackId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Rack.IsSet() {
		localVarQueryParams.Add("rack", parameterToString(localVarOptionals.Rack.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SerialNo.IsSet() {
		localVarQueryParams.Add("serial_no", parameterToString(localVarOptionals.SerialNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SerialNoContains.IsSet() {
		localVarQueryParams.Add("serial_no_contains", parameterToString(localVarOptionals.SerialNoContains.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectCategory.IsSet() {
		localVarQueryParams.Add("object_category", parameterToString(localVarOptionals.ObjectCategory.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectCategoryId.IsSet() {
		localVarQueryParams.Add("object_category_id", parameterToString(localVarOptionals.ObjectCategoryId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AssetNo.IsSet() {
		localVarQueryParams.Add("asset_no", parameterToString(localVarOptionals.AssetNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TagsAnd.IsSet() {
		localVarQueryParams.Add("tags_and", parameterToString(localVarOptionals.TagsAnd.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Uuid.IsSet() {
		localVarQueryParams.Add("uuid", parameterToString(localVarOptionals.Uuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsItSwitch.IsSet() {
		localVarQueryParams.Add("is_it_switch", parameterToString(localVarOptionals.IsItSwitch.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsItVirtualHost.IsSet() {
		localVarQueryParams.Add("is_it_virtual_host", parameterToString(localVarOptionals.IsItVirtualHost.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsItBladeHost.IsSet() {
		localVarQueryParams.Add("is_it_blade_host", parameterToString(localVarOptionals.IsItBladeHost.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Hardware.IsSet() {
		localVarQueryParams.Add("hardware", parameterToString(localVarOptionals.Hardware.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HardwareIds.IsSet() {
		localVarQueryParams.Add("hardware_ids", parameterToString(localVarOptionals.HardwareIds.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Os.IsSet() {
		localVarQueryParams.Add("os", parameterToString(localVarOptionals.Os.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VirtualSubtype.IsSet() {
		localVarQueryParams.Add("virtual_subtype", parameterToString(localVarOptionals.VirtualSubtype.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLt.IsSet() {
		localVarQueryParams.Add("last_updated_lt", parameterToString(localVarOptionals.LastUpdatedLt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGt.IsSet() {
		localVarQueryParams.Add("last_updated_gt", parameterToString(localVarOptionals.LastUpdatedGt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FirstAddedLt.IsSet() {
		localVarQueryParams.Add("first_added_lt", parameterToString(localVarOptionals.FirstAddedLt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FirstAddedGt.IsSet() {
		localVarQueryParams.Add("first_added_gt", parameterToString(localVarOptionals.FirstAddedGt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CustomFieldsAnd.IsSet() {
		localVarQueryParams.Add("custom_fields_and", parameterToString(localVarOptionals.CustomFieldsAnd.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CustomFieldsOr.IsSet() {
		localVarQueryParams.Add("custom_fields_or", parameterToString(localVarOptionals.CustomFieldsOr.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
DevicesApiService Retrieve detailed information about all devices.
Get All Devices With Detailed Output (added in v6.3.4)
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DevicesApiGetDevicesAllOpts - Optional Parameters:
     * @param "IncludeCols" (optional.String) -  do not return all columns just the ones specified. For example, ?include_cols&#x3D;name, device_id, rack will only result in name, device_id, and rack included in the output. The following column names can be part of include_cols: name, device_id, rack, name, device_id, serial_no, asset_no, uuid, notes, in_service, service_level, type, id, last_updated, tags, customer_id, customer, hw_model, hw_size, manufacturer, hw_depth, rack, start_at, rack_id, orientation, row, room, building, blade_host_name, blade_host_id, slot_number, virtual_host_name, location, device_sub_type, os, osarch, osver, osverno, custom_fields, device_purchase_line_items, device_external_links, ip_addresses, mac_addresses, cpucount, cpucore, cpuspeed, ram, hddcount, hddsize, hddraid, hddraid_type, hdd_details, pdu_mapping_url,modules, vms, devices, aliases, xpos, ucs_manager
     * @param "Limit" (optional.String) -  return this number of devices
     * @param "Offset" (optional.String) -  start with this device (e.g. limit&#x3D;100&amp;offset&#x3D;50 means start with the 50th device and return the next 100 devices)
     * @param "Blankasnull" (optional.String) -  start with this device (e.g. limit&#x3D;100&amp;offset&#x3D;50 means start with the 50th device and return the next 100 devices)

@return DevicesAll
*/

type DevicesApiGetDevicesAllOpts struct { 
	IncludeCols optional.String
	Limit optional.String
	Offset optional.String
	Blankasnull optional.String
}

func (a *DevicesApiService) GetDevicesAll(ctx context.Context, localVarOptionals *DevicesApiGetDevicesAllOpts) (DevicesAll, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DevicesAll
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/devices/all/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.IncludeCols.IsSet() {
		localVarQueryParams.Add("include_cols", parameterToString(localVarOptionals.IncludeCols.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Offset.IsSet() {
		localVarQueryParams.Add("offset", parameterToString(localVarOptionals.Offset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Blankasnull.IsSet() {
		localVarQueryParams.Add("blankasnull", parameterToString(localVarOptionals.Blankasnull.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v DevicesAll
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
DevicesApiService Get Device by Device Asset Number
Retrieve detailed information about a specific device by device asset number.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param deviceAsset
 * @param optional nil or *DevicesApiGetDevicesAssetOpts - Optional Parameters:
     * @param "IncludeCols" (optional.String) -  do not return all columns just the ones specified. For example, ?include_cols&#x3D;name, device_id, rack will only result in name, device_id, and rack included in the output. The following column names can be part of include_cols: name, device_id, rack, name, device_id, serial_no, asset_no, uuid, notes, in_service, service_level, type, id, last_updated, tags, customer_id, customer, hw_model, hw_size, manufacturer, hw_depth, rack, start_at, rack_id, orientation, row, room, building, blade_host_name, blade_host_id, slot_number, virtual_host_name, location, device_sub_type, os, osarch, osver, osverno, custom_fields, device_purchase_line_items, device_external_links, ip_addresses, mac_addresses, cpucount, cpucore, cpuspeed, ram, hddcount, hddsize, hddraid, hddraid_type, hdd_details, pdu_mapping_url,modules, vms, devices, aliases, xpos, ucs_manager

@return DevicesCustomerId
*/

type DevicesApiGetDevicesAssetOpts struct { 
	IncludeCols optional.String
}

func (a *DevicesApiService) GetDevicesAsset(ctx context.Context, deviceAsset string, localVarOptionals *DevicesApiGetDevicesAssetOpts) (DevicesCustomerId, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DevicesCustomerId
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/devices/asset/{device-asset}/"
	localVarPath = strings.Replace(localVarPath, "{"+"device-asset"+"}", fmt.Sprintf("%v", deviceAsset), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.IncludeCols.IsSet() {
		localVarQueryParams.Add("include_cols", parameterToString(localVarOptionals.IncludeCols.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v DevicesCustomerId
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
DevicesApiService Get Devices by Customer Id
Retrieve all devices associated with a specific customer.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param customerId
 * @param optional nil or *DevicesApiGetDevicesCustomerIdOpts - Optional Parameters:
     * @param "IncludeCols" (optional.String) -  do not return all columns just the ones specified. For example, ?include_cols&#x3D;name, device_id, rack will only result in name, device_id, and rack included in the output. The following column names can be part of include_cols: name, device_id, rack, name, device_id, serial_no, asset_no, uuid, notes, in_service, service_level, type, id, last_updated, tags, customer_id, customer, hw_model, hw_size, manufacturer, hw_depth, rack, start_at, rack_id, orientation, row, room, building, blade_host_name, blade_host_id, slot_number, virtual_host_name, location, device_sub_type, os, osarch, osver, osverno, custom_fields, device_purchase_line_items, device_external_links, ip_addresses, mac_addresses, cpucount, cpucore, cpuspeed, ram, hddcount, hddsize, hddraid, hddraid_type, hdd_details, pdu_mapping_url,modules, vms, devices, aliases, xpos, ucs_manager

@return DevicesCustomerId
*/

type DevicesApiGetDevicesCustomerIdOpts struct { 
	IncludeCols optional.String
}

func (a *DevicesApiService) GetDevicesCustomerId(ctx context.Context, customerId int32, localVarOptionals *DevicesApiGetDevicesCustomerIdOpts) (DevicesCustomerId, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DevicesCustomerId
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/devices/customer_id/{customer-id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"customer-id"+"}", fmt.Sprintf("%v", customerId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.IncludeCols.IsSet() {
		localVarQueryParams.Add("include_cols", parameterToString(localVarOptionals.IncludeCols.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v DevicesCustomerId
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
DevicesApiService Get Device by Device Id
Retrieve detailed information about a specific device using device id.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param deviceId
 * @param optional nil or *DevicesApiGetDevicesIdOpts - Optional Parameters:
     * @param "Follow" (optional.String) -  use yes if you want to see virtuals in a virtual host, modules in a blade chassis and devices in a clustered device (Added in v5.7.4)

@return DevicesAll
*/

type DevicesApiGetDevicesIdOpts struct { 
	Follow optional.String
}

func (a *DevicesApiService) GetDevicesId(ctx context.Context, deviceId int32, localVarOptionals *DevicesApiGetDevicesIdOpts) (DevicesAll, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DevicesAll
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/devices/id/{device-id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"device-id"+"}", fmt.Sprintf("%v", deviceId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Follow.IsSet() {
		localVarQueryParams.Add("follow", parameterToString(localVarOptionals.Follow.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v DevicesAll
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
DevicesApiService This API endpoint retrieves the impact list of a device by ID.
Get Device Impact List
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param deviceId

@return interface{}
*/
func (a *DevicesApiService) GetDevicesImpactlist(ctx context.Context, deviceId int32) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/device/impactlist/{device-id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"device-id"+"}", fmt.Sprintf("%v", deviceId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
DevicesApiService Get Device by Device Name
Retrieve detailed information about a specific device by device name
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param deviceName
 * @param optional nil or *DevicesApiGetDevicesNameOpts - Optional Parameters:
     * @param "IncludeCols" (optional.String) -  do not return all columns just the ones specified. For example, ?include_cols&#x3D;name, device_id, rack will only result in name, device_id, and rack included in the output. The following column names can be part of include_cols: name, device_id, rack, name, device_id, serial_no, asset_no, uuid, notes, in_service, service_level, type, id, last_updated, tags, customer_id, customer, hw_model, hw_size, manufacturer, hw_depth, rack, start_at, rack_id, orientation, row, room, building, blade_host_name, blade_host_id, slot_number, virtual_host_name, location, device_sub_type, os, osarch, osver, osverno, custom_fields, device_purchase_line_items, device_external_links, ip_addresses, mac_addresses, cpucount, cpucore, cpuspeed, ram, hddcount, hddsize, hddraid, hddraid_type, hdd_details, pdu_mapping_url,modules, vms, devices, aliases, xpos, ucs_manager
     * @param "Follow" (optional.String) -  use yes if you want to see virtuals in a virtual host, modules in a blade chassis and devices in a clusetered device

@return DevicesCustomerId
*/

type DevicesApiGetDevicesNameOpts struct { 
	IncludeCols optional.String
	Follow optional.String
}

func (a *DevicesApiService) GetDevicesName(ctx context.Context, deviceName string, localVarOptionals *DevicesApiGetDevicesNameOpts) (DevicesCustomerId, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DevicesCustomerId
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/devices/name/{device-name}/"
	localVarPath = strings.Replace(localVarPath, "{"+"device-name"+"}", fmt.Sprintf("%v", deviceName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.IncludeCols.IsSet() {
		localVarQueryParams.Add("include_cols", parameterToString(localVarOptionals.IncludeCols.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Follow.IsSet() {
		localVarQueryParams.Add("follow", parameterToString(localVarOptionals.Follow.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v DevicesCustomerId
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
DevicesApiService Get Device by Device Serial Number
Retrieve detailed information about a specific device by device serial number.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param deviceSerial
 * @param optional nil or *DevicesApiGetDevicesSerialOpts - Optional Parameters:
     * @param "IncludeCols" (optional.String) -  do not return all columns just the ones specified. For example, ?include_cols&#x3D;name, device_id, rack will only result in name, device_id, and rack included in the output. The following column names can be part of include_cols: name, device_id, rack, name, device_id, serial_no, asset_no, uuid, notes, in_service, service_level, type, id, last_updated, tags, customer_id, customer, hw_model, hw_size, manufacturer, hw_depth, rack, start_at, rack_id, orientation, row, room, building, blade_host_name, blade_host_id, slot_number, virtual_host_name, location, device_sub_type, os, osarch, osver, osverno, custom_fields, device_purchase_line_items, device_external_links, ip_addresses, mac_addresses, cpucount, cpucore, cpuspeed, ram, hddcount, hddsize, hddraid, hddraid_type, hdd_details, pdu_mapping_url,modules, vms, devices, aliases, xpos, ucs_manager

@return DevicesCustomerId
*/

type DevicesApiGetDevicesSerialOpts struct { 
	IncludeCols optional.String
}

func (a *DevicesApiService) GetDevicesSerial(ctx context.Context, deviceSerial string, localVarOptionals *DevicesApiGetDevicesSerialOpts) (DevicesCustomerId, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DevicesCustomerId
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/devices/serial/{device-serial}/"
	localVarPath = strings.Replace(localVarPath, "{"+"device-serial"+"}", fmt.Sprintf("%v", deviceSerial), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.IncludeCols.IsSet() {
		localVarQueryParams.Add("include_cols", parameterToString(localVarOptionals.IncludeCols.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v DevicesCustomerId
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
DevicesApiService Get a specific device attachment by Device Id and Attachment Id.
Retrieves a specific file attachment for a specific device using device id and attachment id.&lt;br&gt; Note that this implementation of Swagger does not support file download - use another mechanism such as cULR.&lt;br&gt; &lt;br&gt;cURL example:&lt;br&gt; curl -X GET \\&lt;br&gt; URL/api/1.0/devices/id/3/attachments/17 \\&lt;br&gt; -H &#39;Authorization: Basic YWRtaW46YWRtIW5kNDI&#x3D;&#39; 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param deviceId
 * @param attachmentId ID of the attachment to get.

@return interface{}
*/
func (a *DevicesApiService) GetaDevicesAttachment(ctx context.Context, deviceId int32, attachmentId int32) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/devices/id/{device-id}/attachments/{attachment_id}/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("device-id", parameterToString(deviceId, ""))
	localVarFormParams.Add("attachment_id", parameterToString(attachmentId, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
DevicesApiService Create/Update Device Cloud Instance Information
Update cloud instance information for devices. Requires either device or device_id
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DevicesApiPostCloudInstanceDeviceOpts - Optional Parameters:
     * @param "Device" (optional.String) -  Device name
     * @param "DeviceId" (optional.Int32) -  Device ID
     * @param "InstanceId" (optional.Int32) -  The cloud instance ID of the device
     * @param "Vendor" (optional.String) -  The cloud vendor
     * @param "Status" (optional.String) -  Instance status (ie, running, stopped)
     * @param "Location" (optional.String) -  Location/region of instance deployment
     * @param "Notes" (optional.String) -  Any additional notes

@return interface{}
*/

type DevicesApiPostCloudInstanceDeviceOpts struct { 
	Device optional.String
	DeviceId optional.Int32
	InstanceId optional.Int32
	Vendor optional.String
	Status optional.String
	Location optional.String
	Notes optional.String
}

func (a *DevicesApiService) PostCloudInstanceDevice(ctx context.Context, localVarOptionals *DevicesApiPostCloudInstanceDeviceOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/device/cloud_instance/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Device.IsSet() {
		localVarFormParams.Add("device", parameterToString(localVarOptionals.Device.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceId.IsSet() {
		localVarFormParams.Add("device_id", parameterToString(localVarOptionals.DeviceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InstanceId.IsSet() {
		localVarFormParams.Add("instance_id", parameterToString(localVarOptionals.InstanceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Vendor.IsSet() {
		localVarFormParams.Add("vendor", parameterToString(localVarOptionals.Vendor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Status.IsSet() {
		localVarFormParams.Add("status", parameterToString(localVarOptionals.Status.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Location.IsSet() {
		localVarFormParams.Add("location", parameterToString(localVarOptionals.Location.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Notes.IsSet() {
		localVarFormParams.Add("notes", parameterToString(localVarOptionals.Notes.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
DevicesApiService Create/Update Device by Name
This API is used to create a new device with the name supplied as the required argument or update an existing device that has the name, serial # or uuid of the required argument. For information purposes, this is also the API that is used by the Device42 auto-discovery tool.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DevicesApiPostDeviceOpts - Optional Parameters:
     * @param "Name" (optional.String) -  Device name. If device with name already exists - the existing device is updated. If an existing device based on serial # or uuid are found - name is ignored. In that case existing name is not changed and you can use new_name if you wish to change the name.
     * @param "NewName" (optional.String) -  As mentioned above, this can be used to change the name of an existing device
     * @param "SerialNo" (optional.String) -  the serial # of the device. If a device with matching serial # is found - that device is updated. Serial # with less than 3 characters in length are ignored. Also, certain generic serial #s like 123456789 or ‘not specified’ are ignored.
     * @param "Uuid" (optional.String) -  The uuid of the device. If a device with a matching uuid is found - that device is updated.
     * @param "AssetNo" (optional.String) -  the asset # of the device.
     * @param "Manufacturer" (optional.String) -  the hardware manufacturer for the device.
     * @param "Hardware" (optional.String) -  the name of the hardware model for the device. Use in conjunction with the manufacturer argument. However, an update will only occur if no hardware model is previously assigned to the device.
     * @param "NewHardware" (optional.String) -  If you want to change the hardware model for a device. If the device is rack mounted, it will unmount the device before changing hardware model and attempt to mount it back to same rack location (Changed in v6.3.2)
     * @param "IsItSwitch" (optional.String) -  ‘yes’ indicates if device is a network switch
     * @param "IsItVirtualHost" (optional.String) -  ‘yes’ indicates if device is a virtual host
     * @param "IsItBladeHost" (optional.String) -  ‘yes’ indicates if device is a blade host
     * @param "InService" (optional.String) -  ‘yes’ indicates if device is in service, ‘no’ indicates not in service
     * @param "Type_" (optional.String) -  is the type for device. Valid values are ‘unknown’, ‘physical’, ‘virtual’, ‘blade’, ‘cluster’, or ‘other’.
     * @param "ServiceLevel" (optional.String) -  the service level name for the device. The service level must be pre-defined in the device42 appliance before it can be referenced in an api call.
     * @param "VirtualHost" (optional.String) -  Is the name for the host of the virtual machine. Two conditions must be met for this value to successfully update: 1. The device must be a virtual machine. 2. The virtual host must already exist in the device42 application and must be already marked as a virtual host.
     * @param "BladeHost" (optional.String) -  the name of the host for the blade machine. Two conditions must be met for this value to successfully update: 1. The device must be a blade type. 2. The blade host must already exist and must already be marked as a blade host.
     * @param "SlotNo" (optional.Int32) -  slot # for blade device.
     * @param "StorageRoomId" (optional.Int32) -  ID of the room to assign device to storage room. Added in v5.5.0
     * @param "StorageRoom" (optional.String) -  name of the room to assign device to, only used if the room name is unique. Added in v5.5.0
     * @param "Os" (optional.String) -  the name of the operating system (os, osver, and osverno all required if updating any of the three).
     * @param "Osver" (optional.String) -  the version of the operating system (os, osver, and osverno all required if updating any of the three)
     * @param "Osarch" (optional.String) -  The architecture of the operating system (32 or 64)
     * @param "Osverno" (optional.Int32) -  the version # or build # of the operating system (os, osver, and osverno all required if updating any of the three)
     * @param "Memory" (optional.String) -  the total memory(RAM) in MB. Just numbers.
     * @param "Cpucount" (optional.Int32) -  total # of CPUs. (If updating, cpupower and cpucore required)
     * @param "Cpupower" (optional.String) -  CPU speed in MHz, just numbers. (If updating, cpucount and cpucore required)
     * @param "Cpucore" (optional.String) -  number of cores/CPU. Integer. (If updating, cpupower and cpucount required)
     * @param "Hddcount" (optional.Int32) -  total # of HDD (hddcount, hddsize, hddraid, and hddraid_type all required when updating any of the 4)
     * @param "Hddsize" (optional.String) -  HDD Size in GB (hddcount, hddsize, hddraid, and hddraid_type all required when updating any of the 4)
     * @param "Hddraid" (optional.String) -  Raid. Possible values: software or hardware. none to clear. (none added in v9.1.0) (hddcount, hddsize, hddraid, and hddraid_type all required when updating any of the 4)
     * @param "HddraidType" (optional.String) -  Raid Type. (hddcount, hddsize, hddraid, and hddraid_type all required when updating any of the 4)
     * @param "Macaddress" (optional.String) -  the mac address value. Use multiple POST/PUT to add multiple mac addresses.
     * @param "DevicesInCluster" (optional.String) -  comma separated device names for devices in cluster. Only valid for device type cluster.
     * @param "Appcomps" (optional.String) -  comma separated application component names on this device.
     * @param "Customer" (optional.String) -  name of the customer. Customer record must already exist.
     * @param "ContractId" (optional.Int32) -  ID for the contract. Available via GET /api/api/1.0/contracts/ – DEPRECATED in v550.
     * @param "Contract" (optional.String) -  Name of the contract. Used only if contract name is unique. – DEPRECATED in v550.
     * @param "Aliases" (optional.String) -  optional. Comma separated aliases for the device. Must not exist, ignored otherwise.
     * @param "Subtype" (optional.String) -  Only for device type other. Must exist internally first.
     * @param "BladeHostClear" (optional.String) -  clear blade host for device
     * @param "VirtualSubtype" (optional.String) -  Only for device type virtual. Default is internal VM.
     * @param "Notes" (optional.String) - 
     * @param "Tags" (optional.String) -  comma separated tags (Added in v5.9.2)
     * @param "VirtualHostClear" (optional.String) -  yes to clear virtual host for a VM (added in v9.1.0)
     * @param "TagsRemove" (optional.String) -  comma separated tags to remove (added in v9.1.0)
     * @param "AliasesRemove" (optional.String) -  comma separated aliases to remove
     * @param "DevicesInClusterRemove" (optional.String) -  comma separated device names for removing devices in cluster. Only valid for device type cluster. (added in v9.2.0)
     * @param "ObjectCategory" (optional.String) -  If multitenancy is on, a category can be assigned to control access to this object, e.g. Prod_East specifies that the users with access to the Prod_East category will be able to access this device.
     * @param "NewObjectCategory" (optional.String) -  Used to change category on a device if it is already set.

@return interface{}
*/

type DevicesApiPostDeviceOpts struct { 
	Name optional.String
	NewName optional.String
	SerialNo optional.String
	Uuid optional.String
	AssetNo optional.String
	Manufacturer optional.String
	Hardware optional.String
	NewHardware optional.String
	IsItSwitch optional.String
	IsItVirtualHost optional.String
	IsItBladeHost optional.String
	InService optional.String
	Type_ optional.String
	ServiceLevel optional.String
	VirtualHost optional.String
	BladeHost optional.String
	SlotNo optional.Int32
	StorageRoomId optional.Int32
	StorageRoom optional.String
	Os optional.String
	Osver optional.String
	Osarch optional.String
	Osverno optional.Int32
	Memory optional.String
	Cpucount optional.Int32
	Cpupower optional.String
	Cpucore optional.String
	Hddcount optional.Int32
	Hddsize optional.String
	Hddraid optional.String
	HddraidType optional.String
	Macaddress optional.String
	DevicesInCluster optional.String
	Appcomps optional.String
	Customer optional.String
	ContractId optional.Int32
	Contract optional.String
	Aliases optional.String
	Subtype optional.String
	BladeHostClear optional.String
	VirtualSubtype optional.String
	Notes optional.String
	Tags optional.String
	VirtualHostClear optional.String
	TagsRemove optional.String
	AliasesRemove optional.String
	DevicesInClusterRemove optional.String
	ObjectCategory optional.String
	NewObjectCategory optional.String
}

func (a *DevicesApiService) PostDevice(ctx context.Context, localVarOptionals *DevicesApiPostDeviceOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/device/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarFormParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NewName.IsSet() {
		localVarFormParams.Add("new_name", parameterToString(localVarOptionals.NewName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SerialNo.IsSet() {
		localVarFormParams.Add("serial_no", parameterToString(localVarOptionals.SerialNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Uuid.IsSet() {
		localVarFormParams.Add("uuid", parameterToString(localVarOptionals.Uuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AssetNo.IsSet() {
		localVarFormParams.Add("asset_no", parameterToString(localVarOptionals.AssetNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Manufacturer.IsSet() {
		localVarFormParams.Add("manufacturer", parameterToString(localVarOptionals.Manufacturer.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Hardware.IsSet() {
		localVarFormParams.Add("hardware", parameterToString(localVarOptionals.Hardware.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NewHardware.IsSet() {
		localVarFormParams.Add("new_hardware", parameterToString(localVarOptionals.NewHardware.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsItSwitch.IsSet() {
		localVarFormParams.Add("is_it_switch", parameterToString(localVarOptionals.IsItSwitch.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsItVirtualHost.IsSet() {
		localVarFormParams.Add("is_it_virtual_host", parameterToString(localVarOptionals.IsItVirtualHost.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsItBladeHost.IsSet() {
		localVarFormParams.Add("is_it_blade_host", parameterToString(localVarOptionals.IsItBladeHost.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InService.IsSet() {
		localVarFormParams.Add("in_service", parameterToString(localVarOptionals.InService.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarFormParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ServiceLevel.IsSet() {
		localVarFormParams.Add("service_level", parameterToString(localVarOptionals.ServiceLevel.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VirtualHost.IsSet() {
		localVarFormParams.Add("virtual_host", parameterToString(localVarOptionals.VirtualHost.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BladeHost.IsSet() {
		localVarFormParams.Add("blade_host", parameterToString(localVarOptionals.BladeHost.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SlotNo.IsSet() {
		localVarFormParams.Add("slot_no", parameterToString(localVarOptionals.SlotNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StorageRoomId.IsSet() {
		localVarFormParams.Add("storage_room_id", parameterToString(localVarOptionals.StorageRoomId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StorageRoom.IsSet() {
		localVarFormParams.Add("storage_room", parameterToString(localVarOptionals.StorageRoom.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Os.IsSet() {
		localVarFormParams.Add("os", parameterToString(localVarOptionals.Os.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Osver.IsSet() {
		localVarFormParams.Add("osver", parameterToString(localVarOptionals.Osver.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Osarch.IsSet() {
		localVarFormParams.Add("osarch", parameterToString(localVarOptionals.Osarch.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Osverno.IsSet() {
		localVarFormParams.Add("osverno", parameterToString(localVarOptionals.Osverno.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Memory.IsSet() {
		localVarFormParams.Add("memory", parameterToString(localVarOptionals.Memory.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cpucount.IsSet() {
		localVarFormParams.Add("cpucount", parameterToString(localVarOptionals.Cpucount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cpupower.IsSet() {
		localVarFormParams.Add("cpupower", parameterToString(localVarOptionals.Cpupower.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cpucore.IsSet() {
		localVarFormParams.Add("cpucore", parameterToString(localVarOptionals.Cpucore.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Hddcount.IsSet() {
		localVarFormParams.Add("hddcount", parameterToString(localVarOptionals.Hddcount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Hddsize.IsSet() {
		localVarFormParams.Add("hddsize", parameterToString(localVarOptionals.Hddsize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Hddraid.IsSet() {
		localVarFormParams.Add("hddraid", parameterToString(localVarOptionals.Hddraid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HddraidType.IsSet() {
		localVarFormParams.Add("hddraid_type", parameterToString(localVarOptionals.HddraidType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Macaddress.IsSet() {
		localVarFormParams.Add("macaddress", parameterToString(localVarOptionals.Macaddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DevicesInCluster.IsSet() {
		localVarFormParams.Add("devices_in_cluster", parameterToString(localVarOptionals.DevicesInCluster.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Appcomps.IsSet() {
		localVarFormParams.Add("appcomps", parameterToString(localVarOptionals.Appcomps.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Customer.IsSet() {
		localVarFormParams.Add("customer", parameterToString(localVarOptionals.Customer.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ContractId.IsSet() {
		localVarFormParams.Add("contract_id", parameterToString(localVarOptionals.ContractId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Contract.IsSet() {
		localVarFormParams.Add("contract", parameterToString(localVarOptionals.Contract.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Aliases.IsSet() {
		localVarFormParams.Add("aliases", parameterToString(localVarOptionals.Aliases.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Subtype.IsSet() {
		localVarFormParams.Add("subtype", parameterToString(localVarOptionals.Subtype.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BladeHostClear.IsSet() {
		localVarFormParams.Add("blade_host_clear", parameterToString(localVarOptionals.BladeHostClear.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VirtualSubtype.IsSet() {
		localVarFormParams.Add("virtual_subtype", parameterToString(localVarOptionals.VirtualSubtype.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Notes.IsSet() {
		localVarFormParams.Add("notes", parameterToString(localVarOptionals.Notes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tags.IsSet() {
		localVarFormParams.Add("tags", parameterToString(localVarOptionals.Tags.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VirtualHostClear.IsSet() {
		localVarFormParams.Add("virtual_host_clear", parameterToString(localVarOptionals.VirtualHostClear.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TagsRemove.IsSet() {
		localVarFormParams.Add("tags_remove", parameterToString(localVarOptionals.TagsRemove.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AliasesRemove.IsSet() {
		localVarFormParams.Add("aliases_remove", parameterToString(localVarOptionals.AliasesRemove.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DevicesInClusterRemove.IsSet() {
		localVarFormParams.Add("devices_in_cluster_remove", parameterToString(localVarOptionals.DevicesInClusterRemove.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectCategory.IsSet() {
		localVarFormParams.Add("object_category", parameterToString(localVarOptionals.ObjectCategory.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NewObjectCategory.IsSet() {
		localVarFormParams.Add("new_object_category", parameterToString(localVarOptionals.NewObjectCategory.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
DevicesApiService Create/Update device mountpoints - introduced in version 10.5.0
Create/Update Device Mountpoints
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param mountpoint path of the mountpoint
 * @param device device mountpoint is assigned to
 * @param optional nil or *DevicesApiPostDeviceMountpointsOpts - Optional Parameters:
     * @param "Filesytem" (optional.String) -  mountpoint filesystem
     * @param "Fstype" (optional.String) -  mountpoint filesystem type
     * @param "Capacity" (optional.String) -  capacity of mountpoint in MB
     * @param "FreeCapacity" (optional.String) -  free capacity of mountpoint in MB
     * @param "Label" (optional.String) - 

@return interface{}
*/

type DevicesApiPostDeviceMountpointsOpts struct { 
	Filesytem optional.String
	Fstype optional.String
	Capacity optional.String
	FreeCapacity optional.String
	Label optional.String
}

func (a *DevicesApiService) PostDeviceMountpoints(ctx context.Context, mountpoint string, device string, localVarOptionals *DevicesApiPostDeviceMountpointsOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/device/mountpoints/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("mountpoint", parameterToString(mountpoint, ""))
	localVarFormParams.Add("device", parameterToString(device, ""))
	if localVarOptionals != nil && localVarOptionals.Filesytem.IsSet() {
		localVarFormParams.Add("filesytem", parameterToString(localVarOptionals.Filesytem.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fstype.IsSet() {
		localVarFormParams.Add("fstype", parameterToString(localVarOptionals.Fstype.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Capacity.IsSet() {
		localVarFormParams.Add("capacity", parameterToString(localVarOptionals.Capacity.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FreeCapacity.IsSet() {
		localVarFormParams.Add("free_capacity", parameterToString(localVarOptionals.FreeCapacity.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Label.IsSet() {
		localVarFormParams.Add("label", parameterToString(localVarOptionals.Label.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
DevicesApiService Add/Update a device in a rack.
This API will add a new or existing device to a rack or will update an existing device that is already in the rack. (Introduced in v321)&lt;br&gt; Required parameters: &lt;ul&gt;&lt;li&gt;device &lt;b&gt;OR&lt;/b&gt; device_id &lt;b&gt;OR&lt;/b&gt; serial_no &lt;b&gt;OR&lt;/b&gt; asset_no&lt;/li&gt; &lt;li&gt;rack_id &lt;b&gt;OR&lt;/b&gt; rack (with building, room, or row to identify unique rack) &lt;li&gt;start_at&lt;/li&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param startAt This is the starting U location for the device in the rack. Starting with v535, you can use “auto” as value to automatically mount the device in next available slot.
 * @param optional nil or *DevicesApiPostDeviceRackOpts - Optional Parameters:
     * @param "Device" (optional.String) -  name of the new or existing device
     * @param "DeviceId" (optional.Int32) -  Device ID of existing device
     * @param "SerialNo" (optional.String) -  serial # of the existing device
     * @param "AssetNo" (optional.String) -  asset # of the existing device
     * @param "HwModel" (optional.String) -  If the hw_model doesn’t exist or doesn’t have a type, we will add it as type “regular (rack mountable)” (changed in v6.6.0)
     * @param "Size" (optional.String) -  size of the hardware model, only for new hardware model or if hardware model doesn’t have size. required for new hardware model (added in v6.6.0)
     * @param "Manufacturer" (optional.String) -  manufacturer of the hardware model. Only for new hardware model being added(added in v6.6.0)
     * @param "RackId" (optional.String) -  required if building name, room name or rack name are not provided. This is the id of the rack. It can be obtained from Tools &gt; Import &gt; Import Racked Devices.
     * @param "Building" (optional.String) -  building is building name, room is room name, rack is rack name and row is optional. This is used if rack_id is not provided and a unique rack is found with that combination. This could be just rack for rack name, if the rack name is unique. Otherwise add row, room or building to identify a unique rack.
     * @param "Room" (optional.String) - 
     * @param "Rack" (optional.String) - 
     * @param "Row" (optional.String) - 
     * @param "Where" (optional.String) -  location in rack, one of ‘above’, ‘below’, ‘left’, ‘right’, ‘mounted’. Note: If mounted a size must be provided or available from the hardware model.
     * @param "XPos" (optional.String) -  A number between 0 and 2520 representing the position within the u slot. 0 is flush left. 2520 is flush right.

@return interface{}
*/

type DevicesApiPostDeviceRackOpts struct { 
	Device optional.String
	DeviceId optional.Int32
	SerialNo optional.String
	AssetNo optional.String
	HwModel optional.String
	Size optional.String
	Manufacturer optional.String
	RackId optional.String
	Building optional.String
	Room optional.String
	Rack optional.String
	Row optional.String
	Where optional.String
	XPos optional.String
}

func (a *DevicesApiService) PostDeviceRack(ctx context.Context, startAt string, localVarOptionals *DevicesApiPostDeviceRackOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/device/rack/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Device.IsSet() {
		localVarFormParams.Add("device", parameterToString(localVarOptionals.Device.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceId.IsSet() {
		localVarFormParams.Add("device_id", parameterToString(localVarOptionals.DeviceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SerialNo.IsSet() {
		localVarFormParams.Add("serial_no", parameterToString(localVarOptionals.SerialNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AssetNo.IsSet() {
		localVarFormParams.Add("asset_no", parameterToString(localVarOptionals.AssetNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HwModel.IsSet() {
		localVarFormParams.Add("hw_model", parameterToString(localVarOptionals.HwModel.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Size.IsSet() {
		localVarFormParams.Add("size", parameterToString(localVarOptionals.Size.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Manufacturer.IsSet() {
		localVarFormParams.Add("manufacturer", parameterToString(localVarOptionals.Manufacturer.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RackId.IsSet() {
		localVarFormParams.Add("rack_id", parameterToString(localVarOptionals.RackId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Building.IsSet() {
		localVarFormParams.Add("building", parameterToString(localVarOptionals.Building.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Room.IsSet() {
		localVarFormParams.Add("room", parameterToString(localVarOptionals.Room.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Rack.IsSet() {
		localVarFormParams.Add("rack", parameterToString(localVarOptionals.Rack.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Row.IsSet() {
		localVarFormParams.Add("row", parameterToString(localVarOptionals.Row.Value(), ""))
	}
	localVarFormParams.Add("start_at", parameterToString(startAt, ""))
	if localVarOptionals != nil && localVarOptionals.Where.IsSet() {
		localVarFormParams.Add("where", parameterToString(localVarOptionals.Where.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.XPos.IsSet() {
		localVarFormParams.Add("x_pos", parameterToString(localVarOptionals.XPos.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
DevicesApiService Use this API to associate a url (e.g. an http, https, or telnet url) with a device.
Add Url to Device
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param type_ the url type (e.g. http, https, telnet). This must be an existing url type in device42.
 * @param device name of the device to which this url belongs (required parameter)
 * @param optional nil or *DevicesApiPostDeviceUrlOpts - Optional Parameters:
     * @param "Host" (optional.String) -  fqdn portion of the url. e.g. for http://www.device42.com/awesome, host is www.device42.com
     * @param "Port" (optional.String) -  port number if any
     * @param "UrlSuffix" (optional.String) -  url suffix if any. e.g. it is “awesome” based on example given above.
     * @param "Notes" (optional.String) - 

@return interface{}
*/

type DevicesApiPostDeviceUrlOpts struct { 
	Host optional.String
	Port optional.String
	UrlSuffix optional.String
	Notes optional.String
}

func (a *DevicesApiService) PostDeviceUrl(ctx context.Context, type_ string, device string, localVarOptionals *DevicesApiPostDeviceUrlOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/device/url/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("type", parameterToString(type_, ""))
	localVarFormParams.Add("device", parameterToString(device, ""))
	if localVarOptionals != nil && localVarOptionals.Host.IsSet() {
		localVarFormParams.Add("host", parameterToString(localVarOptionals.Host.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Port.IsSet() {
		localVarFormParams.Add("port", parameterToString(localVarOptionals.Port.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UrlSuffix.IsSet() {
		localVarFormParams.Add("url_suffix", parameterToString(localVarOptionals.UrlSuffix.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Notes.IsSet() {
		localVarFormParams.Add("notes", parameterToString(localVarOptionals.Notes.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
DevicesApiService Create/Update Multi-Node Device by Name
This API is used to create a new device with the name supplied as the required argument or update an existing device that with that name. This is similar to /api/api/1.0/devices/ POST call - but you can add duplicate serial #s and UUID for high density servers that share the same serial # and/or UUID.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DevicesApiPostMultiNodeDeviceOpts - Optional Parameters:
     * @param "Name" (optional.String) -  Device name. If device with name already exists - the existing device is updated. If an existing device based on serial # or uuid are found - name is ignored. In that case existing name is not changed and you can use new_name if you wish to change the name.
     * @param "NewName" (optional.String) -  As mentioned above, this can be used to change the name of an existing device
     * @param "SerialNo" (optional.String) -  the serial # of the device. If a device with matching serial # is found - that device is updated. Serial # with less than 3 characters in length are ignored. Also, certain generic serial #s like 123456789 or ‘not specified’ are ignored.
     * @param "Uuid" (optional.Int32) -  the uuid of the device. If a device with matching uuid is found - that device is updated.
     * @param "AssetNo" (optional.String) -  the asset # of the device.
     * @param "Manufacturer" (optional.String) -  the hardware manufacturer for the device.
     * @param "Hardware" (optional.String) -  the name of the hardware model for the device. Use in conjunction with the manufacturer argument. However, an update will only occur if no hardware model is previously assigned to the device.
     * @param "NewHardware" (optional.String) -  If you want to change the hardware model for a device. If the device is rack mounted, it will unmount the device before changing hardware model and attempt to mount it back to same rack location (Changed in v6.3.2)
     * @param "IsItSwitch" (optional.String) -  ‘yes’ indicates if device is a network switch
     * @param "IsItVirtualHost" (optional.String) -  ‘yes’ indicates if device is a virtual host
     * @param "IsItBladeHost" (optional.String) -  ‘yes’ indicates if device is a blade host
     * @param "InService" (optional.String) -  ‘yes’ indicates if device is in service, ‘no’ indicates not in service
     * @param "Type_" (optional.String) -  the type of the device
     * @param "ServiceLevel" (optional.String) -  the service level name for the device. The service level must be pre-defined in the device42 appliance before it can be referenced in an api call.
     * @param "VirtualHost" (optional.String) -  Is the name for the host of the virtual machine. Two conditions must be met for this value to successfully update: 1. The device must be a virtual machine. 2. The virtual host must already exist in the device42 application and must be already marked as a virtual host.
     * @param "BladeHost" (optional.String) -  the name of the host for the blade machine. Two conditions must be met for this value to successfully update: 1. The device must be a blade type. 2. The blade host must already exist and must already be marked as a blade host.
     * @param "SlotNo" (optional.Int32) -  slot # for blade device.
     * @param "StorageRoomId" (optional.Int32) -  ID of the room to assign device to storage room. Added in v5.5.0
     * @param "StorageRoom" (optional.String) -  name of the room to assign device to, only used if the room name is unique. Added in v5.5.0
     * @param "Os" (optional.String) -  the name of the operating system (os, osver, and osverno all required if updating any of the three).
     * @param "Osver" (optional.String) -  the version of the operating system (os, osver, and osverno all required if updating any of the three)
     * @param "Osarch" (optional.String) -  The architecture of the operating system (32 or 64)
     * @param "Osverno" (optional.Int32) -  the version # or build # of the operating system (os, osver, and osverno all required if updating any of the three)
     * @param "Memory" (optional.String) -  the total memory(RAM) in MB. Just numbers.
     * @param "Cpucount" (optional.Int32) -  total # of CPUs. (If updating, cpupower and cpucore required)
     * @param "Cpupower" (optional.String) -  CPU speed in MHz, just numbers. (If updating, cpucount and cpucore required)
     * @param "Cpucore" (optional.String) -  number of cores/CPU. Integer. (If updating, cpupower and cpucount required)
     * @param "Hddcount" (optional.Int32) -  total # of HDD (hddcount, hddsize, hddraid, and hddraid_type all required when updating any of the 4)
     * @param "Hddsize" (optional.String) -  HDD Size in GB (hddcount, hddsize, hddraid, and hddraid_type all required when updating any of the 4)
     * @param "Hddraid" (optional.String) -  Raid. Possible values: software or hardware. none to clear. (none added in v9.1.0) (hddcount, hddsize, hddraid, and hddraid_type all required when updating any of the 4)
     * @param "HddraidType" (optional.String) -  Raid Type. (hddcount, hddsize, hddraid, and hddraid_type all required when updating any of the 4)
     * @param "Macaddress" (optional.String) -  the mac address value. Use multiple POST/PUT to add multiple mac addresses.
     * @param "DevicesInCluster" (optional.String) -  comma separated device names for devices in cluster. Only valid for device type cluster.
     * @param "Appcomps" (optional.String) -  comma separated application component names on this device.
     * @param "Customer" (optional.String) -  name of the customer. Customer record must already exist.
     * @param "ContractId" (optional.Int32) -  ID for the contract. Available via GET /api/api/1.0/contracts/ – DEPRECATED in v550.
     * @param "Contract" (optional.String) -  Name of the contract. Used only if contract name is unique. – DEPRECATED in v550.
     * @param "Aliases" (optional.String) -  optional. Comma separated aliases for the device. Must not exist, ignored otherwise.
     * @param "Subtype" (optional.String) -  Only for device type other. Must exist internally first.
     * @param "BladeHostClear" (optional.String) -  clear blade host for device
     * @param "VirtualSubtype" (optional.String) -  Only for device type virtual. Default is internal VM.
     * @param "Notes" (optional.String) - 
     * @param "Tags" (optional.String) -  comma separated tags (Added in v5.9.2)
     * @param "VirtualHostClear" (optional.String) -  yes to clear virtual host for a VM (added in v9.1.0)
     * @param "TagsRemove" (optional.String) -  comma separated tags to remove (added in v9.1.0)
     * @param "AliasesRemove" (optional.String) -  comma separated aliases to remove
     * @param "DevicesInClusterRemove" (optional.String) -  comma separated device names for removing devices in cluster. Only valid for device type cluster. (added in v9.2.0)
     * @param "ObjectCategory" (optional.String) -  If multitenancy is on, a category can be assigned to control access to this object, e.g. Prod_East specifies that the users with access to the Prod_East category will be able to access this device.
     * @param "NewObjectCategory" (optional.String) -  Used to change category on a device if it is already set.

@return interface{}
*/

type DevicesApiPostMultiNodeDeviceOpts struct { 
	Name optional.String
	NewName optional.String
	SerialNo optional.String
	Uuid optional.Int32
	AssetNo optional.String
	Manufacturer optional.String
	Hardware optional.String
	NewHardware optional.String
	IsItSwitch optional.String
	IsItVirtualHost optional.String
	IsItBladeHost optional.String
	InService optional.String
	Type_ optional.String
	ServiceLevel optional.String
	VirtualHost optional.String
	BladeHost optional.String
	SlotNo optional.Int32
	StorageRoomId optional.Int32
	StorageRoom optional.String
	Os optional.String
	Osver optional.String
	Osarch optional.String
	Osverno optional.Int32
	Memory optional.String
	Cpucount optional.Int32
	Cpupower optional.String
	Cpucore optional.String
	Hddcount optional.Int32
	Hddsize optional.String
	Hddraid optional.String
	HddraidType optional.String
	Macaddress optional.String
	DevicesInCluster optional.String
	Appcomps optional.String
	Customer optional.String
	ContractId optional.Int32
	Contract optional.String
	Aliases optional.String
	Subtype optional.String
	BladeHostClear optional.String
	VirtualSubtype optional.String
	Notes optional.String
	Tags optional.String
	VirtualHostClear optional.String
	TagsRemove optional.String
	AliasesRemove optional.String
	DevicesInClusterRemove optional.String
	ObjectCategory optional.String
	NewObjectCategory optional.String
}

func (a *DevicesApiService) PostMultiNodeDevice(ctx context.Context, localVarOptionals *DevicesApiPostMultiNodeDeviceOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/multinodes/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarFormParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NewName.IsSet() {
		localVarFormParams.Add("new_name", parameterToString(localVarOptionals.NewName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SerialNo.IsSet() {
		localVarFormParams.Add("serial_no", parameterToString(localVarOptionals.SerialNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Uuid.IsSet() {
		localVarFormParams.Add("uuid", parameterToString(localVarOptionals.Uuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AssetNo.IsSet() {
		localVarFormParams.Add("asset_no", parameterToString(localVarOptionals.AssetNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Manufacturer.IsSet() {
		localVarFormParams.Add("manufacturer", parameterToString(localVarOptionals.Manufacturer.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Hardware.IsSet() {
		localVarFormParams.Add("hardware", parameterToString(localVarOptionals.Hardware.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NewHardware.IsSet() {
		localVarFormParams.Add("new_hardware", parameterToString(localVarOptionals.NewHardware.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsItSwitch.IsSet() {
		localVarFormParams.Add("is_it_switch", parameterToString(localVarOptionals.IsItSwitch.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsItVirtualHost.IsSet() {
		localVarFormParams.Add("is_it_virtual_host", parameterToString(localVarOptionals.IsItVirtualHost.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsItBladeHost.IsSet() {
		localVarFormParams.Add("is_it_blade_host", parameterToString(localVarOptionals.IsItBladeHost.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InService.IsSet() {
		localVarFormParams.Add("in_service", parameterToString(localVarOptionals.InService.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarFormParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ServiceLevel.IsSet() {
		localVarFormParams.Add("service_level", parameterToString(localVarOptionals.ServiceLevel.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VirtualHost.IsSet() {
		localVarFormParams.Add("virtual_host", parameterToString(localVarOptionals.VirtualHost.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BladeHost.IsSet() {
		localVarFormParams.Add("blade_host", parameterToString(localVarOptionals.BladeHost.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SlotNo.IsSet() {
		localVarFormParams.Add("slot_no", parameterToString(localVarOptionals.SlotNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StorageRoomId.IsSet() {
		localVarFormParams.Add("storage_room_id", parameterToString(localVarOptionals.StorageRoomId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StorageRoom.IsSet() {
		localVarFormParams.Add("storage_room", parameterToString(localVarOptionals.StorageRoom.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Os.IsSet() {
		localVarFormParams.Add("os", parameterToString(localVarOptionals.Os.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Osver.IsSet() {
		localVarFormParams.Add("osver", parameterToString(localVarOptionals.Osver.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Osarch.IsSet() {
		localVarFormParams.Add("osarch", parameterToString(localVarOptionals.Osarch.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Osverno.IsSet() {
		localVarFormParams.Add("osverno", parameterToString(localVarOptionals.Osverno.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Memory.IsSet() {
		localVarFormParams.Add("memory", parameterToString(localVarOptionals.Memory.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cpucount.IsSet() {
		localVarFormParams.Add("cpucount", parameterToString(localVarOptionals.Cpucount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cpupower.IsSet() {
		localVarFormParams.Add("cpupower", parameterToString(localVarOptionals.Cpupower.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cpucore.IsSet() {
		localVarFormParams.Add("cpucore", parameterToString(localVarOptionals.Cpucore.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Hddcount.IsSet() {
		localVarFormParams.Add("hddcount", parameterToString(localVarOptionals.Hddcount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Hddsize.IsSet() {
		localVarFormParams.Add("hddsize", parameterToString(localVarOptionals.Hddsize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Hddraid.IsSet() {
		localVarFormParams.Add("hddraid", parameterToString(localVarOptionals.Hddraid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HddraidType.IsSet() {
		localVarFormParams.Add("hddraid_type", parameterToString(localVarOptionals.HddraidType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Macaddress.IsSet() {
		localVarFormParams.Add("macaddress", parameterToString(localVarOptionals.Macaddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DevicesInCluster.IsSet() {
		localVarFormParams.Add("devices_in_cluster", parameterToString(localVarOptionals.DevicesInCluster.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Appcomps.IsSet() {
		localVarFormParams.Add("appcomps", parameterToString(localVarOptionals.Appcomps.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Customer.IsSet() {
		localVarFormParams.Add("customer", parameterToString(localVarOptionals.Customer.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ContractId.IsSet() {
		localVarFormParams.Add("contract_id", parameterToString(localVarOptionals.ContractId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Contract.IsSet() {
		localVarFormParams.Add("contract", parameterToString(localVarOptionals.Contract.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Aliases.IsSet() {
		localVarFormParams.Add("aliases", parameterToString(localVarOptionals.Aliases.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Subtype.IsSet() {
		localVarFormParams.Add("subtype", parameterToString(localVarOptionals.Subtype.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BladeHostClear.IsSet() {
		localVarFormParams.Add("blade_host_clear", parameterToString(localVarOptionals.BladeHostClear.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VirtualSubtype.IsSet() {
		localVarFormParams.Add("virtual_subtype", parameterToString(localVarOptionals.VirtualSubtype.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Notes.IsSet() {
		localVarFormParams.Add("notes", parameterToString(localVarOptionals.Notes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tags.IsSet() {
		localVarFormParams.Add("tags", parameterToString(localVarOptionals.Tags.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VirtualHostClear.IsSet() {
		localVarFormParams.Add("virtual_host_clear", parameterToString(localVarOptionals.VirtualHostClear.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TagsRemove.IsSet() {
		localVarFormParams.Add("tags_remove", parameterToString(localVarOptionals.TagsRemove.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AliasesRemove.IsSet() {
		localVarFormParams.Add("aliases_remove", parameterToString(localVarOptionals.AliasesRemove.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DevicesInClusterRemove.IsSet() {
		localVarFormParams.Add("devices_in_cluster_remove", parameterToString(localVarOptionals.DevicesInClusterRemove.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectCategory.IsSet() {
		localVarFormParams.Add("object_category", parameterToString(localVarOptionals.ObjectCategory.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NewObjectCategory.IsSet() {
		localVarFormParams.Add("new_object_category", parameterToString(localVarOptionals.NewObjectCategory.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
DevicesApiService Create/Update Multi-Serial Device by Name
This API is used to create a new device with the name supplied as the required argument or update an existing device that with that name. This is similar to /api/api/1.0/devices/ POST call - but you can add duplicate serial numberss and UUID for high density servers that share the same serial # and/or UUID.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DevicesApiPostMultiSerialDeviceOpts - Optional Parameters:
     * @param "Name" (optional.String) -  Device name. If device with name already exists - the existing device is updated. If an existing device based on serial # or uuid are found - name is ignored. In that case existing name is not changed and you can use new_name if you wish to change the name.
     * @param "NewName" (optional.String) -  As mentioned above, this can be used to change the name of an existing device
     * @param "SerialNo" (optional.String) -  the serial # of the device. If a device with matching serial # is found - that device is updated. Serial # with less than 3 characters in length are ignored. Also, certain generic serial #s like 123456789 or ‘not specified’ are ignored.
     * @param "Uuid" (optional.String) -  the uuid of the device. If a device with matching uuid is found - that device is updated.
     * @param "AssetNo" (optional.String) -  the asset # of the device.
     * @param "Manufacturer" (optional.String) -  the hardware manufacturer for the device.
     * @param "Hardware" (optional.String) -  the name of the hardware model for the device. Use in conjunction with the manufacturer argument. However, an update will only occur if no hardware model is previously assigned to the device.
     * @param "NewHardware" (optional.String) -  If you want to change the hardware model for a device. If the device is rack mounted, it will unmount the device before changing hardware model and attempt to mount it back to same rack location (Changed in v6.3.2)
     * @param "IsItSwitch" (optional.String) -  ‘yes’ indicates if device is a network switch
     * @param "IsItVirtualHost" (optional.String) -  ‘yes’ indicates if device is a virtual host
     * @param "IsItBladeHost" (optional.String) -  ‘yes’ indicates if device is a blade host
     * @param "InService" (optional.String) -  ‘yes’ indicates if device is in service, ‘no’ indicates not in service
     * @param "Type_" (optional.String) -  is the type for device. Valid values are ‘physical’, ‘virtual’, ‘blade’, ‘cluster’, or ‘other’.
     * @param "ServiceLevel" (optional.String) -  the service level name for the device. The service level must be pre-defined in the device42 appliance before it can be referenced in an api call.
     * @param "VirtualHost" (optional.String) -  Is the name for the host of the virtual machine. Two conditions must be met for this value to successfully update: 1. The device must be a virtual machine. 2. The virtual host must already exist in the device42 application and must be already marked as a virtual host.
     * @param "BladeHost" (optional.String) -  the name of the host for the blade machine. Two conditions must be met for this value to successfully update: 1. The device must be a blade type. 2. The blade host must already exist and must already be marked as a blade host.
     * @param "SlotNo" (optional.Int32) -  slot # for blade device.
     * @param "StorageRoomId" (optional.Int32) -  ID of the room to assign device to storage room. Added in v5.5.0
     * @param "StorageRoom" (optional.String) -  name of the room to assign device to, only used if the room name is unique. Added in v5.5.0
     * @param "Os" (optional.String) -  the name of the operating system (os, osver, and osverno all required if updating any of the three).
     * @param "Osver" (optional.String) -  the version of the operating system (os, osver, and osverno all required if updating any of the three)
     * @param "Osarch" (optional.String) -  The architecture of the operating system (32 or 64)
     * @param "Osverno" (optional.Int32) -  the version # or build # of the operating system (os, osver, and osverno all required if updating any of the three)
     * @param "Memory" (optional.String) -  the total memory(RAM) in MB. Just numbers.
     * @param "Cpucount" (optional.Int32) -  total # of CPUs. (If updating, cpupower and cpucore required)
     * @param "Cpupower" (optional.String) -  CPU speed in MHz, just numbers. (If updating, cpucount and cpucore required)
     * @param "Cpucore" (optional.String) -  number of cores/CPU. Integer. (If updating, cpupower and cpucount required)
     * @param "Hddcount" (optional.Int32) -  total # of HDD (hddcount, hddsize, hddraid, and hddraid_type all required when updating any of the 4)
     * @param "Hddsize" (optional.String) -  HDD Size in GB (hddcount, hddsize, hddraid, and hddraid_type all required when updating any of the 4)
     * @param "Hddraid" (optional.String) -  Raid. Possible values: software or hardware. none to clear. (none added in v9.1.0) (hddcount, hddsize, hddraid, and hddraid_type all required when updating any of the 4)
     * @param "HddraidType" (optional.String) -  Raid Type. (hddcount, hddsize, hddraid, and hddraid_type all required when updating any of the 4)
     * @param "Macaddress" (optional.String) -  the mac address value. Use multiple POST/PUT to add multiple mac addresses.
     * @param "DevicesInCluster" (optional.String) -  comma separated device names for devices in cluster. Only valid for device type cluster.
     * @param "Appcomps" (optional.String) -  comma separated application component names on this device.
     * @param "Customer" (optional.String) -  name of the customer. Customer record must already exist.
     * @param "ContractId" (optional.Int32) -  ID for the contract. Available via GET /api/api/1.0/contracts/ – DEPRECATED in v550.
     * @param "Contract" (optional.String) -  Name of the contract. Used only if contract name is unique. – DEPRECATED in v550.
     * @param "Aliases" (optional.String) -  optional. Comma separated aliases for the device. Must not exist, ignored otherwise.
     * @param "Subtype" (optional.String) -  Only for device type other. Must exist internally first.
     * @param "BladeHostClear" (optional.String) -  clear blade host for device
     * @param "VirtualSubtype" (optional.String) -  Only for device type virtual. Default is internal VM.
     * @param "Notes" (optional.String) - 
     * @param "Tags" (optional.String) -  comma separated tags (Added in v5.9.2)
     * @param "VirtualHostClear" (optional.String) -  yes to clear virtual host for a VM (added in v9.1.0)
     * @param "TagsRemove" (optional.String) -  comma separated tags to remove (added in v9.1.0)
     * @param "AliasesRemove" (optional.String) -  comma separated aliases to remove
     * @param "DevicesInClusterRemove" (optional.String) -  comma separated device names for removing devices in cluster. Only valid for device type cluster. (added in v9.2.0)
     * @param "ObjectCategory" (optional.String) -  If multitenancy is on, a category can be assigned to control access to this object, e.g. Prod_East specifies that the users with access to the Prod_East category will be able to access this device.
     * @param "NewObjectCategory" (optional.String) -  Used to change category on a device if it is already set.

@return interface{}
*/

type DevicesApiPostMultiSerialDeviceOpts struct { 
	Name optional.String
	NewName optional.String
	SerialNo optional.String
	Uuid optional.String
	AssetNo optional.String
	Manufacturer optional.String
	Hardware optional.String
	NewHardware optional.String
	IsItSwitch optional.String
	IsItVirtualHost optional.String
	IsItBladeHost optional.String
	InService optional.String
	Type_ optional.String
	ServiceLevel optional.String
	VirtualHost optional.String
	BladeHost optional.String
	SlotNo optional.Int32
	StorageRoomId optional.Int32
	StorageRoom optional.String
	Os optional.String
	Osver optional.String
	Osarch optional.String
	Osverno optional.Int32
	Memory optional.String
	Cpucount optional.Int32
	Cpupower optional.String
	Cpucore optional.String
	Hddcount optional.Int32
	Hddsize optional.String
	Hddraid optional.String
	HddraidType optional.String
	Macaddress optional.String
	DevicesInCluster optional.String
	Appcomps optional.String
	Customer optional.String
	ContractId optional.Int32
	Contract optional.String
	Aliases optional.String
	Subtype optional.String
	BladeHostClear optional.String
	VirtualSubtype optional.String
	Notes optional.String
	Tags optional.String
	VirtualHostClear optional.String
	TagsRemove optional.String
	AliasesRemove optional.String
	DevicesInClusterRemove optional.String
	ObjectCategory optional.String
	NewObjectCategory optional.String
}

func (a *DevicesApiService) PostMultiSerialDevice(ctx context.Context, localVarOptionals *DevicesApiPostMultiSerialDeviceOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/multiserial_device/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarFormParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NewName.IsSet() {
		localVarFormParams.Add("new_name", parameterToString(localVarOptionals.NewName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SerialNo.IsSet() {
		localVarFormParams.Add("serial_no", parameterToString(localVarOptionals.SerialNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Uuid.IsSet() {
		localVarFormParams.Add("uuid", parameterToString(localVarOptionals.Uuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AssetNo.IsSet() {
		localVarFormParams.Add("asset_no", parameterToString(localVarOptionals.AssetNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Manufacturer.IsSet() {
		localVarFormParams.Add("manufacturer", parameterToString(localVarOptionals.Manufacturer.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Hardware.IsSet() {
		localVarFormParams.Add("hardware", parameterToString(localVarOptionals.Hardware.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NewHardware.IsSet() {
		localVarFormParams.Add("new_hardware", parameterToString(localVarOptionals.NewHardware.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsItSwitch.IsSet() {
		localVarFormParams.Add("is_it_switch", parameterToString(localVarOptionals.IsItSwitch.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsItVirtualHost.IsSet() {
		localVarFormParams.Add("is_it_virtual_host", parameterToString(localVarOptionals.IsItVirtualHost.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsItBladeHost.IsSet() {
		localVarFormParams.Add("is_it_blade_host", parameterToString(localVarOptionals.IsItBladeHost.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InService.IsSet() {
		localVarFormParams.Add("in_service", parameterToString(localVarOptionals.InService.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarFormParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ServiceLevel.IsSet() {
		localVarFormParams.Add("service_level", parameterToString(localVarOptionals.ServiceLevel.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VirtualHost.IsSet() {
		localVarFormParams.Add("virtual_host", parameterToString(localVarOptionals.VirtualHost.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BladeHost.IsSet() {
		localVarFormParams.Add("blade_host", parameterToString(localVarOptionals.BladeHost.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SlotNo.IsSet() {
		localVarFormParams.Add("slot_no", parameterToString(localVarOptionals.SlotNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StorageRoomId.IsSet() {
		localVarFormParams.Add("storage_room_id", parameterToString(localVarOptionals.StorageRoomId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StorageRoom.IsSet() {
		localVarFormParams.Add("storage_room", parameterToString(localVarOptionals.StorageRoom.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Os.IsSet() {
		localVarFormParams.Add("os", parameterToString(localVarOptionals.Os.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Osver.IsSet() {
		localVarFormParams.Add("osver", parameterToString(localVarOptionals.Osver.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Osarch.IsSet() {
		localVarFormParams.Add("osarch", parameterToString(localVarOptionals.Osarch.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Osverno.IsSet() {
		localVarFormParams.Add("osverno", parameterToString(localVarOptionals.Osverno.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Memory.IsSet() {
		localVarFormParams.Add("memory", parameterToString(localVarOptionals.Memory.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cpucount.IsSet() {
		localVarFormParams.Add("cpucount", parameterToString(localVarOptionals.Cpucount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cpupower.IsSet() {
		localVarFormParams.Add("cpupower", parameterToString(localVarOptionals.Cpupower.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cpucore.IsSet() {
		localVarFormParams.Add("cpucore", parameterToString(localVarOptionals.Cpucore.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Hddcount.IsSet() {
		localVarFormParams.Add("hddcount", parameterToString(localVarOptionals.Hddcount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Hddsize.IsSet() {
		localVarFormParams.Add("hddsize", parameterToString(localVarOptionals.Hddsize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Hddraid.IsSet() {
		localVarFormParams.Add("hddraid", parameterToString(localVarOptionals.Hddraid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HddraidType.IsSet() {
		localVarFormParams.Add("hddraid_type", parameterToString(localVarOptionals.HddraidType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Macaddress.IsSet() {
		localVarFormParams.Add("macaddress", parameterToString(localVarOptionals.Macaddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DevicesInCluster.IsSet() {
		localVarFormParams.Add("devices_in_cluster", parameterToString(localVarOptionals.DevicesInCluster.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Appcomps.IsSet() {
		localVarFormParams.Add("appcomps", parameterToString(localVarOptionals.Appcomps.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Customer.IsSet() {
		localVarFormParams.Add("customer", parameterToString(localVarOptionals.Customer.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ContractId.IsSet() {
		localVarFormParams.Add("contract_id", parameterToString(localVarOptionals.ContractId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Contract.IsSet() {
		localVarFormParams.Add("contract", parameterToString(localVarOptionals.Contract.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Aliases.IsSet() {
		localVarFormParams.Add("aliases", parameterToString(localVarOptionals.Aliases.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Subtype.IsSet() {
		localVarFormParams.Add("subtype", parameterToString(localVarOptionals.Subtype.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BladeHostClear.IsSet() {
		localVarFormParams.Add("blade_host_clear", parameterToString(localVarOptionals.BladeHostClear.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VirtualSubtype.IsSet() {
		localVarFormParams.Add("virtual_subtype", parameterToString(localVarOptionals.VirtualSubtype.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Notes.IsSet() {
		localVarFormParams.Add("notes", parameterToString(localVarOptionals.Notes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tags.IsSet() {
		localVarFormParams.Add("tags", parameterToString(localVarOptionals.Tags.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VirtualHostClear.IsSet() {
		localVarFormParams.Add("virtual_host_clear", parameterToString(localVarOptionals.VirtualHostClear.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TagsRemove.IsSet() {
		localVarFormParams.Add("tags_remove", parameterToString(localVarOptionals.TagsRemove.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AliasesRemove.IsSet() {
		localVarFormParams.Add("aliases_remove", parameterToString(localVarOptionals.AliasesRemove.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DevicesInClusterRemove.IsSet() {
		localVarFormParams.Add("devices_in_cluster_remove", parameterToString(localVarOptionals.DevicesInClusterRemove.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectCategory.IsSet() {
		localVarFormParams.Add("object_category", parameterToString(localVarOptionals.ObjectCategory.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NewObjectCategory.IsSet() {
		localVarFormParams.Add("new_object_category", parameterToString(localVarOptionals.NewObjectCategory.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
DevicesApiService Create/Update Custom Fields for a Device
One of the following parameters is required: name, id, asset, or serial
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param key Can be new or existing. This is the custom field name.
 * @param optional nil or *DevicesApiPutCustomFieldOpts - Optional Parameters:
     * @param "Name" (optional.String) -  name of the device, or
     * @param "Id" (optional.Int32) -  ID of the device
     * @param "Asset" (optional.String) -  if there is more than 1 device with the same asset #, this will return “device not found”, or
     * @param "Serial" (optional.String) -  if there is more than 1 device with the same serial #, this will return “device not found”
     * @param "Type_" (optional.String) -  this is the custom field type. If left blank, default is text. Date should be formatted as YYYY-MM-DD
     * @param "RelatedFieldName" (optional.String) -  Required if type &#x3D; related_field. The existing field to relate this custom field to. Can be: appcomp (for application components), asset, building, certificate, circuit, cusotmer, device, endusers, hardware (for device hardware models), ip_address, natip, netport (for ports), os, part, partmodel, password, pdu (for power units), pdu_model (for power unit models), ports, purchase, purchaselineitem (for a line item on a purchase order), rack, room, software, vlan (for subnets), switch_vlan (for vlans), vrfgroup
     * @param "AddToPicklist" (optional.String) -  Comma separated values to add to picklist. If type is picklist and custom field is new, this is a required field. Duplicates will be ignored.
     * @param "Value" (optional.String) -  This will set the value of the custom field.
     * @param "ClearValue" (optional.String) -  yes to clear existing value for that field
     * @param "Notes" (optional.String) -  Any additional notes.
     * @param "ClearNotes" (optional.String) -  Yes to clear any existing notes.
     * @param "BulkFields" (optional.String) -  comma separated key value pairs, with key and value separated by colon. e.g.key1:value1, key2:value2 (added in v6.4.1)

@return interface{}
*/

type DevicesApiPutCustomFieldOpts struct { 
	Name optional.String
	Id optional.Int32
	Asset optional.String
	Serial optional.String
	Type_ optional.String
	RelatedFieldName optional.String
	AddToPicklist optional.String
	Value optional.String
	ClearValue optional.String
	Notes optional.String
	ClearNotes optional.String
	BulkFields optional.String
}

func (a *DevicesApiService) PutCustomField(ctx context.Context, key string, localVarOptionals *DevicesApiPutCustomFieldOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/device/custom_field/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarFormParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarFormParams.Add("id", parameterToString(localVarOptionals.Id.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Asset.IsSet() {
		localVarFormParams.Add("asset", parameterToString(localVarOptionals.Asset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Serial.IsSet() {
		localVarFormParams.Add("serial", parameterToString(localVarOptionals.Serial.Value(), ""))
	}
	localVarFormParams.Add("key", parameterToString(key, ""))
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarFormParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RelatedFieldName.IsSet() {
		localVarFormParams.Add("related_field_name", parameterToString(localVarOptionals.RelatedFieldName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AddToPicklist.IsSet() {
		localVarFormParams.Add("add_to_picklist", parameterToString(localVarOptionals.AddToPicklist.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Value.IsSet() {
		localVarFormParams.Add("value", parameterToString(localVarOptionals.Value.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ClearValue.IsSet() {
		localVarFormParams.Add("clear_value", parameterToString(localVarOptionals.ClearValue.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Notes.IsSet() {
		localVarFormParams.Add("notes", parameterToString(localVarOptionals.Notes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ClearNotes.IsSet() {
		localVarFormParams.Add("clear_notes", parameterToString(localVarOptionals.ClearNotes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BulkFields.IsSet() {
		localVarFormParams.Add("bulk_fields", parameterToString(localVarOptionals.BulkFields.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
DevicesApiService Update an existing device by name, serial, ID or asset number.
Update Device by Name, ID, Serial or Asset. Requires one of the following parameters: name, serial, asset, device_id
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DevicesApiPutDeviceOpts - Optional Parameters:
     * @param "Name" (optional.String) -  Updates the device found with that name. Otherwise returns “device not found\&quot;
     * @param "Serial" (optional.String) -  If the serial number is provided, it must be a unique serial number or a “device not found” error will result. If it is a unique serial number, then the device that has that serial number will be updated.
     * @param "Asset" (optional.String) -  If the asset number is provided, it must be a unique asset number or a “device not found” error will result. If it is a unique asset number, then the device that has that asset number will be updated.
     * @param "DeviceId" (optional.String) -  update the device by Device42 ID
     * @param "NewName" (optional.String) -  As mentioned above, this can be used to change the name of an existing device
     * @param "SerialNo" (optional.String) -  the serial # of the device. If a device with matching serial # is found - that device is updated. Serial # with less than 3 characters in length are ignored. Also, certain generic serial #s like 123456789 or ‘not specified’ are ignored.
     * @param "Uuid" (optional.String) -  the uuid of the device. If a device with matching uuid is found - that device is updated.
     * @param "AssetNo" (optional.String) -  the asset # of the device.
     * @param "Manufacturer" (optional.String) -  the hardware manufacturer for the device.
     * @param "Hardware" (optional.String) -  the name of the hardware model for the device. Use in conjunction with the manufacturer argument. However, an update will only occur if no hardware model is previously assigned to the device.
     * @param "NewHardware" (optional.String) -  If you want to change the hardware model for a device. If the device is rack mounted, it will unmount the device before changing hardware model and attempt to mount it back to same rack location (Changed in v6.3.2)
     * @param "IsItSwitch" (optional.String) -  ‘yes’ indicates if device is a network switch
     * @param "IsItVirtualHost" (optional.String) -  ‘yes’ indicates if device is a virtual host
     * @param "IsItBladeHost" (optional.String) -  ‘yes’ indicates if device is a blade host
     * @param "InService" (optional.String) -  ‘yes’ indicates if device is in service, ‘no’ indicates not in service
     * @param "Type_" (optional.String) -  type of the device
     * @param "ServiceLevel" (optional.String) -  the service level name for the device. The service level must be pre-defined in the device42 appliance before it can be referenced in an api call.
     * @param "VirtualHost" (optional.String) -  Is the name for the host of the virtual machine. Two conditions must be met for this value to successfully update: 1. The device must be a virtual machine. 2. The virtual host must already exist in the device42 application and must be already marked as a virtual host.
     * @param "BladeHost" (optional.String) -  the name of the host for the blade machine. Two conditions must be met for this value to successfully update: 1. The device must be a blade type. 2. The blade host must already exist and must already be marked as a blade host.
     * @param "SlotNo" (optional.Int32) -  slot # for blade device.
     * @param "StorageRoomId" (optional.Int32) -  ID of the room to assign device to storage room. Added in v5.5.0
     * @param "StorageRoom" (optional.String) -  name of the room to assign device to, only used if the room name is unique. Added in v5.5.0
     * @param "Os" (optional.String) -  the name of the operating system (os, osver, and osverno all required if updating any of the three).
     * @param "Osver" (optional.String) -  the version of the operating system (os, osver, and osverno all required if updating any of the three)
     * @param "Osarch" (optional.String) -  The architecture of the operating system (32 or 64)
     * @param "Osverno" (optional.Int32) -  the version # or build # of the operating system (os, osver, and osverno all required if updating any of the three)
     * @param "Memory" (optional.String) -  the total memory(RAM) in MB. Just numbers.
     * @param "Cpucount" (optional.Int32) -  total # of CPUs. (If updating, cpupower and cpucore required)
     * @param "Cpupower" (optional.String) -  CPU speed in MHz, just numbers. (If updating, cpucount and cpucore required)
     * @param "Cpucore" (optional.String) -  number of cores/CPU. Integer. (If updating, cpupower and cpucount required)
     * @param "Hddcount" (optional.Int32) -  total # of HDD (hddcount, hddsize, hddraid, and hddraid_type all required when updating any of the 4)
     * @param "Hddsize" (optional.String) -  HDD Size in GB (hddcount, hddsize, hddraid, and hddraid_type all required when updating any of the 4)
     * @param "Hddraid" (optional.String) -  Raid. Possible values: software or hardware. none to clear. (none added in v9.1.0) (hddcount, hddsize, hddraid, and hddraid_type all required when updating any of the 4)
     * @param "HddraidType" (optional.String) -  Raid Type. (hddcount, hddsize, hddraid, and hddraid_type all required when updating any of the 4)
     * @param "Macaddress" (optional.String) -  the mac address value. Use multiple POST/PUT to add multiple mac addresses.
     * @param "DevicesInCluster" (optional.String) -  comma separated device names for devices in cluster. Only valid for device type cluster.
     * @param "Appcomps" (optional.String) -  comma separated application component names on this device.
     * @param "Customer" (optional.String) -  name of the customer. Customer record must already exist.
     * @param "ContractId" (optional.Int32) -  ID for the contract. Available via GET /api/api/1.0/contracts/ – DEPRECATED in v550.
     * @param "Contract" (optional.String) -  Name of the contract. Used only if contract name is unique. – DEPRECATED in v550.
     * @param "Aliases" (optional.String) -  optional. Comma separated aliases for the device. Must not exist, ignored otherwise.
     * @param "Subtype" (optional.String) -  Only for device type other. Must exist internally first.
     * @param "BladeHostClear" (optional.String) -  clear blade host for device
     * @param "VirtualSubtype" (optional.String) -  Only for device type virtual. Default is internal VM.
     * @param "Notes" (optional.String) - 
     * @param "Tags" (optional.String) -  comma separated tags (Added in v5.9.2)
     * @param "VirtualHostClear" (optional.String) -  yes to clear virtual host for a VM (added in v9.1.0)
     * @param "TagsRemove" (optional.String) -  comma separated tags to remove (added in v9.1.0)
     * @param "AliasesRemove" (optional.String) -  comma separated aliases to remove
     * @param "DevicesInClusterRemove" (optional.String) -  comma separated device names for removing devices in cluster. Only valid for device type cluster. (added in v9.2.0)
     * @param "ObjectCategory" (optional.String) -  If multitenancy is on, a category can be assigned to control access to this object, e.g. Prod_East specifies that the users with access to the Prod_East category will be able to access this device.
     * @param "NewObjectCategory" (optional.String) -  Used to change category on a device if it is already set.

@return interface{}
*/

type DevicesApiPutDeviceOpts struct { 
	Name optional.String
	Serial optional.String
	Asset optional.String
	DeviceId optional.String
	NewName optional.String
	SerialNo optional.String
	Uuid optional.String
	AssetNo optional.String
	Manufacturer optional.String
	Hardware optional.String
	NewHardware optional.String
	IsItSwitch optional.String
	IsItVirtualHost optional.String
	IsItBladeHost optional.String
	InService optional.String
	Type_ optional.String
	ServiceLevel optional.String
	VirtualHost optional.String
	BladeHost optional.String
	SlotNo optional.Int32
	StorageRoomId optional.Int32
	StorageRoom optional.String
	Os optional.String
	Osver optional.String
	Osarch optional.String
	Osverno optional.Int32
	Memory optional.String
	Cpucount optional.Int32
	Cpupower optional.String
	Cpucore optional.String
	Hddcount optional.Int32
	Hddsize optional.String
	Hddraid optional.String
	HddraidType optional.String
	Macaddress optional.String
	DevicesInCluster optional.String
	Appcomps optional.String
	Customer optional.String
	ContractId optional.Int32
	Contract optional.String
	Aliases optional.String
	Subtype optional.String
	BladeHostClear optional.String
	VirtualSubtype optional.String
	Notes optional.String
	Tags optional.String
	VirtualHostClear optional.String
	TagsRemove optional.String
	AliasesRemove optional.String
	DevicesInClusterRemove optional.String
	ObjectCategory optional.String
	NewObjectCategory optional.String
}

func (a *DevicesApiService) PutDevice(ctx context.Context, localVarOptionals *DevicesApiPutDeviceOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/device/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarFormParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Serial.IsSet() {
		localVarFormParams.Add("serial", parameterToString(localVarOptionals.Serial.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Asset.IsSet() {
		localVarFormParams.Add("asset", parameterToString(localVarOptionals.Asset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceId.IsSet() {
		localVarFormParams.Add("device_id", parameterToString(localVarOptionals.DeviceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NewName.IsSet() {
		localVarFormParams.Add("new_name", parameterToString(localVarOptionals.NewName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SerialNo.IsSet() {
		localVarFormParams.Add("serial_no", parameterToString(localVarOptionals.SerialNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Uuid.IsSet() {
		localVarFormParams.Add("uuid", parameterToString(localVarOptionals.Uuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AssetNo.IsSet() {
		localVarFormParams.Add("asset_no", parameterToString(localVarOptionals.AssetNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Manufacturer.IsSet() {
		localVarFormParams.Add("manufacturer", parameterToString(localVarOptionals.Manufacturer.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Hardware.IsSet() {
		localVarFormParams.Add("hardware", parameterToString(localVarOptionals.Hardware.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NewHardware.IsSet() {
		localVarFormParams.Add("new_hardware", parameterToString(localVarOptionals.NewHardware.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsItSwitch.IsSet() {
		localVarFormParams.Add("is_it_switch", parameterToString(localVarOptionals.IsItSwitch.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsItVirtualHost.IsSet() {
		localVarFormParams.Add("is_it_virtual_host", parameterToString(localVarOptionals.IsItVirtualHost.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsItBladeHost.IsSet() {
		localVarFormParams.Add("is_it_blade_host", parameterToString(localVarOptionals.IsItBladeHost.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InService.IsSet() {
		localVarFormParams.Add("in_service", parameterToString(localVarOptionals.InService.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarFormParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ServiceLevel.IsSet() {
		localVarFormParams.Add("service_level", parameterToString(localVarOptionals.ServiceLevel.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VirtualHost.IsSet() {
		localVarFormParams.Add("virtual_host", parameterToString(localVarOptionals.VirtualHost.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BladeHost.IsSet() {
		localVarFormParams.Add("blade_host", parameterToString(localVarOptionals.BladeHost.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SlotNo.IsSet() {
		localVarFormParams.Add("slot_no", parameterToString(localVarOptionals.SlotNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StorageRoomId.IsSet() {
		localVarFormParams.Add("storage_room_id", parameterToString(localVarOptionals.StorageRoomId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StorageRoom.IsSet() {
		localVarFormParams.Add("storage_room", parameterToString(localVarOptionals.StorageRoom.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Os.IsSet() {
		localVarFormParams.Add("os", parameterToString(localVarOptionals.Os.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Osver.IsSet() {
		localVarFormParams.Add("osver", parameterToString(localVarOptionals.Osver.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Osarch.IsSet() {
		localVarFormParams.Add("osarch", parameterToString(localVarOptionals.Osarch.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Osverno.IsSet() {
		localVarFormParams.Add("osverno", parameterToString(localVarOptionals.Osverno.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Memory.IsSet() {
		localVarFormParams.Add("memory", parameterToString(localVarOptionals.Memory.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cpucount.IsSet() {
		localVarFormParams.Add("cpucount", parameterToString(localVarOptionals.Cpucount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cpupower.IsSet() {
		localVarFormParams.Add("cpupower", parameterToString(localVarOptionals.Cpupower.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cpucore.IsSet() {
		localVarFormParams.Add("cpucore", parameterToString(localVarOptionals.Cpucore.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Hddcount.IsSet() {
		localVarFormParams.Add("hddcount", parameterToString(localVarOptionals.Hddcount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Hddsize.IsSet() {
		localVarFormParams.Add("hddsize", parameterToString(localVarOptionals.Hddsize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Hddraid.IsSet() {
		localVarFormParams.Add("hddraid", parameterToString(localVarOptionals.Hddraid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HddraidType.IsSet() {
		localVarFormParams.Add("hddraid_type", parameterToString(localVarOptionals.HddraidType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Macaddress.IsSet() {
		localVarFormParams.Add("macaddress", parameterToString(localVarOptionals.Macaddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DevicesInCluster.IsSet() {
		localVarFormParams.Add("devices_in_cluster", parameterToString(localVarOptionals.DevicesInCluster.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Appcomps.IsSet() {
		localVarFormParams.Add("appcomps", parameterToString(localVarOptionals.Appcomps.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Customer.IsSet() {
		localVarFormParams.Add("customer", parameterToString(localVarOptionals.Customer.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ContractId.IsSet() {
		localVarFormParams.Add("contract_id", parameterToString(localVarOptionals.ContractId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Contract.IsSet() {
		localVarFormParams.Add("contract", parameterToString(localVarOptionals.Contract.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Aliases.IsSet() {
		localVarFormParams.Add("aliases", parameterToString(localVarOptionals.Aliases.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Subtype.IsSet() {
		localVarFormParams.Add("subtype", parameterToString(localVarOptionals.Subtype.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BladeHostClear.IsSet() {
		localVarFormParams.Add("blade_host_clear", parameterToString(localVarOptionals.BladeHostClear.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VirtualSubtype.IsSet() {
		localVarFormParams.Add("virtual_subtype", parameterToString(localVarOptionals.VirtualSubtype.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Notes.IsSet() {
		localVarFormParams.Add("notes", parameterToString(localVarOptionals.Notes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tags.IsSet() {
		localVarFormParams.Add("tags", parameterToString(localVarOptionals.Tags.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VirtualHostClear.IsSet() {
		localVarFormParams.Add("virtual_host_clear", parameterToString(localVarOptionals.VirtualHostClear.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TagsRemove.IsSet() {
		localVarFormParams.Add("tags_remove", parameterToString(localVarOptionals.TagsRemove.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AliasesRemove.IsSet() {
		localVarFormParams.Add("aliases_remove", parameterToString(localVarOptionals.AliasesRemove.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DevicesInClusterRemove.IsSet() {
		localVarFormParams.Add("devices_in_cluster_remove", parameterToString(localVarOptionals.DevicesInClusterRemove.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectCategory.IsSet() {
		localVarFormParams.Add("object_category", parameterToString(localVarOptionals.ObjectCategory.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NewObjectCategory.IsSet() {
		localVarFormParams.Add("new_object_category", parameterToString(localVarOptionals.NewObjectCategory.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
DevicesApiService Update Device URL
Use this API to update and existing url (e.g. an http, https, or telnet url) with a device. Type and device are required if no ID is provided.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *DevicesApiPutDeviceUrlOpts - Optional Parameters:
     * @param "Id" (optional.String) -  ID of the URL
     * @param "Type_" (optional.String) -  the url type (e.g. http, https, telnet). This must be an existing url type in device42. (required if no ID)
     * @param "Device" (optional.String) -  name of the device to which this url belongs (required if no ID)
     * @param "Host" (optional.String) -  fqdn portion of the url. e.g. for https://example.com/awesome, host is example.com
     * @param "Port" (optional.String) -  port number if any
     * @param "UrlSuffix" (optional.String) -  url suffix if any. e.g. it is “awesome” based on example given above.
     * @param "Notes" (optional.String) - 

@return interface{}
*/

type DevicesApiPutDeviceUrlOpts struct { 
	Id optional.String
	Type_ optional.String
	Device optional.String
	Host optional.String
	Port optional.String
	UrlSuffix optional.String
	Notes optional.String
}

func (a *DevicesApiService) PutDeviceUrl(ctx context.Context, localVarOptionals *DevicesApiPutDeviceUrlOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/device/url/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarFormParams.Add("id", parameterToString(localVarOptionals.Id.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarFormParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Device.IsSet() {
		localVarFormParams.Add("device", parameterToString(localVarOptionals.Device.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Host.IsSet() {
		localVarFormParams.Add("host", parameterToString(localVarOptionals.Host.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Port.IsSet() {
		localVarFormParams.Add("port", parameterToString(localVarOptionals.Port.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UrlSuffix.IsSet() {
		localVarFormParams.Add("url_suffix", parameterToString(localVarOptionals.UrlSuffix.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Notes.IsSet() {
		localVarFormParams.Add("notes", parameterToString(localVarOptionals.Notes.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
DevicesApiService Upload and attach a file to a Device by Device Id.
Uploads a file attachment for a specific device using device id and a selected file.&lt;br&gt; Note that this implementation of Swagger does not support file upload - use another mechanism such as cULR.&lt;br&gt; &lt;br&gt;cURL example:&lt;br&gt; curl -X POST \\&lt;br&gt; URL/api/1.0/devices/id/3/attachments/17 \\&lt;br&gt; -H &#39;Accept-Encoding: gzip, deflate&#39; \\&lt;br&gt; -H &#39;Authorization: Basic YWRtaW46YWRtIW5kNDI&#x3D;&#39;&lt;br&gt; -H &#39;Content-Type: multipart/form-data; boundary&#x3D;--------------------------216746989913126372322897&#39; \\&lt;br&gt; -H &#39;content-type: multipart/form-data; boundary&#x3D;----WebKitFormBoundary7MA4YWxkTrZu0gW&#39; \\&lt;br&gt; -F &#39;some test pdf.pdf&#x3D;@/C:/path/to/attachment/Some test pdf.pdf&#39; \\&lt;br&gt; -F &#39;file_attachment_details&#x3D;{\&quot;some test pdf.pdf\&quot;:\&quot;hello world! I&#39;\\&#39;&#39;m a pdf description!\&quot;}&#39;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param deviceId
 * @param name The name of the file attachment you select for upload.&lt;br&gt; This filename is also required for the file_attachment_details parameter.
 * @param fileAttachmentDetails The name of the file to upload and a description.&lt;br&gt;Example: {\&quot;TEST_Attachment-3.txt\&quot;: \&quot;test attachment-3\&quot;} 

@return interface{}
*/
func (a *DevicesApiService) UploadDevicesAttachments(ctx context.Context, deviceId int32, name string, fileAttachmentDetails string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/devices/id/{device-id}/attachments/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("device-id", parameterToString(deviceId, ""))
	localVarFormParams.Add("name", parameterToString(name, ""))
	localVarFormParams.Add("file_attachment_details", parameterToString(fileAttachmentDetails, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
