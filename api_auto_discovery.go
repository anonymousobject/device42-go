
/*
 * Device42 API
 *
 * <b><h2>API Overview</h2></b><br>Restful API are supported in Device42 as one of the primary methods of entering, editing and retrieving data.<br><br> The API documentation has samples in curl for now and we will be adding other programming languages in future. You can refer to our github repositories at https://github.com/device42 for some sample code in python.<br><br> The RESTful API's enforce the role-based security that is created with the Device42 app. If you want a user to have access via the API, but not via the UI - deselect 'Staff Status' for that user from UI Tools > Admins & Permissions > Administrators.<br><br>If you'd like to see your changes on our UI, please visit http://swaggerdemo.device42.com and use credentials 'guest:device42_rocks!'. Please be aware that every 30 minutes our database resets and all data entered with POST/PUT calls from this page will be lost.<br><br>If you have any questions/suggestions, please send us a note to support at device42.com below. <br><h2><a id = 'Sample_API_Code'><b>Sample API Code</b></a></h2> <b>Sample Code with API Calls in the Python and .Net Programming Languages.</b><br>The following programs written in the Python programming language are available at <a href= 'https://github.com/device42/Device42-AutoDiscovery-Scripts'>Device42 sample programs</a><br><ul><li>api-sample.py: Runs against a single Windows system and uploads info to device42 appliance.</li><li>ad-sample.py: Can run against Active directory computers, servers or a given list and upload discovered systems’ info to device42 appliance.</li><li>d42_api_linux_upload_sample_script.py: Runs on a single *nix based system and uploads info to device42 appliance.</li><li>sample-script-facter-facts-to-d42: Runs on puppet master and uploads nodes info from facter fact files to device42 appliance.</li><li>d42_api_solaris_sample_script.py: Runs on an individual solaris system and uploads info to device42 appliance.</li></ul>The csv2d42apis.py sample program shows how to create a CSV file of data to import into device42. It reads a CSV file, matches columns to arguments for APIs and sends data to device42 via POST or PUT. This program can be found at: <a href= 'https://github.com/device42/API_Helpers'> Device42 sample CSV importer</a>.<br><br>The Auto Discovery Client source code can be found at Device42 <a href='https://docs.device42.com/auto-discovery/'>Auto Discovery Client</a>. This is a .net program that uses the device42 Restful API’s to load the discovered data.<h2><a id = 'Response_Status_Messages'><b>Response & Status Messages</b></a></h2><b>Responses</b><br>The response to most POST calls will have the following format: <br>{'msg':['PartModel added/updated', 17, 'RAM Acme 123456', true, true], 'code':0}<br><br>Using the example above:<br>'17' = ID of the object<br>'RAM Acme 123456' = representation of the object<br> 'true, true' = object added and is new.<br>'true, false' = object updated.<br>'false, false' = no changes.<br><br><b>Status Codes</b><br><u>Code 0</u><br>Success! e.g. = {'msg': 'device added or updated', <b>code:0</b>}<br><br><u>'HTTP/1.1 200 OK'</u><br>Success! All other responses are errors and will display an error code e.g.: 400, 401, 403, 405, 410, 500, 503. These are explained in each call.<br><br>Please let us know if you notice something odd with a response and we will fix it! :) <h2><a id = 'Get_Limits_Offsets'><b>API Get Limits and Offsets</b></a></h2>In Device42’s global settings we have the option to enforce API GET limits and this setting is recommended for better performance. To set this value from Device42, go to Tools>Settings>Global Settings and the click Edit in the top right. Toward the bottom of the screen you will see the API section. First check the “Enforce API GET Limits” checkbox, then enter a value for API GET Limit. A good limit to start with is 500 or 1000, depending on the performance you experience.<br><br>After setting this limit all GET calls below can have the results augmented via “offset” and “limit” parameters to tell Device42 which value to start returning results from, and how many results to return at maximum.<br>Examples:<br><br>'/?limit=50' returns the first 50 results.<br><br> '/?offset=100' will start at the 101st result. <br><br>'/?offset=42&limit=42' returns 42 results, starting at the 43rd.<br><br> Note that offset is used for paging - that is, the offset is only applied when the total number of objects returned exceeds the limit that is returned.
 *
 * API version: 2.0
 * Contact: support@device42.com
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package swagger

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type AutoDiscoveryApiService service

/* 
AutoDiscoveryApiService Retrieves all auto-discovery jobs for dns.
Get Certificate Auto Discovery Jobs
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

@return interface{}
*/
func (a *AutoDiscoveryApiService) GetAutoDiscoveryCertificate(ctx context.Context) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/auto_discovery/certificate/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
AutoDiscoveryApiService Retrieves all cloud auto-discovery jobs.
Get all cloud discovery jobs
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

@return interface{}
*/
func (a *AutoDiscoveryApiService) GetAutoDiscoveryCloudaccount(ctx context.Context) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/auto_discovery/cloudaccount/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
AutoDiscoveryApiService Retrieves all auto-discovery jobs for dns.
Get DNS Auto Discovery Jobs
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

@return interface{}
*/
func (a *AutoDiscoveryApiService) GetAutoDiscoveryDns(ctx context.Context) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/auto_discovery/dns/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
AutoDiscoveryApiService Retrieves all IPMI/Redfish auto-discovery jobs.
Get all IPMI/Redfish auto-discovery jobs
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

@return interface{}
*/
func (a *AutoDiscoveryApiService) GetAutoDiscoveryIpmi(ctx context.Context) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/auto_discovery/ipmi/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
AutoDiscoveryApiService Retrieves all auto-discovery jobs for networking devices.
Get Network Jobs
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

@return interface{}
*/
func (a *AutoDiscoveryApiService) GetAutoDiscoveryNetworks(ctx context.Context) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/auto_discovery/networks/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
AutoDiscoveryApiService Retrieves all auto-discovery pingsweep jobs.
Get Pingsweep Jobs
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

@return interface{}
*/
func (a *AutoDiscoveryApiService) GetAutoDiscoveryPingsweep(ctx context.Context) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/auto_discovery/pingsweep/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
AutoDiscoveryApiService Retrieves all SNMP auto-discovery jobs.
Get all SNMP discovery jobs
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

@return interface{}
*/
func (a *AutoDiscoveryApiService) GetAutoDiscoverySnmpDisc(ctx context.Context) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/auto_discovery/snmp_disc/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
AutoDiscoveryApiService Retrieves all UCS/ACI/Load Balancer auto-discovery jobs.
Get all UCS/ACI/Load Balancer auto-discovery jobs
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

@return interface{}
*/
func (a *AutoDiscoveryApiService) GetAutoDiscoveryUcs(ctx context.Context) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/auto_discovery/ucs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
AutoDiscoveryApiService Retrieves all auto-discovery Nmap jobs.
Get Nmap Jobs
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

@return interface{}
*/
func (a *AutoDiscoveryApiService) GetAutoDiscoverynmap(ctx context.Context) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/auto_discovery/nmap/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
AutoDiscoveryApiService Retrieves all vServer auto-discovery jobs.
Get all vServer Jobs
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

@return interface{}
*/
func (a *AutoDiscoveryApiService) GetAutoDiscoveryvServer(ctx context.Context) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/auto_discovery/vserver/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
AutoDiscoveryApiService Add or update blade autodiscovery job
Add or update blade autodiscovery job
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name name of the job
 * @param optional nil or *AutoDiscoveryApiPostAutoDiscoveryBladeDiscOpts - Optional Parameters:
     * @param "Ipaddress" (optional.String) -  IP address. Required if new
     * @param "EndIpAddress" (optional.String) -  End IP address
     * @param "SnmpString" (optional.String) -  required, if new
     * @param "ScheduleTime" (optional.String) -  Time in HH:MM format if you want to schedule the job. Note: Must be formatted as text NOT date. For multiple schedules, separate with a slash (/).
     * @param "ScheduleDays" (optional.String) -  Comma separated days of week, where Monday &#x3D; 0. e.g. 0,1,2 wil set the job for Mon, Tue and Wed. For multiple schedules, separate with a slash (/).
     * @param "StripDomainName" (optional.String) - 
     * @param "ClearExistingSchedule" (optional.String) - 
     * @param "Groups" (optional.String) -  name of one or more groups separated by commas
     * @param "SnmpPort" (optional.Int32) -  snmp port (integer only) (added in v10.4.0)
     * @param "SnmpVersion" (optional.String) - 
     * @param "Snmpv3User" (optional.String) -  name of snmp v3 user (added in v10.4.0)
     * @param "Snmpv3AuthMode" (optional.String) - 
     * @param "Snmpv3AuthProtocol" (optional.String) - 
     * @param "Snmpv3AuthPassword" (optional.String) -  password (added in v10.4.0)
     * @param "Snmpv3PrivacyProtocol" (optional.String) - 
     * @param "Snmpv3PrivacyProtocolPassword" (optional.String) -  password (added in v10.4.0)
     * @param "Snmpv3Context" (optional.String) - 
     * @param "DebugLevel" (optional.String) - 
     * @param "HostnamePrecedence" (optional.String) - 
     * @param "ServiceLevel" (optional.String) -  Must already exist
     * @param "NameToUseForNewlyDiscoveredModule" (optional.String) -  name to use
     * @param "ToggleInServiceOnModulePowerState" (optional.String) -  yes or no
     * @param "ModuleNotFound" (optional.String) -  action to take on module not found. One of: Remove Host Association, Change Service Level, Delete Module (default is no action)

@return interface{}
*/

type AutoDiscoveryApiPostAutoDiscoveryBladeDiscOpts struct { 
	Ipaddress optional.String
	EndIpAddress optional.String
	SnmpString optional.String
	ScheduleTime optional.String
	ScheduleDays optional.String
	StripDomainName optional.String
	ClearExistingSchedule optional.String
	Groups optional.String
	SnmpPort optional.Int32
	SnmpVersion optional.String
	Snmpv3User optional.String
	Snmpv3AuthMode optional.String
	Snmpv3AuthProtocol optional.String
	Snmpv3AuthPassword optional.String
	Snmpv3PrivacyProtocol optional.String
	Snmpv3PrivacyProtocolPassword optional.String
	Snmpv3Context optional.String
	DebugLevel optional.String
	HostnamePrecedence optional.String
	ServiceLevel optional.String
	NameToUseForNewlyDiscoveredModule optional.String
	ToggleInServiceOnModulePowerState optional.String
	ModuleNotFound optional.String
}

func (a *AutoDiscoveryApiService) PostAutoDiscoveryBladeDisc(ctx context.Context, name string, localVarOptionals *AutoDiscoveryApiPostAutoDiscoveryBladeDiscOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/auto_discovery/blade_disc/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("name", parameterToString(name, ""))
	if localVarOptionals != nil && localVarOptionals.Ipaddress.IsSet() {
		localVarFormParams.Add("ipaddress", parameterToString(localVarOptionals.Ipaddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EndIpAddress.IsSet() {
		localVarFormParams.Add("end_ip_address", parameterToString(localVarOptionals.EndIpAddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SnmpString.IsSet() {
		localVarFormParams.Add("snmp_string", parameterToString(localVarOptionals.SnmpString.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScheduleTime.IsSet() {
		localVarFormParams.Add("schedule_time", parameterToString(localVarOptionals.ScheduleTime.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScheduleDays.IsSet() {
		localVarFormParams.Add("schedule_days", parameterToString(localVarOptionals.ScheduleDays.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StripDomainName.IsSet() {
		localVarFormParams.Add("strip_domain_name", parameterToString(localVarOptionals.StripDomainName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ClearExistingSchedule.IsSet() {
		localVarFormParams.Add("clear_existing_schedule", parameterToString(localVarOptionals.ClearExistingSchedule.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Groups.IsSet() {
		localVarFormParams.Add("groups", parameterToString(localVarOptionals.Groups.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SnmpPort.IsSet() {
		localVarFormParams.Add("snmp_port", parameterToString(localVarOptionals.SnmpPort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SnmpVersion.IsSet() {
		localVarFormParams.Add("snmp_version", parameterToString(localVarOptionals.SnmpVersion.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Snmpv3User.IsSet() {
		localVarFormParams.Add("snmpv3_user", parameterToString(localVarOptionals.Snmpv3User.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Snmpv3AuthMode.IsSet() {
		localVarFormParams.Add("snmpv3_auth_mode", parameterToString(localVarOptionals.Snmpv3AuthMode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Snmpv3AuthProtocol.IsSet() {
		localVarFormParams.Add("snmpv3_auth_protocol", parameterToString(localVarOptionals.Snmpv3AuthProtocol.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Snmpv3AuthPassword.IsSet() {
		localVarFormParams.Add("snmpv3_auth_password", parameterToString(localVarOptionals.Snmpv3AuthPassword.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Snmpv3PrivacyProtocol.IsSet() {
		localVarFormParams.Add("snmpv3_privacy_protocol", parameterToString(localVarOptionals.Snmpv3PrivacyProtocol.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Snmpv3PrivacyProtocolPassword.IsSet() {
		localVarFormParams.Add("snmpv3_privacy_protocol_password", parameterToString(localVarOptionals.Snmpv3PrivacyProtocolPassword.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Snmpv3Context.IsSet() {
		localVarFormParams.Add("snmpv3_context", parameterToString(localVarOptionals.Snmpv3Context.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DebugLevel.IsSet() {
		localVarFormParams.Add("debug_level", parameterToString(localVarOptionals.DebugLevel.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HostnamePrecedence.IsSet() {
		localVarFormParams.Add("hostname_precedence", parameterToString(localVarOptionals.HostnamePrecedence.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ServiceLevel.IsSet() {
		localVarFormParams.Add("service_level", parameterToString(localVarOptionals.ServiceLevel.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameToUseForNewlyDiscoveredModule.IsSet() {
		localVarFormParams.Add("name_to_use_for_newly_discovered_module", parameterToString(localVarOptionals.NameToUseForNewlyDiscoveredModule.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ToggleInServiceOnModulePowerState.IsSet() {
		localVarFormParams.Add("toggle_in_service_on_module_power_state", parameterToString(localVarOptionals.ToggleInServiceOnModulePowerState.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ModuleNotFound.IsSet() {
		localVarFormParams.Add("module_not_found", parameterToString(localVarOptionals.ModuleNotFound.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
AutoDiscoveryApiService Add Certificate Auto Discovery
Add Certificate Auto Discovery job
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name name of the job
 * @param startIpAddress beginning of IP address range
 * @param endIpAddress End IP address
 * @param optional nil or *AutoDiscoveryApiPostAutoDiscoveryCertificateOpts - Optional Parameters:
     * @param "Server" (optional.String) -  IP or FQDN of target server
     * @param "ExcludeServers" (optional.String) -  comma separated liste of addresses to exclude
     * @param "Ports" (optional.String) -  default is 443, comma separated
     * @param "FollowChain" (optional.String) - 
     * @param "DebugLevel" (optional.String) - 
     * @param "ScheduleTime" (optional.String) -  Time in HH:MM format if you want to schedule the job. Note: Must be formatted as text NOT date. For multiple schedules, separate with a slash (/).
     * @param "ScheduleDays" (optional.String) -  Comma separated days of week, where Monday &#x3D; 0. e.g. 0,1,2 wil set the job for Mon, Tue and Wed. For multiple schedules, separate with a slash (/).

@return interface{}
*/

type AutoDiscoveryApiPostAutoDiscoveryCertificateOpts struct { 
	Server optional.String
	ExcludeServers optional.String
	Ports optional.String
	FollowChain optional.String
	DebugLevel optional.String
	ScheduleTime optional.String
	ScheduleDays optional.String
}

func (a *AutoDiscoveryApiService) PostAutoDiscoveryCertificate(ctx context.Context, name string, startIpAddress string, endIpAddress string, localVarOptionals *AutoDiscoveryApiPostAutoDiscoveryCertificateOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/auto_discovery/certificate/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("name", parameterToString(name, ""))
	localVarFormParams.Add("start_ip_address", parameterToString(startIpAddress, ""))
	localVarFormParams.Add("end_ip_address", parameterToString(endIpAddress, ""))
	if localVarOptionals != nil && localVarOptionals.Server.IsSet() {
		localVarFormParams.Add("server", parameterToString(localVarOptionals.Server.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ExcludeServers.IsSet() {
		localVarFormParams.Add("exclude_servers", parameterToString(localVarOptionals.ExcludeServers.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Ports.IsSet() {
		localVarFormParams.Add("ports", parameterToString(localVarOptionals.Ports.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FollowChain.IsSet() {
		localVarFormParams.Add("follow_chain", parameterToString(localVarOptionals.FollowChain.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DebugLevel.IsSet() {
		localVarFormParams.Add("debug_level", parameterToString(localVarOptionals.DebugLevel.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScheduleTime.IsSet() {
		localVarFormParams.Add("schedule_time", parameterToString(localVarOptionals.ScheduleTime.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScheduleDays.IsSet() {
		localVarFormParams.Add("schedule_days", parameterToString(localVarOptionals.ScheduleDays.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
AutoDiscoveryApiService Add or update cloud autodiscovery job
Add or update a cloud autodiscovery job.&lt;br&gt; &lt;p&gt;&lt;b&gt;Required parameters by cloud vendor or job type.&lt;/b&gt;&lt;br&gt;(API parameter &#x3D; UI equivalent)&lt;/i&gt;&lt;p&gt;ALL DISCOVERY JOBS&lt;br&gt;- name &#x3D; Name&lt;br&gt;- cloud_type &#x3D; Cloud Type &lt;p&gt;AMAZON AWS&lt;br&gt;- accountid &#x3D; Access Key ID&lt;br&gt;- secret_key OR secret_key_id &#x3D; Secret Key&lt;br&gt;- regions &#x3D; Regions &lt;p&gt;MICROSOFT AZURE&lt;br&gt;- auth_type &#x3D; Authentication Type&lt;br&gt;- accountid &#x3D; Client ID (Service Principal) or Username (User Credentials)&lt;br&gt;- secret_key OR secret_key_id &#x3D; Client Secret (Service Principal) or Password (User Credentials)&lt;br&gt;- subscriptionid &#x3D; Subscription ID&lt;br&gt;- tenant &#x3D; Tenant ID &lt;p&gt;LINODE&lt;br&gt;- api_key OR api_key_id &#x3D; API Key &lt;p&gt;DIGITALOCEAN&lt;br&gt;- token_key &#x3D; Token Key &lt;p&gt;OPENSTACK&lt;br&gt;- ip &#x3D; URL&lt;br&gt;- username &#x3D; User&lt;br&gt;- secret_key OR secret_key_id &#x3D; Password&lt;br&gt;- tenant &#x3D; Project Name &lt;p&gt;AMAZON API&lt;br&gt;- ip &#x3D; URL&lt;br&gt;- region &#x3D; Region&lt;br&gt;- secret_key OR secret_key_id &#x3D; Secret Key&lt;br&gt; - accountid &#x3D; API Key &lt;p&gt;GOOGLE CLOUD&lt;br&gt;- tenant &#x3D; Project ID&lt;br&gt;- secret_key OR secret_key_id &#x3D; Credentials JSON&lt;br&gt;- google_regions &#x3D; Zones &lt;p&gt;ALIBABA CLOUD&lt;br&gt;- accountid &#x3D; Access Key ID&lt;br&gt;- secret_key OR secret_key_id &#x3D; Access Key Secret &lt;p&gt;ORACLE CLOUD&lt;br&gt;- accountid &#x3D; User ID&lt;br&gt;- api_key OR api_key_id &#x3D; Fingerprint&lt;br&gt;- secret_key OR secret_key_id &#x3D; Key File&lt;br&gt;- tenant &#x3D; Tenant ID&lt;br&gt;- oracle_regions &#x3D; Zones &lt;p&gt;STANDALONE KUBERNETES&lt;br&gt;- ip &#x3D; URL&lt;br&gt;- auth_type &#x3D; Authentication Type&lt;br&gt;- accountid &#x3D; Bearer Token or Basic Credentials (depending on Authentication Type)
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Name of the discovery job; required for all jobs.
 * @param cloudType Required for all jobs.
 * @param optional nil or *AutoDiscoveryApiPostAutoDiscoveryCloudaccountOpts - Optional Parameters:
     * @param "SecretKeyId" (optional.String) -  Amazon AWS, MS Azure, OpenStack, Amazon API, Google Cloud, Alibaba Cloud, Oracle Cloud
     * @param "Vendor" (optional.String) -  The cloud vendor
     * @param "KubernetesDiscovery" (optional.String) -  Available for Amazon AWS, Microsoft Azure, and standalone Kubernetes. &lt;br&gt;Yes / No
     * @param "RemoteCollectorId" (optional.String) -  ID number of the remote collector (RC) to use for the job.
     * @param "CustomerId" (optional.String) -  Customer ID number for discovered devices.
     * @param "DeviceNameFormat" (optional.String) -  Name format for discovered cloud instances (only for Alibaba Cloud, Amazon API, Amazon AWS, Google Cloud, MS Azure, Oracle Cloud).
     * @param "ContainerNotFound" (optional.String) -  For Kubernetes discovery.&lt;br&gt;1 &#x3D; changes status, 2 &#x3D; delete container
     * @param "AuthType" (optional.String) -  Type of authentication credentials for MS Azure and Standalone Kubernetes.
     * @param "Accountid" (optional.String) -  Required for Alibaba Cloud, Amazon AWS, Kubernetes, MS Azure, Oracle Cloud.
     * @param "Vrfgroup" (optional.String) -  name of vrf group for discovered subnets (added in v10.4.0)
     * @param "Notes" (optional.String) -  Any additional notes
     * @param "RemoveUnfoundInstances" (optional.String) - 
     * @param "StripDomainName" (optional.String) - 
     * @param "AddSuffix" (optional.String) - 
     * @param "MatchNameOnlyForVirtuals" (optional.String) - 
     * @param "MatchNameOnlyForHypervisor" (optional.String) - 
     * @param "Groups" (optional.String) -  name of one or more groups separated by commas
     * @param "ObjectCategory" (optional.String) -  category of discovered vservers and vms
     * @param "DebugLevel" (optional.String) - 
     * @param "ClearExistingSchedule" (optional.String) - 
     * @param "ScheduleTime" (optional.String) -  Time in HH:MM format if you want to schedule the job. Note: Must be formatted as text NOT date. For multiple schedules, separate with a slash (/).
     * @param "ScheduleDays" (optional.String) -  Comma separated days of week, where Monday &#x3D; 0. e.g. 0,1,2 wil set the job for Mon, Tue and Wed. For multiple schedules, separate with a slash (/).
     * @param "SecretKey" (optional.String) -  Amazon AWS, MS Azure, OpenStack, Amazon API, Google Cloud, Alibaba Cloud, Oracle Cloud
     * @param "Regions" (optional.String) -  Comma separated region names for Amazon AWS
     * @param "GoogleRegions" (optional.String) -  comma-separated list of Google region names
     * @param "OracleRegions" (optional.String) -  comma-separated list of Oracle region names
     * @param "Subscriptionid" (optional.String) -  MS Azure Subscription ID
     * @param "Ip" (optional.String) -  Amazon API URL; OpenStack URL; Standalone Kubernetes URL
     * @param "Tenant" (optional.String) -  OpenStack Project name; Google Project ID; Oracle Tenant ID
     * @param "Username" (optional.String) -  OpenStack username - required for OpenStack
     * @param "ApiKey" (optional.String) -  Oracle Cloud Fingerprint; Linode API Key
     * @param "ApiKeyId" (optional.String) -  Oracle Cloud Fingerprint; Linode API Key
     * @param "ApiToken" (optional.String) -  Linode API token - Required for Linode
     * @param "TokenKey" (optional.String) -  DigitalOcean Token Key - required for DigitalOcean.
     * @param "Region" (optional.String) -  Required for Amazon AWS API discovery.
     * @param "AlibabaRegions" (optional.String) -  Comma-separated list of Alibaba Cloud region names.


*/

type AutoDiscoveryApiPostAutoDiscoveryCloudaccountOpts struct { 
	SecretKeyId optional.String
	Vendor optional.String
	KubernetesDiscovery optional.String
	RemoteCollectorId optional.String
	CustomerId optional.String
	DeviceNameFormat optional.String
	ContainerNotFound optional.String
	AuthType optional.String
	Accountid optional.String
	Vrfgroup optional.String
	Notes optional.String
	RemoveUnfoundInstances optional.String
	StripDomainName optional.String
	AddSuffix optional.String
	MatchNameOnlyForVirtuals optional.String
	MatchNameOnlyForHypervisor optional.String
	Groups optional.String
	ObjectCategory optional.String
	DebugLevel optional.String
	ClearExistingSchedule optional.String
	ScheduleTime optional.String
	ScheduleDays optional.String
	SecretKey optional.String
	Regions optional.String
	GoogleRegions optional.String
	OracleRegions optional.String
	Subscriptionid optional.String
	Ip optional.String
	Tenant optional.String
	Username optional.String
	ApiKey optional.String
	ApiKeyId optional.String
	ApiToken optional.String
	TokenKey optional.String
	Region optional.String
	AlibabaRegions optional.String
}

func (a *AutoDiscoveryApiService) PostAutoDiscoveryCloudaccount(ctx context.Context, name string, cloudType string, localVarOptionals *AutoDiscoveryApiPostAutoDiscoveryCloudaccountOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/auto_discovery/cloudaccount/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("name", parameterToString(name, ""))
	localVarFormParams.Add("cloud_type", parameterToString(cloudType, ""))
	if localVarOptionals != nil && localVarOptionals.SecretKeyId.IsSet() {
		localVarFormParams.Add("secret_key_id", parameterToString(localVarOptionals.SecretKeyId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Vendor.IsSet() {
		localVarFormParams.Add("vendor", parameterToString(localVarOptionals.Vendor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.KubernetesDiscovery.IsSet() {
		localVarFormParams.Add("kubernetes_discovery", parameterToString(localVarOptionals.KubernetesDiscovery.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RemoteCollectorId.IsSet() {
		localVarFormParams.Add("remote_collector_id", parameterToString(localVarOptionals.RemoteCollectorId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CustomerId.IsSet() {
		localVarFormParams.Add("customer_id", parameterToString(localVarOptionals.CustomerId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceNameFormat.IsSet() {
		localVarFormParams.Add("device_name_format", parameterToString(localVarOptionals.DeviceNameFormat.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ContainerNotFound.IsSet() {
		localVarFormParams.Add("container_not_found", parameterToString(localVarOptionals.ContainerNotFound.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AuthType.IsSet() {
		localVarFormParams.Add("auth_type", parameterToString(localVarOptionals.AuthType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Accountid.IsSet() {
		localVarFormParams.Add("accountid", parameterToString(localVarOptionals.Accountid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Vrfgroup.IsSet() {
		localVarFormParams.Add("vrfgroup", parameterToString(localVarOptionals.Vrfgroup.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Notes.IsSet() {
		localVarFormParams.Add("notes", parameterToString(localVarOptionals.Notes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RemoveUnfoundInstances.IsSet() {
		localVarFormParams.Add("remove_unfound_instances", parameterToString(localVarOptionals.RemoveUnfoundInstances.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StripDomainName.IsSet() {
		localVarFormParams.Add("strip_domain_name", parameterToString(localVarOptionals.StripDomainName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AddSuffix.IsSet() {
		localVarFormParams.Add("add_suffix", parameterToString(localVarOptionals.AddSuffix.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MatchNameOnlyForVirtuals.IsSet() {
		localVarFormParams.Add("match_name_only_for_virtuals", parameterToString(localVarOptionals.MatchNameOnlyForVirtuals.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MatchNameOnlyForHypervisor.IsSet() {
		localVarFormParams.Add("match_name_only_for_hypervisor", parameterToString(localVarOptionals.MatchNameOnlyForHypervisor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Groups.IsSet() {
		localVarFormParams.Add("groups", parameterToString(localVarOptionals.Groups.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectCategory.IsSet() {
		localVarFormParams.Add("object_category", parameterToString(localVarOptionals.ObjectCategory.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DebugLevel.IsSet() {
		localVarFormParams.Add("debug_level", parameterToString(localVarOptionals.DebugLevel.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ClearExistingSchedule.IsSet() {
		localVarFormParams.Add("clear_existing_schedule", parameterToString(localVarOptionals.ClearExistingSchedule.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScheduleTime.IsSet() {
		localVarFormParams.Add("schedule_time", parameterToString(localVarOptionals.ScheduleTime.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScheduleDays.IsSet() {
		localVarFormParams.Add("schedule_days", parameterToString(localVarOptionals.ScheduleDays.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SecretKey.IsSet() {
		localVarFormParams.Add("secret_key", parameterToString(localVarOptionals.SecretKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Regions.IsSet() {
		localVarFormParams.Add("regions", parameterToString(localVarOptionals.Regions.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.GoogleRegions.IsSet() {
		localVarFormParams.Add("google_regions", parameterToString(localVarOptionals.GoogleRegions.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OracleRegions.IsSet() {
		localVarFormParams.Add("oracle_regions", parameterToString(localVarOptionals.OracleRegions.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Subscriptionid.IsSet() {
		localVarFormParams.Add("subscriptionid", parameterToString(localVarOptionals.Subscriptionid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Ip.IsSet() {
		localVarFormParams.Add("ip", parameterToString(localVarOptionals.Ip.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tenant.IsSet() {
		localVarFormParams.Add("tenant", parameterToString(localVarOptionals.Tenant.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Username.IsSet() {
		localVarFormParams.Add("username", parameterToString(localVarOptionals.Username.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApiKey.IsSet() {
		localVarFormParams.Add("api_key", parameterToString(localVarOptionals.ApiKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApiKeyId.IsSet() {
		localVarFormParams.Add("api_key_id", parameterToString(localVarOptionals.ApiKeyId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ApiToken.IsSet() {
		localVarFormParams.Add("api_token", parameterToString(localVarOptionals.ApiToken.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TokenKey.IsSet() {
		localVarFormParams.Add("token_key", parameterToString(localVarOptionals.TokenKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Region.IsSet() {
		localVarFormParams.Add("region", parameterToString(localVarOptionals.Region.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AlibabaRegions.IsSet() {
		localVarFormParams.Add("alibaba_regions", parameterToString(localVarOptionals.AlibabaRegions.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
AutoDiscoveryApiService Add DNS Auto Discovery
Add DNS Auto Discovery job
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param zonename name of the zone
 * @param nameserver IP/FQDN of the nameserver
 * @param optional nil or *AutoDiscoveryApiPostAutoDiscoveryDnsOpts - Optional Parameters:
     * @param "RemoteCollectorId" (optional.String) -  D42 ID of the remote collector to use for this job.
     * @param "ScheduleTime" (optional.String) -  Time in HH:MM format if you want to schedule the job. Note: Must be formatted as text NOT date. For multiple schedules, separate with a slash (/).
     * @param "ScheduleDays" (optional.String) -  Comma separated days of week, where Monday &#x3D; 0. e.g. 0,1,2 wil set the job for Mon, Tue and Wed. For multiple schedules, separate with a slash (/).

@return interface{}
*/

type AutoDiscoveryApiPostAutoDiscoveryDnsOpts struct { 
	RemoteCollectorId optional.String
	ScheduleTime optional.String
	ScheduleDays optional.String
}

func (a *AutoDiscoveryApiService) PostAutoDiscoveryDns(ctx context.Context, zonename string, nameserver string, localVarOptionals *AutoDiscoveryApiPostAutoDiscoveryDnsOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/auto_discovery/dns/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("zonename", parameterToString(zonename, ""))
	localVarFormParams.Add("nameserver", parameterToString(nameserver, ""))
	if localVarOptionals != nil && localVarOptionals.RemoteCollectorId.IsSet() {
		localVarFormParams.Add("remote_collector_id", parameterToString(localVarOptionals.RemoteCollectorId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScheduleTime.IsSet() {
		localVarFormParams.Add("schedule_time", parameterToString(localVarOptionals.ScheduleTime.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScheduleDays.IsSet() {
		localVarFormParams.Add("schedule_days", parameterToString(localVarOptionals.ScheduleDays.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
AutoDiscoveryApiService Add IPMI/Redfish Auto Discovery
Add IPMI/Redfish Auto Discovery job
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name name of the job
 * @param ipStart starting IP address
 * @param ipEnd ending IP address, use same as start for single address
 * @param bmcUser username for discovery
 * @param bmcPassword password for discovery
 * @param hostnameToUse
 * @param optional nil or *AutoDiscoveryApiPostAutoDiscoveryIpmiOpts - Optional Parameters:
     * @param "UpdateModelIfFound" (optional.String) - 
     * @param "RunAsOperator" (optional.String) - 
     * @param "ObjectCategory" (optional.String) - 
     * @param "OverwriteObjectCategories" (optional.String) - 
     * @param "ClearExistingSchedule" (optional.String) - 
     * @param "Groups" (optional.String) -  name of one or more groups separated by commas
     * @param "DebugLevel" (optional.String) - 
     * @param "DiscoveryType" (optional.String) - 
     * @param "RemoteCollectorId" (optional.String) - 
     * @param "ScheduleTime" (optional.String) -  Time in HH:MM format if you want to schedule the job. Note: Must be formatted as text NOT date. For multiple schedules, separate with a slash (/).
     * @param "ScheduleDays" (optional.String) -  Comma separated days of week, where Monday &#x3D; 0. e.g. 0,1,2 wil set the job for Mon, Tue and Wed. For multiple schedules, separate with a slash (/).

@return interface{}
*/

type AutoDiscoveryApiPostAutoDiscoveryIpmiOpts struct { 
	UpdateModelIfFound optional.String
	RunAsOperator optional.String
	ObjectCategory optional.String
	OverwriteObjectCategories optional.String
	ClearExistingSchedule optional.String
	Groups optional.String
	DebugLevel optional.String
	DiscoveryType optional.String
	RemoteCollectorId optional.String
	ScheduleTime optional.String
	ScheduleDays optional.String
}

func (a *AutoDiscoveryApiService) PostAutoDiscoveryIpmi(ctx context.Context, name string, ipStart string, ipEnd string, bmcUser string, bmcPassword string, hostnameToUse string, localVarOptionals *AutoDiscoveryApiPostAutoDiscoveryIpmiOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/auto_discovery/ipmi/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("hostname_to_use", parameterToString(hostnameToUse, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("name", parameterToString(name, ""))
	localVarFormParams.Add("ip_start", parameterToString(ipStart, ""))
	localVarFormParams.Add("ip_end", parameterToString(ipEnd, ""))
	localVarFormParams.Add("bmc_user", parameterToString(bmcUser, ""))
	localVarFormParams.Add("bmc_password", parameterToString(bmcPassword, ""))
	if localVarOptionals != nil && localVarOptionals.UpdateModelIfFound.IsSet() {
		localVarFormParams.Add("update_model_if_found", parameterToString(localVarOptionals.UpdateModelIfFound.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RunAsOperator.IsSet() {
		localVarFormParams.Add("run_as_operator", parameterToString(localVarOptionals.RunAsOperator.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectCategory.IsSet() {
		localVarFormParams.Add("object_category", parameterToString(localVarOptionals.ObjectCategory.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OverwriteObjectCategories.IsSet() {
		localVarFormParams.Add("overwrite_object_categories", parameterToString(localVarOptionals.OverwriteObjectCategories.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ClearExistingSchedule.IsSet() {
		localVarFormParams.Add("clear_existing_schedule", parameterToString(localVarOptionals.ClearExistingSchedule.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Groups.IsSet() {
		localVarFormParams.Add("groups", parameterToString(localVarOptionals.Groups.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DebugLevel.IsSet() {
		localVarFormParams.Add("debug_level", parameterToString(localVarOptionals.DebugLevel.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DiscoveryType.IsSet() {
		localVarFormParams.Add("discovery_type", parameterToString(localVarOptionals.DiscoveryType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RemoteCollectorId.IsSet() {
		localVarFormParams.Add("remote_collector_id", parameterToString(localVarOptionals.RemoteCollectorId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScheduleTime.IsSet() {
		localVarFormParams.Add("schedule_time", parameterToString(localVarOptionals.ScheduleTime.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScheduleDays.IsSet() {
		localVarFormParams.Add("schedule_days", parameterToString(localVarOptionals.ScheduleDays.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
AutoDiscoveryApiService
Add or update network job
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name name of the job
 * @param optional nil or *AutoDiscoveryApiPostAutoDiscoveryNetworksOpts - Optional Parameters:
     * @param "Ipaddress" (optional.String) -  IP address. Required if new
     * @param "EndIpAddress" (optional.String) -  End IP address
     * @param "SnmpString" (optional.String) -  required, if new
     * @param "SnmpStrings" (optional.String) -  Can be comma separated list of community strings to use multiple community strings
     * @param "SnmpStringIds" (optional.String) -  Can be comma separated list of community string IDs to use multiple community strings
     * @param "ScheduleTime" (optional.String) -  Time in HH:MM format if you want to schedule the job. Note: Must be formatted as text NOT date. For multiple schedules, separate with a slash (/).
     * @param "ScheduleDays" (optional.String) -  Comma separated days of week, where Monday &#x3D; 0. e.g. 0,1,2 wil set the job for Mon, Tue and Wed. For multiple schedules, separate with a slash (/).
     * @param "StripDomainName" (optional.String) - 
     * @param "AutodiscoverCdpDevices" (optional.String) -  yes to enable CDP/LLDP (added in v8.3.2)
     * @param "UseNameAliasPortDescr" (optional.String) -  yes to use alias for port description during discovery (added in v8.3.2)
     * @param "ClearExistingSchedule" (optional.String) - 
     * @param "Groups" (optional.String) -  name of one or more groups separated by commas
     * @param "MaskBits" (optional.Int32) -  mask bits (integer only)
     * @param "SnmpPort" (optional.Int32) -  snmp port (integer only) (added in v10.4.0)
     * @param "SnmpVersion" (optional.String) - 
     * @param "SnmpStringId" (optional.String) -  The id of the password for the community string
     * @param "Snmpv3AuthPasswordId" (optional.String) -  The id of the password for the auth password
     * @param "Snmpv3PrivacyProtocolPasswordId" (optional.String) -  The id of the password for the privacy protocol password
     * @param "Snmpv3User" (optional.String) -  name of snmp v3 user (added in v10.4.0)
     * @param "Snmpv3AuthMode" (optional.String) - 
     * @param "Snmpv3AuthProtocol" (optional.String) - 
     * @param "Snmpv3AuthPassword" (optional.String) -  password (added in v10.4.0)
     * @param "Snmpv3PrivacyProtocol" (optional.String) - 
     * @param "Snmpv3PrivacyProtocolPassword" (optional.String) -  password (added in v10.4.0)
     * @param "Snmpv3Context" (optional.String) - 
     * @param "GetAllSwitchPorts" (optional.String) -  yes or no to get all switch ports (added in v10.4.0)
     * @param "DeleteOlderMacAssociationAfter" (optional.String) -  number of days (added in v10.4.0)
     * @param "DeleteSwitchPortNotFound" (optional.String) -  yes or no to delete switch ports not found (added in v10.4.0)
     * @param "VlansToIgnore" (optional.String) -  list of vlan ids to ignore separated by commas (added in v10.4.0)
     * @param "PortNamePrefixToIgnoreMacs" (optional.String) - 
     * @param "DebugLevel" (optional.String) - 
     * @param "HostnamePrecedence" (optional.String) - 
     * @param "ServiceLevel" (optional.String) -  Must already exist
     * @param "SkipVlanIndexing" (optional.String) -  yes or no (added in v10.4.0)
     * @param "Vrfgroup" (optional.String) -  name of vrf group for discovered subnets (added in v10.4.0)
     * @param "ObjectCategory" (optional.String) -  name of subnet category for discovered subnets
     * @param "DiscoverServices" (optional.String) - 

@return interface{}
*/

type AutoDiscoveryApiPostAutoDiscoveryNetworksOpts struct { 
	Ipaddress optional.String
	EndIpAddress optional.String
	SnmpString optional.String
	SnmpStrings optional.String
	SnmpStringIds optional.String
	ScheduleTime optional.String
	ScheduleDays optional.String
	StripDomainName optional.String
	AutodiscoverCdpDevices optional.String
	UseNameAliasPortDescr optional.String
	ClearExistingSchedule optional.String
	Groups optional.String
	MaskBits optional.Int32
	SnmpPort optional.Int32
	SnmpVersion optional.String
	SnmpStringId optional.String
	Snmpv3AuthPasswordId optional.String
	Snmpv3PrivacyProtocolPasswordId optional.String
	Snmpv3User optional.String
	Snmpv3AuthMode optional.String
	Snmpv3AuthProtocol optional.String
	Snmpv3AuthPassword optional.String
	Snmpv3PrivacyProtocol optional.String
	Snmpv3PrivacyProtocolPassword optional.String
	Snmpv3Context optional.String
	GetAllSwitchPorts optional.String
	DeleteOlderMacAssociationAfter optional.String
	DeleteSwitchPortNotFound optional.String
	VlansToIgnore optional.String
	PortNamePrefixToIgnoreMacs optional.String
	DebugLevel optional.String
	HostnamePrecedence optional.String
	ServiceLevel optional.String
	SkipVlanIndexing optional.String
	Vrfgroup optional.String
	ObjectCategory optional.String
	DiscoverServices optional.String
}

func (a *AutoDiscoveryApiService) PostAutoDiscoveryNetworks(ctx context.Context, name string, localVarOptionals *AutoDiscoveryApiPostAutoDiscoveryNetworksOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/auto_discovery/networks/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("name", parameterToString(name, ""))
	if localVarOptionals != nil && localVarOptionals.Ipaddress.IsSet() {
		localVarFormParams.Add("ipaddress", parameterToString(localVarOptionals.Ipaddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EndIpAddress.IsSet() {
		localVarFormParams.Add("end_ip_address", parameterToString(localVarOptionals.EndIpAddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SnmpString.IsSet() {
		localVarFormParams.Add("snmp_string", parameterToString(localVarOptionals.SnmpString.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SnmpStrings.IsSet() {
		localVarFormParams.Add("snmp_strings", parameterToString(localVarOptionals.SnmpStrings.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SnmpStringIds.IsSet() {
		localVarFormParams.Add("snmp_string_ids", parameterToString(localVarOptionals.SnmpStringIds.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScheduleTime.IsSet() {
		localVarFormParams.Add("schedule_time", parameterToString(localVarOptionals.ScheduleTime.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScheduleDays.IsSet() {
		localVarFormParams.Add("schedule_days", parameterToString(localVarOptionals.ScheduleDays.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StripDomainName.IsSet() {
		localVarFormParams.Add("strip_domain_name", parameterToString(localVarOptionals.StripDomainName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AutodiscoverCdpDevices.IsSet() {
		localVarFormParams.Add("autodiscover_cdp_devices", parameterToString(localVarOptionals.AutodiscoverCdpDevices.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UseNameAliasPortDescr.IsSet() {
		localVarFormParams.Add("use_name_alias_port_descr", parameterToString(localVarOptionals.UseNameAliasPortDescr.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ClearExistingSchedule.IsSet() {
		localVarFormParams.Add("clear_existing_schedule", parameterToString(localVarOptionals.ClearExistingSchedule.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Groups.IsSet() {
		localVarFormParams.Add("groups", parameterToString(localVarOptionals.Groups.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaskBits.IsSet() {
		localVarFormParams.Add("mask_bits", parameterToString(localVarOptionals.MaskBits.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SnmpPort.IsSet() {
		localVarFormParams.Add("snmp_port", parameterToString(localVarOptionals.SnmpPort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SnmpVersion.IsSet() {
		localVarFormParams.Add("snmp_version", parameterToString(localVarOptionals.SnmpVersion.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SnmpStringId.IsSet() {
		localVarFormParams.Add("snmp_string_id", parameterToString(localVarOptionals.SnmpStringId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Snmpv3AuthPasswordId.IsSet() {
		localVarFormParams.Add("snmpv3_auth_password_id", parameterToString(localVarOptionals.Snmpv3AuthPasswordId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Snmpv3PrivacyProtocolPasswordId.IsSet() {
		localVarFormParams.Add("snmpv3_privacy_protocol_password_id", parameterToString(localVarOptionals.Snmpv3PrivacyProtocolPasswordId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Snmpv3User.IsSet() {
		localVarFormParams.Add("snmpv3_user", parameterToString(localVarOptionals.Snmpv3User.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Snmpv3AuthMode.IsSet() {
		localVarFormParams.Add("snmpv3_auth_mode", parameterToString(localVarOptionals.Snmpv3AuthMode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Snmpv3AuthProtocol.IsSet() {
		localVarFormParams.Add("snmpv3_auth_protocol", parameterToString(localVarOptionals.Snmpv3AuthProtocol.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Snmpv3AuthPassword.IsSet() {
		localVarFormParams.Add("snmpv3_auth_password", parameterToString(localVarOptionals.Snmpv3AuthPassword.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Snmpv3PrivacyProtocol.IsSet() {
		localVarFormParams.Add("snmpv3_privacy_protocol", parameterToString(localVarOptionals.Snmpv3PrivacyProtocol.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Snmpv3PrivacyProtocolPassword.IsSet() {
		localVarFormParams.Add("snmpv3_privacy_protocol_password", parameterToString(localVarOptionals.Snmpv3PrivacyProtocolPassword.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Snmpv3Context.IsSet() {
		localVarFormParams.Add("snmpv3_context", parameterToString(localVarOptionals.Snmpv3Context.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.GetAllSwitchPorts.IsSet() {
		localVarFormParams.Add("get_all_switch_ports", parameterToString(localVarOptionals.GetAllSwitchPorts.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeleteOlderMacAssociationAfter.IsSet() {
		localVarFormParams.Add("delete_older_mac_association_after", parameterToString(localVarOptionals.DeleteOlderMacAssociationAfter.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeleteSwitchPortNotFound.IsSet() {
		localVarFormParams.Add("delete_switch_port_not_found", parameterToString(localVarOptionals.DeleteSwitchPortNotFound.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VlansToIgnore.IsSet() {
		localVarFormParams.Add("vlans_to_ignore", parameterToString(localVarOptionals.VlansToIgnore.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PortNamePrefixToIgnoreMacs.IsSet() {
		localVarFormParams.Add("port_name_prefix_to_ignore_macs", parameterToString(localVarOptionals.PortNamePrefixToIgnoreMacs.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DebugLevel.IsSet() {
		localVarFormParams.Add("debug_level", parameterToString(localVarOptionals.DebugLevel.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HostnamePrecedence.IsSet() {
		localVarFormParams.Add("hostname_precedence", parameterToString(localVarOptionals.HostnamePrecedence.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ServiceLevel.IsSet() {
		localVarFormParams.Add("service_level", parameterToString(localVarOptionals.ServiceLevel.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SkipVlanIndexing.IsSet() {
		localVarFormParams.Add("skip_vlan_indexing", parameterToString(localVarOptionals.SkipVlanIndexing.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Vrfgroup.IsSet() {
		localVarFormParams.Add("vrfgroup", parameterToString(localVarOptionals.Vrfgroup.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectCategory.IsSet() {
		localVarFormParams.Add("object_category", parameterToString(localVarOptionals.ObjectCategory.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DiscoverServices.IsSet() {
		localVarFormParams.Add("discover_services", parameterToString(localVarOptionals.DiscoverServices.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
AutoDiscoveryApiService
Add or update pingsweep job
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name name of the job
 * @param optional nil or *AutoDiscoveryApiPostAutoDiscoveryPingsweepOpts - Optional Parameters:
     * @param "Networks" (optional.String) -  Networks to search. Required if new
     * @param "Type_" (optional.String) -  Choose if you want to automatically assign type to discovered IPs.
     * @param "StripDomainSuffix" (optional.String) -  Strip everything after the first dot
     * @param "ClearExistingSchedule" (optional.String) - 
     * @param "DebugLevel" (optional.String) - 
     * @param "ReverseDns" (optional.String) -  Add devices by reverse DNS of discovered IP. (Recommended to leave unchecked and use other discovery methods for devices)
     * @param "CreateNewSubnet" (optional.String) -  Create new subnet for networks not found
     * @param "Vrfgroup" (optional.String) -  name of vrf group for discovered subnets
     * @param "SubnetCategory" (optional.String) -  name of subnet category for discovered subnets
     * @param "OverwriteSubnetCategories" (optional.String) -  If a subnet is discovered that exists and already has a subnet category, the category will be overwritten and all child subnets of the discovered subnet will also get the new category.
     * @param "RemoteCollectorId" (optional.Int32) -  ID of the remote collector to use for this job
     * @param "Tags" (optional.String) -  comma separated list of tags
     * @param "TagsRemove" (optional.String) -  comma separated list of tags to remove

@return interface{}
*/

type AutoDiscoveryApiPostAutoDiscoveryPingsweepOpts struct { 
	Networks optional.String
	Type_ optional.String
	StripDomainSuffix optional.String
	ClearExistingSchedule optional.String
	DebugLevel optional.String
	ReverseDns optional.String
	CreateNewSubnet optional.String
	Vrfgroup optional.String
	SubnetCategory optional.String
	OverwriteSubnetCategories optional.String
	RemoteCollectorId optional.Int32
	Tags optional.String
	TagsRemove optional.String
}

func (a *AutoDiscoveryApiService) PostAutoDiscoveryPingsweep(ctx context.Context, name string, localVarOptionals *AutoDiscoveryApiPostAutoDiscoveryPingsweepOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/auto_discovery/pingsweep/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("name", parameterToString(name, ""))
	if localVarOptionals != nil && localVarOptionals.Networks.IsSet() {
		localVarFormParams.Add("networks", parameterToString(localVarOptionals.Networks.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarFormParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StripDomainSuffix.IsSet() {
		localVarFormParams.Add("strip_domain_suffix", parameterToString(localVarOptionals.StripDomainSuffix.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ClearExistingSchedule.IsSet() {
		localVarFormParams.Add("clear_existing_schedule", parameterToString(localVarOptionals.ClearExistingSchedule.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DebugLevel.IsSet() {
		localVarFormParams.Add("debug_level", parameterToString(localVarOptionals.DebugLevel.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReverseDns.IsSet() {
		localVarFormParams.Add("reverse_dns", parameterToString(localVarOptionals.ReverseDns.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreateNewSubnet.IsSet() {
		localVarFormParams.Add("create_new_subnet", parameterToString(localVarOptionals.CreateNewSubnet.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Vrfgroup.IsSet() {
		localVarFormParams.Add("vrfgroup", parameterToString(localVarOptionals.Vrfgroup.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SubnetCategory.IsSet() {
		localVarFormParams.Add("subnet_category", parameterToString(localVarOptionals.SubnetCategory.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OverwriteSubnetCategories.IsSet() {
		localVarFormParams.Add("overwrite_subnet_categories", parameterToString(localVarOptionals.OverwriteSubnetCategories.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RemoteCollectorId.IsSet() {
		localVarFormParams.Add("remote_collector_id", parameterToString(localVarOptionals.RemoteCollectorId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tags.IsSet() {
		localVarFormParams.Add("tags", parameterToString(localVarOptionals.Tags.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TagsRemove.IsSet() {
		localVarFormParams.Add("tags_remove", parameterToString(localVarOptionals.TagsRemove.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
AutoDiscoveryApiService Add or update power autodiscovery job
Add or update power autodiscovery job
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name name of the job
 * @param appliance name of the monitoring appliance
 * @param optional nil or *AutoDiscoveryApiPostAutoDiscoveryPowerDiscOpts - Optional Parameters:
     * @param "Ipaddress" (optional.String) -  IP address. Required if new
     * @param "EndIpAddress" (optional.String) -  End IP address
     * @param "SnmpString" (optional.String) -  required, if new
     * @param "ScheduleTime" (optional.String) -  Time in HH:MM format if you want to schedule the job. Note: Must be formatted as text NOT date. For multiple schedules, separate with a slash (/).
     * @param "ScheduleDays" (optional.String) -  Comma separated days of week, where Monday &#x3D; 0. e.g. 0,1,2 wil set the job for Mon, Tue and Wed. For multiple schedules, separate with a slash (/).
     * @param "StripDomainName" (optional.String) - 
     * @param "ClearExistingSchedule" (optional.String) - 
     * @param "Vrfgroup" (optional.String) -  name of vrf group for discovered subnets (added in v10.4.0)
     * @param "ObjectCategory" (optional.String) -  name of subnet category for discovered subnets
     * @param "Category" (optional.String) -  subnet category to assign to addresses of discovered units
     * @param "Groups" (optional.String) -  name of one or more groups separated by commas
     * @param "SnmpPort" (optional.Int32) -  snmp port (integer only) (added in v10.4.0)
     * @param "SnmpVersion" (optional.String) - 
     * @param "SnmpStringId" (optional.String) -  The id of the password for the community string
     * @param "Snmpv3AuthPasswordId" (optional.String) -  The id of the password for the auth password
     * @param "Snmpv3PrivacyProtocolPasswordId" (optional.String) -  The id of the password for the privacy protocol password
     * @param "Snmpv3User" (optional.String) -  name of snmp v3 user (added in v10.4.0)
     * @param "Snmpv3AuthMode" (optional.String) - 
     * @param "Snmpv3AuthProtocol" (optional.String) - 
     * @param "Snmpv3AuthPassword" (optional.String) -  password (added in v10.4.0)
     * @param "Snmpv3PrivacyProtocol" (optional.String) - 
     * @param "Snmpv3PrivacyProtocolPassword" (optional.String) -  password (added in v10.4.0)
     * @param "Snmpv3Context" (optional.String) - 
     * @param "HostnamePrecedence" (optional.String) - 
     * @param "ServiceLevel" (optional.String) -  Must already exist
     * @param "NameToUseForNewlyDiscoveredModule" (optional.String) -  name to use
     * @param "ToggleInServiceOnModulePowerState" (optional.String) -  yes or no
     * @param "ModuleNotFound" (optional.String) -  action to take on module not found. One of: Remove Host Association, Change Service Level, Delete Module (default is no action)
     * @param "NameToUseForNewlyDiscoveredPdu" (optional.String) -  one of: Name discovered by SNMP, Name plus serial number, Name plus serial number plus IP
     * @param "PollingInterval" (optional.String) -  polling interval in minutes (integer)

@return interface{}
*/

type AutoDiscoveryApiPostAutoDiscoveryPowerDiscOpts struct { 
	Ipaddress optional.String
	EndIpAddress optional.String
	SnmpString optional.String
	ScheduleTime optional.String
	ScheduleDays optional.String
	StripDomainName optional.String
	ClearExistingSchedule optional.String
	Vrfgroup optional.String
	ObjectCategory optional.String
	Category optional.String
	Groups optional.String
	SnmpPort optional.Int32
	SnmpVersion optional.String
	SnmpStringId optional.String
	Snmpv3AuthPasswordId optional.String
	Snmpv3PrivacyProtocolPasswordId optional.String
	Snmpv3User optional.String
	Snmpv3AuthMode optional.String
	Snmpv3AuthProtocol optional.String
	Snmpv3AuthPassword optional.String
	Snmpv3PrivacyProtocol optional.String
	Snmpv3PrivacyProtocolPassword optional.String
	Snmpv3Context optional.String
	HostnamePrecedence optional.String
	ServiceLevel optional.String
	NameToUseForNewlyDiscoveredModule optional.String
	ToggleInServiceOnModulePowerState optional.String
	ModuleNotFound optional.String
	NameToUseForNewlyDiscoveredPdu optional.String
	PollingInterval optional.String
}

func (a *AutoDiscoveryApiService) PostAutoDiscoveryPowerDisc(ctx context.Context, name string, appliance string, localVarOptionals *AutoDiscoveryApiPostAutoDiscoveryPowerDiscOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/auto_discovery/power_disc/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("name", parameterToString(name, ""))
	localVarFormParams.Add("appliance", parameterToString(appliance, ""))
	if localVarOptionals != nil && localVarOptionals.Ipaddress.IsSet() {
		localVarFormParams.Add("ipaddress", parameterToString(localVarOptionals.Ipaddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EndIpAddress.IsSet() {
		localVarFormParams.Add("end_ip_address", parameterToString(localVarOptionals.EndIpAddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SnmpString.IsSet() {
		localVarFormParams.Add("snmp_string", parameterToString(localVarOptionals.SnmpString.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScheduleTime.IsSet() {
		localVarFormParams.Add("schedule_time", parameterToString(localVarOptionals.ScheduleTime.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScheduleDays.IsSet() {
		localVarFormParams.Add("schedule_days", parameterToString(localVarOptionals.ScheduleDays.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StripDomainName.IsSet() {
		localVarFormParams.Add("strip_domain_name", parameterToString(localVarOptionals.StripDomainName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ClearExistingSchedule.IsSet() {
		localVarFormParams.Add("clear_existing_schedule", parameterToString(localVarOptionals.ClearExistingSchedule.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Vrfgroup.IsSet() {
		localVarFormParams.Add("vrfgroup", parameterToString(localVarOptionals.Vrfgroup.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectCategory.IsSet() {
		localVarFormParams.Add("object_category", parameterToString(localVarOptionals.ObjectCategory.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Category.IsSet() {
		localVarFormParams.Add("category", parameterToString(localVarOptionals.Category.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Groups.IsSet() {
		localVarFormParams.Add("groups", parameterToString(localVarOptionals.Groups.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SnmpPort.IsSet() {
		localVarFormParams.Add("snmp_port", parameterToString(localVarOptionals.SnmpPort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SnmpVersion.IsSet() {
		localVarFormParams.Add("snmp_version", parameterToString(localVarOptionals.SnmpVersion.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SnmpStringId.IsSet() {
		localVarFormParams.Add("snmp_string_id", parameterToString(localVarOptionals.SnmpStringId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Snmpv3AuthPasswordId.IsSet() {
		localVarFormParams.Add("snmpv3_auth_password_id", parameterToString(localVarOptionals.Snmpv3AuthPasswordId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Snmpv3PrivacyProtocolPasswordId.IsSet() {
		localVarFormParams.Add("snmpv3_privacy_protocol_password_id", parameterToString(localVarOptionals.Snmpv3PrivacyProtocolPasswordId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Snmpv3User.IsSet() {
		localVarFormParams.Add("snmpv3_user", parameterToString(localVarOptionals.Snmpv3User.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Snmpv3AuthMode.IsSet() {
		localVarFormParams.Add("snmpv3_auth_mode", parameterToString(localVarOptionals.Snmpv3AuthMode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Snmpv3AuthProtocol.IsSet() {
		localVarFormParams.Add("snmpv3_auth_protocol", parameterToString(localVarOptionals.Snmpv3AuthProtocol.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Snmpv3AuthPassword.IsSet() {
		localVarFormParams.Add("snmpv3_auth_password", parameterToString(localVarOptionals.Snmpv3AuthPassword.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Snmpv3PrivacyProtocol.IsSet() {
		localVarFormParams.Add("snmpv3_privacy_protocol", parameterToString(localVarOptionals.Snmpv3PrivacyProtocol.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Snmpv3PrivacyProtocolPassword.IsSet() {
		localVarFormParams.Add("snmpv3_privacy_protocol_password", parameterToString(localVarOptionals.Snmpv3PrivacyProtocolPassword.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Snmpv3Context.IsSet() {
		localVarFormParams.Add("snmpv3_context", parameterToString(localVarOptionals.Snmpv3Context.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HostnamePrecedence.IsSet() {
		localVarFormParams.Add("hostname_precedence", parameterToString(localVarOptionals.HostnamePrecedence.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ServiceLevel.IsSet() {
		localVarFormParams.Add("service_level", parameterToString(localVarOptionals.ServiceLevel.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameToUseForNewlyDiscoveredModule.IsSet() {
		localVarFormParams.Add("name_to_use_for_newly_discovered_module", parameterToString(localVarOptionals.NameToUseForNewlyDiscoveredModule.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ToggleInServiceOnModulePowerState.IsSet() {
		localVarFormParams.Add("toggle_in_service_on_module_power_state", parameterToString(localVarOptionals.ToggleInServiceOnModulePowerState.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ModuleNotFound.IsSet() {
		localVarFormParams.Add("module_not_found", parameterToString(localVarOptionals.ModuleNotFound.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameToUseForNewlyDiscoveredPdu.IsSet() {
		localVarFormParams.Add("name_to_use_for_newly_discovered_pdu", parameterToString(localVarOptionals.NameToUseForNewlyDiscoveredPdu.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PollingInterval.IsSet() {
		localVarFormParams.Add("polling_interval", parameterToString(localVarOptionals.PollingInterval.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
AutoDiscoveryApiService Add or update other SNMP autodiscovery job
Add or update other SNMP autodiscovery job
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name name of the job
 * @param optional nil or *AutoDiscoveryApiPostAutoDiscoverySnmpDiscOpts - Optional Parameters:
     * @param "Ipaddress" (optional.String) -  IP address. Required if new
     * @param "EndIpAddress" (optional.String) -  End IP address
     * @param "SnmpString" (optional.String) -  required, if new
     * @param "RemoteCollectorId" (optional.String) -  D42 ID of the remote collector to use for this job.
     * @param "ScheduleTime" (optional.String) -  Time in HH:MM format if you want to schedule the job. Note: Must be formatted as text NOT date. For multiple schedules, separate with a slash (/).
     * @param "ScheduleDays" (optional.String) -  Comma separated days of week, where Monday &#x3D; 0. e.g. 0,1,2 wil set the job for Mon, Tue and Wed. For multiple schedules, separate with a slash (/).
     * @param "StripDomainName" (optional.String) - 
     * @param "ClearExistingSchedule" (optional.String) - 
     * @param "Groups" (optional.String) -  name of one or more groups separated by commas
     * @param "SnmpPort" (optional.Int32) -  snmp port (integer only) (added in v10.4.0)
     * @param "SnmpVersion" (optional.String) - 
     * @param "SnmpStringId" (optional.String) -  The id of the password for the community string
     * @param "Snmpv3AuthPasswordId" (optional.String) -  The id of the password for the auth password
     * @param "Snmpv3PrivacyProtocolPasswordId" (optional.String) -  The id of the password for the privacy protocol password
     * @param "Snmpv3User" (optional.String) -  name of snmp v3 user (added in v10.4.0)
     * @param "Snmpv3AuthMode" (optional.String) - 
     * @param "Snmpv3AuthProtocol" (optional.String) - 
     * @param "Snmpv3AuthPassword" (optional.String) -  password (added in v10.4.0)
     * @param "Snmpv3PrivacyProtocol" (optional.String) - 
     * @param "Snmpv3PrivacyProtocolPassword" (optional.String) -  password (added in v10.4.0)
     * @param "Snmpv3Context" (optional.String) - 
     * @param "DebugLevel" (optional.String) - 
     * @param "ServiceLevel" (optional.String) -  Must already exist


*/

type AutoDiscoveryApiPostAutoDiscoverySnmpDiscOpts struct { 
	Ipaddress optional.String
	EndIpAddress optional.String
	SnmpString optional.String
	RemoteCollectorId optional.String
	ScheduleTime optional.String
	ScheduleDays optional.String
	StripDomainName optional.String
	ClearExistingSchedule optional.String
	Groups optional.String
	SnmpPort optional.Int32
	SnmpVersion optional.String
	SnmpStringId optional.String
	Snmpv3AuthPasswordId optional.String
	Snmpv3PrivacyProtocolPasswordId optional.String
	Snmpv3User optional.String
	Snmpv3AuthMode optional.String
	Snmpv3AuthProtocol optional.String
	Snmpv3AuthPassword optional.String
	Snmpv3PrivacyProtocol optional.String
	Snmpv3PrivacyProtocolPassword optional.String
	Snmpv3Context optional.String
	DebugLevel optional.String
	ServiceLevel optional.String
}

func (a *AutoDiscoveryApiService) PostAutoDiscoverySnmpDisc(ctx context.Context, name string, localVarOptionals *AutoDiscoveryApiPostAutoDiscoverySnmpDiscOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/auto_discovery/snmp_disc/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("name", parameterToString(name, ""))
	if localVarOptionals != nil && localVarOptionals.Ipaddress.IsSet() {
		localVarFormParams.Add("ipaddress", parameterToString(localVarOptionals.Ipaddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EndIpAddress.IsSet() {
		localVarFormParams.Add("end_ip_address", parameterToString(localVarOptionals.EndIpAddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SnmpString.IsSet() {
		localVarFormParams.Add("snmp_string", parameterToString(localVarOptionals.SnmpString.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RemoteCollectorId.IsSet() {
		localVarFormParams.Add("remote_collector_id", parameterToString(localVarOptionals.RemoteCollectorId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScheduleTime.IsSet() {
		localVarFormParams.Add("schedule_time", parameterToString(localVarOptionals.ScheduleTime.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScheduleDays.IsSet() {
		localVarFormParams.Add("schedule_days", parameterToString(localVarOptionals.ScheduleDays.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StripDomainName.IsSet() {
		localVarFormParams.Add("strip_domain_name", parameterToString(localVarOptionals.StripDomainName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ClearExistingSchedule.IsSet() {
		localVarFormParams.Add("clear_existing_schedule", parameterToString(localVarOptionals.ClearExistingSchedule.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Groups.IsSet() {
		localVarFormParams.Add("groups", parameterToString(localVarOptionals.Groups.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SnmpPort.IsSet() {
		localVarFormParams.Add("snmp_port", parameterToString(localVarOptionals.SnmpPort.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SnmpVersion.IsSet() {
		localVarFormParams.Add("snmp_version", parameterToString(localVarOptionals.SnmpVersion.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SnmpStringId.IsSet() {
		localVarFormParams.Add("snmp_string_id", parameterToString(localVarOptionals.SnmpStringId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Snmpv3AuthPasswordId.IsSet() {
		localVarFormParams.Add("snmpv3_auth_password_id", parameterToString(localVarOptionals.Snmpv3AuthPasswordId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Snmpv3PrivacyProtocolPasswordId.IsSet() {
		localVarFormParams.Add("snmpv3_privacy_protocol_password_id", parameterToString(localVarOptionals.Snmpv3PrivacyProtocolPasswordId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Snmpv3User.IsSet() {
		localVarFormParams.Add("snmpv3_user", parameterToString(localVarOptionals.Snmpv3User.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Snmpv3AuthMode.IsSet() {
		localVarFormParams.Add("snmpv3_auth_mode", parameterToString(localVarOptionals.Snmpv3AuthMode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Snmpv3AuthProtocol.IsSet() {
		localVarFormParams.Add("snmpv3_auth_protocol", parameterToString(localVarOptionals.Snmpv3AuthProtocol.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Snmpv3AuthPassword.IsSet() {
		localVarFormParams.Add("snmpv3_auth_password", parameterToString(localVarOptionals.Snmpv3AuthPassword.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Snmpv3PrivacyProtocol.IsSet() {
		localVarFormParams.Add("snmpv3_privacy_protocol", parameterToString(localVarOptionals.Snmpv3PrivacyProtocol.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Snmpv3PrivacyProtocolPassword.IsSet() {
		localVarFormParams.Add("snmpv3_privacy_protocol_password", parameterToString(localVarOptionals.Snmpv3PrivacyProtocolPassword.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Snmpv3Context.IsSet() {
		localVarFormParams.Add("snmpv3_context", parameterToString(localVarOptionals.Snmpv3Context.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DebugLevel.IsSet() {
		localVarFormParams.Add("debug_level", parameterToString(localVarOptionals.DebugLevel.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ServiceLevel.IsSet() {
		localVarFormParams.Add("service_level", parameterToString(localVarOptionals.ServiceLevel.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
AutoDiscoveryApiService Add or update UCS/ACI/Load Balancer Auto Discovery
Add or update a UCS/ACI/Load Balancer auto-discovery job.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name name of the job
 * @param platform Required
 * @param port Default is 443 - use this default if you are not sure.
 * @param username
 * @param password
 * @param hostnameToUse Required - relevant for new devices only. If a device with same serial number already exists, name is ignored
 * @param optional nil or *AutoDiscoveryApiPostAutoDiscoveryUcsOpts - Optional Parameters:
     * @param "RemoteCollectorId" (optional.String) - 
     * @param "Server" (optional.String) -  FQDN or IP of the server(s) or CIDR or ranges
     * @param "UseSsl" (optional.String) -  Default is Yes - use this default if you are not sure.
     * @param "ExcludeServers" (optional.String) -  Servers to ignore
     * @param "HostnamePrecedence" (optional.String) -  Discovered name for the device is given precedence over existing name in the system.
     * @param "ToggleServiceLevelOnPowerState" (optional.String) -  Toggle the service level of a device based on power state.
     * @param "DecommissionedServiceLevelId" (optional.String) -  Service level for decommissioned devices.
     * @param "VrfGroupId" (optional.String) -  VRF Group for discovered devices.
     * @param "ObjectCategory" (optional.String) -  Existing object category will not be overwritten.
     * @param "OverwriteObjectCategories" (optional.String) - 
     * @param "ScheduleTime" (optional.String) -  Time in HH:MM format if you want to schedule the job. Note: Must be formatted as text NOT date. For multiple schedules, separate with a slash (/).
     * @param "ScheduleDays" (optional.String) -  Comma separated days of week, where Monday &#x3D; 0. e.g. 0,1,2 wil set the job for Mon, Tue and Wed. For multiple schedules, separate with a slash (/).
     * @param "ClearExistingSchedule" (optional.String) - 
     * @param "DebugLevel" (optional.String) - 

@return interface{}
*/

type AutoDiscoveryApiPostAutoDiscoveryUcsOpts struct { 
	RemoteCollectorId optional.String
	Server optional.String
	UseSsl optional.String
	ExcludeServers optional.String
	HostnamePrecedence optional.String
	ToggleServiceLevelOnPowerState optional.String
	DecommissionedServiceLevelId optional.String
	VrfGroupId optional.String
	ObjectCategory optional.String
	OverwriteObjectCategories optional.String
	ScheduleTime optional.String
	ScheduleDays optional.String
	ClearExistingSchedule optional.String
	DebugLevel optional.String
}

func (a *AutoDiscoveryApiService) PostAutoDiscoveryUcs(ctx context.Context, name string, platform string, port string, username string, password string, hostnameToUse string, localVarOptionals *AutoDiscoveryApiPostAutoDiscoveryUcsOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/auto_discovery/ucs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("name", parameterToString(name, ""))
	if localVarOptionals != nil && localVarOptionals.RemoteCollectorId.IsSet() {
		localVarFormParams.Add("remote_collector_id", parameterToString(localVarOptionals.RemoteCollectorId.Value(), ""))
	}
	localVarFormParams.Add("platform", parameterToString(platform, ""))
	if localVarOptionals != nil && localVarOptionals.Server.IsSet() {
		localVarFormParams.Add("server", parameterToString(localVarOptionals.Server.Value(), ""))
	}
	localVarFormParams.Add("port", parameterToString(port, ""))
	if localVarOptionals != nil && localVarOptionals.UseSsl.IsSet() {
		localVarFormParams.Add("use_ssl", parameterToString(localVarOptionals.UseSsl.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ExcludeServers.IsSet() {
		localVarFormParams.Add("exclude_servers", parameterToString(localVarOptionals.ExcludeServers.Value(), ""))
	}
	localVarFormParams.Add("username", parameterToString(username, ""))
	localVarFormParams.Add("password", parameterToString(password, ""))
	localVarFormParams.Add("hostname_to_use", parameterToString(hostnameToUse, ""))
	if localVarOptionals != nil && localVarOptionals.HostnamePrecedence.IsSet() {
		localVarFormParams.Add("hostname_precedence", parameterToString(localVarOptionals.HostnamePrecedence.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ToggleServiceLevelOnPowerState.IsSet() {
		localVarFormParams.Add("toggle_service_level_on_power_state", parameterToString(localVarOptionals.ToggleServiceLevelOnPowerState.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DecommissionedServiceLevelId.IsSet() {
		localVarFormParams.Add("decommissioned_service_level_id", parameterToString(localVarOptionals.DecommissionedServiceLevelId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VrfGroupId.IsSet() {
		localVarFormParams.Add("vrf_group_id", parameterToString(localVarOptionals.VrfGroupId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectCategory.IsSet() {
		localVarFormParams.Add("object_category", parameterToString(localVarOptionals.ObjectCategory.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OverwriteObjectCategories.IsSet() {
		localVarFormParams.Add("overwrite_object_categories", parameterToString(localVarOptionals.OverwriteObjectCategories.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScheduleTime.IsSet() {
		localVarFormParams.Add("schedule_time", parameterToString(localVarOptionals.ScheduleTime.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScheduleDays.IsSet() {
		localVarFormParams.Add("schedule_days", parameterToString(localVarOptionals.ScheduleDays.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ClearExistingSchedule.IsSet() {
		localVarFormParams.Add("clear_existing_schedule", parameterToString(localVarOptionals.ClearExistingSchedule.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DebugLevel.IsSet() {
		localVarFormParams.Add("debug_level", parameterToString(localVarOptionals.DebugLevel.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
AutoDiscoveryApiService Add or update vServer autodiscovery job
Add or update vServer autodiscovery job
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name name of the job
 * @param optional nil or *AutoDiscoveryApiPostAutoDiscoveryVserverOpts - Optional Parameters:
     * @param "Server" (optional.String) -  IP or FQDN of target server
     * @param "Platform" (optional.String) - 
     * @param "EndIpAddress" (optional.String) -  End IP address
     * @param "UseFtp" (optional.String) -  Use FTP instead of Telnet for discovery.
     * @param "ClearExistingSchedule" (optional.String) - 
     * @param "ScheduleTime" (optional.String) -  Time in HH:MM format if you want to schedule the job. Note: Must be formatted as text NOT date. For multiple schedules, separate with a slash (/).
     * @param "ScheduleDays" (optional.String) -  Comma separated days of week, where Monday &#x3D; 0. e.g. 0,1,2 wil set the job for Mon, Tue and Wed. For multiple schedules, separate with a slash (/).
     * @param "PasswordIds" (optional.String) -  One or more D42 password ID numbers separated by commas
     * @param "Groups" (optional.String) -  name of one or more groups separated by commas
     * @param "ObjectCategory" (optional.String) -  category of discovered vservers and vms
     * @param "DebugLevel" (optional.String) - 
     * @param "ServiceLevel" (optional.String) -  Must already exist
     * @param "UrlPrefix" (optional.String) -  http or https
     * @param "Port" (optional.String) -  specify port
     * @param "UrlSuffix" (optional.String) -  append suffix to discovery url
     * @param "Username" (optional.String) -  username to use in discovery
     * @param "Password" (optional.String) -  password to use in discovery
     * @param "StripDomainSuffix" (optional.String) -  Strip domain suffix if discovered on VMs or hypervisor
     * @param "PrependVmhostname" (optional.String) - 
     * @param "IgnorePoweredOff" (optional.String) -  Ignore powered off vms
     * @param "DiscoverVms" (optional.String) -  discover VMs or strictly hypervisors
     * @param "VmNameToUse" (optional.String) -  “found from vm tools” or “as named on vserver”
     * @param "AddMultipleVmNamesAsAlias" (optional.String) -  add any additional names found as device alias
     * @param "ToggleServiceLevelOnVmPowerState" (optional.String) - 
     * @param "GetGuestOsInfo" (optional.String) - 
     * @param "IgnoreGuestUuid" (optional.String) - 
     * @param "VmNotFound" (optional.String) -  Choose how to handle VM not found in discovery
     * @param "TrackVmNameChange" (optional.String) - 
     * @param "HostnamePrecedence" (optional.String) - 
     * @param "Hostidlist" (optional.String) - 
     * @param "VmAddDisk" (optional.String) - 
     * @param "HostAllowDuplicateSerials" (optional.String) - 
     * @param "IgnoreHostSerial" (optional.String) - 
     * @param "IgnoreHostUuid" (optional.String) - 
     * @param "OverwriteObjectCategories" (optional.String) - 
     * @param "RemoteCollectorId" (optional.String) - 
     * @param "UseServiceAccount" (optional.String) - 
     * @param "IgnoreIpv6" (optional.String) - 
     * @param "IgnoreVirtSubtype" (optional.String) - 
     * @param "DeviceNameFormat" (optional.String) - 
     * @param "DiscoverParts" (optional.String) - 
     * @param "CaptureHostsFile" (optional.String) - 
     * @param "DiscoverSoftware" (optional.String) - 
     * @param "InitialSoftwareType" (optional.String) - 
     * @param "DiscoverLinesOfCode" (optional.String) -  If enabled, please set the max timeout for the discovery to greater than 5 minutes.
     * @param "DiscoverServices" (optional.String) - 
     * @param "DiscoverApplications" (optional.String) - 
     * @param "StoreConfigFiles" (optional.String) - 
     * @param "DiscoverCloudid" (optional.String) - 
     * @param "CustomerId" (optional.String) - 
     * @param "VrfGroupId" (optional.String) -  ID of the VRF group
     * @param "ServiceLevelDeviceId" (optional.String) - 
     * @param "SudoRetry" (optional.String) - 
     * @param "AlternateSudo" (optional.String) - 
     * @param "UseDomainServer" (optional.String) - 
     * @param "LdapServer" (optional.String) - 
     * @param "UseFqdn" (optional.String) - 
     * @param "LdapFilterType" (optional.String) - 
     * @param "LdapUnpwdId" (optional.String) - 
     * @param "AlternateSudoPasswordId" (optional.String) - 
     * @param "PollingInterval" (optional.String) -  polling interval in minutes (integer)
     * @param "EnableResourcesMonitoring" (optional.String) - 

@return interface{}
*/

type AutoDiscoveryApiPostAutoDiscoveryVserverOpts struct { 
	Server optional.String
	Platform optional.String
	EndIpAddress optional.String
	UseFtp optional.String
	ClearExistingSchedule optional.String
	ScheduleTime optional.String
	ScheduleDays optional.String
	PasswordIds optional.String
	Groups optional.String
	ObjectCategory optional.String
	DebugLevel optional.String
	ServiceLevel optional.String
	UrlPrefix optional.String
	Port optional.String
	UrlSuffix optional.String
	Username optional.String
	Password optional.String
	StripDomainSuffix optional.String
	PrependVmhostname optional.String
	IgnorePoweredOff optional.String
	DiscoverVms optional.String
	VmNameToUse optional.String
	AddMultipleVmNamesAsAlias optional.String
	ToggleServiceLevelOnVmPowerState optional.String
	GetGuestOsInfo optional.String
	IgnoreGuestUuid optional.String
	VmNotFound optional.String
	TrackVmNameChange optional.String
	HostnamePrecedence optional.String
	Hostidlist optional.String
	VmAddDisk optional.String
	HostAllowDuplicateSerials optional.String
	IgnoreHostSerial optional.String
	IgnoreHostUuid optional.String
	OverwriteObjectCategories optional.String
	RemoteCollectorId optional.String
	UseServiceAccount optional.String
	IgnoreIpv6 optional.String
	IgnoreVirtSubtype optional.String
	DeviceNameFormat optional.String
	DiscoverParts optional.String
	CaptureHostsFile optional.String
	DiscoverSoftware optional.String
	InitialSoftwareType optional.String
	DiscoverLinesOfCode optional.String
	DiscoverServices optional.String
	DiscoverApplications optional.String
	StoreConfigFiles optional.String
	DiscoverCloudid optional.String
	CustomerId optional.String
	VrfGroupId optional.String
	ServiceLevelDeviceId optional.String
	SudoRetry optional.String
	AlternateSudo optional.String
	UseDomainServer optional.String
	LdapServer optional.String
	UseFqdn optional.String
	LdapFilterType optional.String
	LdapUnpwdId optional.String
	AlternateSudoPasswordId optional.String
	PollingInterval optional.String
	EnableResourcesMonitoring optional.String
}

func (a *AutoDiscoveryApiService) PostAutoDiscoveryVserver(ctx context.Context, name string, localVarOptionals *AutoDiscoveryApiPostAutoDiscoveryVserverOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/auto_discovery/vserver/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("name", parameterToString(name, ""))
	if localVarOptionals != nil && localVarOptionals.Server.IsSet() {
		localVarFormParams.Add("server", parameterToString(localVarOptionals.Server.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Platform.IsSet() {
		localVarFormParams.Add("platform", parameterToString(localVarOptionals.Platform.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EndIpAddress.IsSet() {
		localVarFormParams.Add("end_ip_address", parameterToString(localVarOptionals.EndIpAddress.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UseFtp.IsSet() {
		localVarFormParams.Add("use_ftp", parameterToString(localVarOptionals.UseFtp.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ClearExistingSchedule.IsSet() {
		localVarFormParams.Add("clear_existing_schedule", parameterToString(localVarOptionals.ClearExistingSchedule.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScheduleTime.IsSet() {
		localVarFormParams.Add("schedule_time", parameterToString(localVarOptionals.ScheduleTime.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScheduleDays.IsSet() {
		localVarFormParams.Add("schedule_days", parameterToString(localVarOptionals.ScheduleDays.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PasswordIds.IsSet() {
		localVarFormParams.Add("password_ids", parameterToString(localVarOptionals.PasswordIds.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Groups.IsSet() {
		localVarFormParams.Add("groups", parameterToString(localVarOptionals.Groups.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectCategory.IsSet() {
		localVarFormParams.Add("object_category", parameterToString(localVarOptionals.ObjectCategory.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DebugLevel.IsSet() {
		localVarFormParams.Add("debug_level", parameterToString(localVarOptionals.DebugLevel.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ServiceLevel.IsSet() {
		localVarFormParams.Add("service_level", parameterToString(localVarOptionals.ServiceLevel.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UrlPrefix.IsSet() {
		localVarFormParams.Add("url_prefix", parameterToString(localVarOptionals.UrlPrefix.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Port.IsSet() {
		localVarFormParams.Add("port", parameterToString(localVarOptionals.Port.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UrlSuffix.IsSet() {
		localVarFormParams.Add("url_suffix", parameterToString(localVarOptionals.UrlSuffix.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Username.IsSet() {
		localVarFormParams.Add("username", parameterToString(localVarOptionals.Username.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Password.IsSet() {
		localVarFormParams.Add("password", parameterToString(localVarOptionals.Password.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StripDomainSuffix.IsSet() {
		localVarFormParams.Add("strip_domain_suffix", parameterToString(localVarOptionals.StripDomainSuffix.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PrependVmhostname.IsSet() {
		localVarFormParams.Add("prepend_vmhostname", parameterToString(localVarOptionals.PrependVmhostname.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IgnorePoweredOff.IsSet() {
		localVarFormParams.Add("ignore_powered_off", parameterToString(localVarOptionals.IgnorePoweredOff.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DiscoverVms.IsSet() {
		localVarFormParams.Add("discover_vms", parameterToString(localVarOptionals.DiscoverVms.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VmNameToUse.IsSet() {
		localVarFormParams.Add("vm_name_to_use", parameterToString(localVarOptionals.VmNameToUse.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AddMultipleVmNamesAsAlias.IsSet() {
		localVarFormParams.Add("add_multiple_vm_names_as_alias", parameterToString(localVarOptionals.AddMultipleVmNamesAsAlias.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ToggleServiceLevelOnVmPowerState.IsSet() {
		localVarFormParams.Add("toggle_service_level_on_vm_power_state", parameterToString(localVarOptionals.ToggleServiceLevelOnVmPowerState.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.GetGuestOsInfo.IsSet() {
		localVarFormParams.Add("get_guest_os_info", parameterToString(localVarOptionals.GetGuestOsInfo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IgnoreGuestUuid.IsSet() {
		localVarFormParams.Add("ignore_guest_uuid", parameterToString(localVarOptionals.IgnoreGuestUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VmNotFound.IsSet() {
		localVarFormParams.Add("vm_not_found", parameterToString(localVarOptionals.VmNotFound.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TrackVmNameChange.IsSet() {
		localVarFormParams.Add("track_vm_name_change", parameterToString(localVarOptionals.TrackVmNameChange.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HostnamePrecedence.IsSet() {
		localVarFormParams.Add("hostname_precedence", parameterToString(localVarOptionals.HostnamePrecedence.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Hostidlist.IsSet() {
		localVarFormParams.Add("hostidlist", parameterToString(localVarOptionals.Hostidlist.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VmAddDisk.IsSet() {
		localVarFormParams.Add("vm_add_disk", parameterToString(localVarOptionals.VmAddDisk.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.HostAllowDuplicateSerials.IsSet() {
		localVarFormParams.Add("host_allow_duplicate_serials", parameterToString(localVarOptionals.HostAllowDuplicateSerials.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IgnoreHostSerial.IsSet() {
		localVarFormParams.Add("ignore_host_serial", parameterToString(localVarOptionals.IgnoreHostSerial.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IgnoreHostUuid.IsSet() {
		localVarFormParams.Add("ignore_host_uuid", parameterToString(localVarOptionals.IgnoreHostUuid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OverwriteObjectCategories.IsSet() {
		localVarFormParams.Add("overwrite_object_categories", parameterToString(localVarOptionals.OverwriteObjectCategories.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RemoteCollectorId.IsSet() {
		localVarFormParams.Add("remote_collector_id", parameterToString(localVarOptionals.RemoteCollectorId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UseServiceAccount.IsSet() {
		localVarFormParams.Add("use_service_account", parameterToString(localVarOptionals.UseServiceAccount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IgnoreIpv6.IsSet() {
		localVarFormParams.Add("ignore_ipv6", parameterToString(localVarOptionals.IgnoreIpv6.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IgnoreVirtSubtype.IsSet() {
		localVarFormParams.Add("ignore_virt_subtype", parameterToString(localVarOptionals.IgnoreVirtSubtype.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceNameFormat.IsSet() {
		localVarFormParams.Add("device_name_format", parameterToString(localVarOptionals.DeviceNameFormat.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DiscoverParts.IsSet() {
		localVarFormParams.Add("discover_parts", parameterToString(localVarOptionals.DiscoverParts.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CaptureHostsFile.IsSet() {
		localVarFormParams.Add("capture_hosts_file", parameterToString(localVarOptionals.CaptureHostsFile.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DiscoverSoftware.IsSet() {
		localVarFormParams.Add("discover_software", parameterToString(localVarOptionals.DiscoverSoftware.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InitialSoftwareType.IsSet() {
		localVarFormParams.Add("initial_software_type", parameterToString(localVarOptionals.InitialSoftwareType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DiscoverLinesOfCode.IsSet() {
		localVarFormParams.Add("discover_lines_of_code", parameterToString(localVarOptionals.DiscoverLinesOfCode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DiscoverServices.IsSet() {
		localVarFormParams.Add("discover_services", parameterToString(localVarOptionals.DiscoverServices.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DiscoverApplications.IsSet() {
		localVarFormParams.Add("discover_applications", parameterToString(localVarOptionals.DiscoverApplications.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StoreConfigFiles.IsSet() {
		localVarFormParams.Add("store_config_files", parameterToString(localVarOptionals.StoreConfigFiles.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DiscoverCloudid.IsSet() {
		localVarFormParams.Add("discover_cloudid", parameterToString(localVarOptionals.DiscoverCloudid.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CustomerId.IsSet() {
		localVarFormParams.Add("customer_id", parameterToString(localVarOptionals.CustomerId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VrfGroupId.IsSet() {
		localVarFormParams.Add("vrf_group_id", parameterToString(localVarOptionals.VrfGroupId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ServiceLevelDeviceId.IsSet() {
		localVarFormParams.Add("service_level_device_id", parameterToString(localVarOptionals.ServiceLevelDeviceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SudoRetry.IsSet() {
		localVarFormParams.Add("sudo_retry", parameterToString(localVarOptionals.SudoRetry.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AlternateSudo.IsSet() {
		localVarFormParams.Add("alternate_sudo", parameterToString(localVarOptionals.AlternateSudo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UseDomainServer.IsSet() {
		localVarFormParams.Add("use_domain_server", parameterToString(localVarOptionals.UseDomainServer.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LdapServer.IsSet() {
		localVarFormParams.Add("ldap_server", parameterToString(localVarOptionals.LdapServer.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UseFqdn.IsSet() {
		localVarFormParams.Add("use_fqdn", parameterToString(localVarOptionals.UseFqdn.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LdapFilterType.IsSet() {
		localVarFormParams.Add("ldap_filter_type", parameterToString(localVarOptionals.LdapFilterType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LdapUnpwdId.IsSet() {
		localVarFormParams.Add("ldap_unpwd_id", parameterToString(localVarOptionals.LdapUnpwdId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AlternateSudoPasswordId.IsSet() {
		localVarFormParams.Add("alternate_sudo_password_id", parameterToString(localVarOptionals.AlternateSudoPasswordId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PollingInterval.IsSet() {
		localVarFormParams.Add("polling_interval", parameterToString(localVarOptionals.PollingInterval.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EnableResourcesMonitoring.IsSet() {
		localVarFormParams.Add("enable_resources_monitoring", parameterToString(localVarOptionals.EnableResourcesMonitoring.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
AutoDiscoveryApiService Add Nmap auto-discovery job
Add Nmap auto-discovery job
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name name of the job
 * @param ipStart starting IP address
 * @param ipEnd ending IP address, use same as start for single address
 * @param remoteCollectorId D42 ID of the remote collector to use for this job.
 * @param optional nil or *AutoDiscoveryApiPostAutoDiscoverynmapOpts - Optional Parameters:
     * @param "Nameserver" (optional.String) -  IP/FQDA of name server
     * @param "OsDetection" (optional.String) -  Select yes to detect operating system.
     * @param "ServicesDetection" (optional.String) -  Select yes to detect services.
     * @param "ObjectCategory" (optional.String) -  Name of subnet category for discovered subnets
     * @param "NewObjectCategory" (optional.String) -  Update an existing object category.
     * @param "OverwriteDeviceCategories" (optional.String) -  Overwrite the object categories for existing discovered devices.&lt;br&gt;&lt;br&gt;Note - this is equivalent to the &#39;Overwrite existing object categories&#39; parameter shown in the D42 Nmap UI.
     * @param "Vrfgroup" (optional.String) -  Name of vrf group for discovered subnets
     * @param "VrfgroupId" (optional.String) -  D42 ID of group for discovered subnets
     * @param "Tags" (optional.String) -  Comma separated list of tags
     * @param "TagsRemove" (optional.String) -  Comma separated list of tags to remove
     * @param "ScheduleTime" (optional.String) -  Time in HH:MM format if you want to schedule the job. Note: Must be formatted as text NOT date. For multiple schedules, separate with a slash (/).
     * @param "ScheduleDays" (optional.String) -  Comma separated days of week, where Monday &#x3D; 0. e.g. 0,1,2 wil set the job for Mon, Tue and Wed. For multiple schedules, separate with a slash (/).

@return interface{}
*/

type AutoDiscoveryApiPostAutoDiscoverynmapOpts struct { 
	Nameserver optional.String
	OsDetection optional.String
	ServicesDetection optional.String
	ObjectCategory optional.String
	NewObjectCategory optional.String
	OverwriteDeviceCategories optional.String
	Vrfgroup optional.String
	VrfgroupId optional.String
	Tags optional.String
	TagsRemove optional.String
	ScheduleTime optional.String
	ScheduleDays optional.String
}

func (a *AutoDiscoveryApiService) PostAutoDiscoverynmap(ctx context.Context, name string, ipStart string, ipEnd string, remoteCollectorId string, localVarOptionals *AutoDiscoveryApiPostAutoDiscoverynmapOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/auto_discovery/nmap/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("name", parameterToString(name, ""))
	localVarFormParams.Add("ip_start", parameterToString(ipStart, ""))
	localVarFormParams.Add("ip_end", parameterToString(ipEnd, ""))
	localVarFormParams.Add("remote_collector_id", parameterToString(remoteCollectorId, ""))
	if localVarOptionals != nil && localVarOptionals.Nameserver.IsSet() {
		localVarFormParams.Add("nameserver", parameterToString(localVarOptionals.Nameserver.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OsDetection.IsSet() {
		localVarFormParams.Add("os_detection", parameterToString(localVarOptionals.OsDetection.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ServicesDetection.IsSet() {
		localVarFormParams.Add("services_detection", parameterToString(localVarOptionals.ServicesDetection.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectCategory.IsSet() {
		localVarFormParams.Add("object_category", parameterToString(localVarOptionals.ObjectCategory.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NewObjectCategory.IsSet() {
		localVarFormParams.Add("new_object_category", parameterToString(localVarOptionals.NewObjectCategory.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OverwriteDeviceCategories.IsSet() {
		localVarFormParams.Add("overwrite_device_categories", parameterToString(localVarOptionals.OverwriteDeviceCategories.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Vrfgroup.IsSet() {
		localVarFormParams.Add("vrfgroup", parameterToString(localVarOptionals.Vrfgroup.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VrfgroupId.IsSet() {
		localVarFormParams.Add("vrfgroup_id", parameterToString(localVarOptionals.VrfgroupId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tags.IsSet() {
		localVarFormParams.Add("tags", parameterToString(localVarOptionals.Tags.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TagsRemove.IsSet() {
		localVarFormParams.Add("tags_remove", parameterToString(localVarOptionals.TagsRemove.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScheduleTime.IsSet() {
		localVarFormParams.Add("schedule_time", parameterToString(localVarOptionals.ScheduleTime.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScheduleDays.IsSet() {
		localVarFormParams.Add("schedule_days", parameterToString(localVarOptionals.ScheduleDays.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
AutoDiscoveryApiService Execute blade autodiscovery job
Execute blade autodiscovery job. Required parameters: name or job_id
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param run yes to start
 * @param optional nil or *AutoDiscoveryApiPutAutoDiscoveryBladeDiscOpts - Optional Parameters:
     * @param "Name" (optional.String) -  name of the job - required if no job_id
     * @param "JobId" (optional.String) -  D42 ID for the job - required if no name

@return interface{}
*/

type AutoDiscoveryApiPutAutoDiscoveryBladeDiscOpts struct { 
	Name optional.String
	JobId optional.String
}

func (a *AutoDiscoveryApiService) PutAutoDiscoveryBladeDisc(ctx context.Context, run string, localVarOptionals *AutoDiscoveryApiPutAutoDiscoveryBladeDiscOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/auto_discovery/blade_disc/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarFormParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JobId.IsSet() {
		localVarFormParams.Add("job_id", parameterToString(localVarOptionals.JobId.Value(), ""))
	}
	localVarFormParams.Add("run", parameterToString(run, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
AutoDiscoveryApiService Execute Certificate job
Execute Certificate Auto Discovery Job
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param run yes to start
 * @param optional nil or *AutoDiscoveryApiPutAutoDiscoveryCertificateOpts - Optional Parameters:
     * @param "Name" (optional.String) -  name of the job - required if no job_id
     * @param "JobId" (optional.String) -  D42 ID for the job - required if no name

@return interface{}
*/

type AutoDiscoveryApiPutAutoDiscoveryCertificateOpts struct { 
	Name optional.String
	JobId optional.String
}

func (a *AutoDiscoveryApiService) PutAutoDiscoveryCertificate(ctx context.Context, run string, localVarOptionals *AutoDiscoveryApiPutAutoDiscoveryCertificateOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/auto_discovery/certificate/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarFormParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JobId.IsSet() {
		localVarFormParams.Add("job_id", parameterToString(localVarOptionals.JobId.Value(), ""))
	}
	localVarFormParams.Add("run", parameterToString(run, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
AutoDiscoveryApiService Execute Cloud job
Execute Cloud job
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param run yes to start
 * @param optional nil or *AutoDiscoveryApiPutAutoDiscoveryCloudaccountOpts - Optional Parameters:
     * @param "Name" (optional.String) -  name of the job - required if no job_id
     * @param "JobId" (optional.String) -  D42 ID for the job - required if no name

@return interface{}
*/

type AutoDiscoveryApiPutAutoDiscoveryCloudaccountOpts struct { 
	Name optional.String
	JobId optional.String
}

func (a *AutoDiscoveryApiService) PutAutoDiscoveryCloudaccount(ctx context.Context, run string, localVarOptionals *AutoDiscoveryApiPutAutoDiscoveryCloudaccountOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/auto_discovery/cloudaccount/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarFormParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JobId.IsSet() {
		localVarFormParams.Add("job_id", parameterToString(localVarOptionals.JobId.Value(), ""))
	}
	localVarFormParams.Add("run", parameterToString(run, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
AutoDiscoveryApiService Execute DNS job
Execute DNS Auto Discovery Job
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param jobId D42 ID for the job
 * @param run yes to start

@return interface{}
*/
func (a *AutoDiscoveryApiService) PutAutoDiscoveryDns(ctx context.Context, jobId string, run string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/auto_discovery/dns/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("job_id", parameterToString(jobId, ""))
	localVarFormParams.Add("run", parameterToString(run, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
AutoDiscoveryApiService Execute snmp autodiscovery job
Execute snmp autodiscovery job
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param jobId D42 ID for the job
 * @param run yes to start

@return interface{}
*/
func (a *AutoDiscoveryApiService) PutAutoDiscoveryIpmi(ctx context.Context, jobId string, run string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/auto_discovery/ipmi/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("job_id", parameterToString(jobId, ""))
	localVarFormParams.Add("run", parameterToString(run, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
AutoDiscoveryApiService Execute network job
Execute network job. Required parameters: name or job_id
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param run yes to start
 * @param optional nil or *AutoDiscoveryApiPutAutoDiscoveryNetworksOpts - Optional Parameters:
     * @param "Name" (optional.String) -  name of the job - required if no job_id
     * @param "JobId" (optional.String) -  D42 ID for the job - required if no name

@return interface{}
*/

type AutoDiscoveryApiPutAutoDiscoveryNetworksOpts struct { 
	Name optional.String
	JobId optional.String
}

func (a *AutoDiscoveryApiService) PutAutoDiscoveryNetworks(ctx context.Context, run string, localVarOptionals *AutoDiscoveryApiPutAutoDiscoveryNetworksOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/auto_discovery/networks/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarFormParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JobId.IsSet() {
		localVarFormParams.Add("job_id", parameterToString(localVarOptionals.JobId.Value(), ""))
	}
	localVarFormParams.Add("run", parameterToString(run, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
AutoDiscoveryApiService Execute pingsweep job
Execute pingsweep job. Required parameters: name or job_id
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param run yes to start
 * @param optional nil or *AutoDiscoveryApiPutAutoDiscoveryPingsweepOpts - Optional Parameters:
     * @param "Name" (optional.String) -  name of the job - required if no job_id
     * @param "JobId" (optional.String) -  D42 ID for the job - required if no name

@return interface{}
*/

type AutoDiscoveryApiPutAutoDiscoveryPingsweepOpts struct { 
	Name optional.String
	JobId optional.String
}

func (a *AutoDiscoveryApiService) PutAutoDiscoveryPingsweep(ctx context.Context, run string, localVarOptionals *AutoDiscoveryApiPutAutoDiscoveryPingsweepOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/auto_discovery/pingsweep/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarFormParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JobId.IsSet() {
		localVarFormParams.Add("job_id", parameterToString(localVarOptionals.JobId.Value(), ""))
	}
	localVarFormParams.Add("run", parameterToString(run, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
AutoDiscoveryApiService Execute power autodiscovery job
Execute power autodiscovery job
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param run yes to start
 * @param optional nil or *AutoDiscoveryApiPutAutoDiscoveryPowerDiscOpts - Optional Parameters:
     * @param "Name" (optional.String) -  name of the job - required if no job_id
     * @param "JobId" (optional.String) -  D42 ID for the job - required if no name

@return interface{}
*/

type AutoDiscoveryApiPutAutoDiscoveryPowerDiscOpts struct { 
	Name optional.String
	JobId optional.String
}

func (a *AutoDiscoveryApiService) PutAutoDiscoveryPowerDisc(ctx context.Context, run string, localVarOptionals *AutoDiscoveryApiPutAutoDiscoveryPowerDiscOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/auto_discovery/power_disc/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarFormParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JobId.IsSet() {
		localVarFormParams.Add("job_id", parameterToString(localVarOptionals.JobId.Value(), ""))
	}
	localVarFormParams.Add("run", parameterToString(run, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
AutoDiscoveryApiService Execute snmp autodiscovery job
Execute snmp autodiscovery job
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param run yes to start
 * @param optional nil or *AutoDiscoveryApiPutAutoDiscoverySnmpDiscOpts - Optional Parameters:
     * @param "Name" (optional.String) -  name of the job - required if no job_id
     * @param "JobId" (optional.String) -  D42 ID for the job - required if no name

@return interface{}
*/

type AutoDiscoveryApiPutAutoDiscoverySnmpDiscOpts struct { 
	Name optional.String
	JobId optional.String
}

func (a *AutoDiscoveryApiService) PutAutoDiscoverySnmpDisc(ctx context.Context, run string, localVarOptionals *AutoDiscoveryApiPutAutoDiscoverySnmpDiscOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/auto_discovery/snmp_disc/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarFormParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JobId.IsSet() {
		localVarFormParams.Add("job_id", parameterToString(localVarOptionals.JobId.Value(), ""))
	}
	localVarFormParams.Add("run", parameterToString(run, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
AutoDiscoveryApiService Execute UCS/ACI/Load Balancer autodiscovery job
Execute UCS/ACI/Load Balancer autodiscovery job
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param jobId D42 ID for the job
 * @param run yes to start

@return interface{}
*/
func (a *AutoDiscoveryApiService) PutAutoDiscoveryUcs(ctx context.Context, jobId string, run string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/auto_discovery/ucs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("job_id", parameterToString(jobId, ""))
	localVarFormParams.Add("run", parameterToString(run, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
AutoDiscoveryApiService Execute vserver job
Execute VServer job
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param run yes to start
 * @param optional nil or *AutoDiscoveryApiPutAutoDiscoveryVserverOpts - Optional Parameters:
     * @param "Name" (optional.String) -  name of the job - required if no job_id
     * @param "JobId" (optional.String) -  D42 ID for the job - required if no name

@return interface{}
*/

type AutoDiscoveryApiPutAutoDiscoveryVserverOpts struct { 
	Name optional.String
	JobId optional.String
}

func (a *AutoDiscoveryApiService) PutAutoDiscoveryVserver(ctx context.Context, run string, localVarOptionals *AutoDiscoveryApiPutAutoDiscoveryVserverOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/auto_discovery/vserver/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarFormParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JobId.IsSet() {
		localVarFormParams.Add("job_id", parameterToString(localVarOptionals.JobId.Value(), ""))
	}
	localVarFormParams.Add("run", parameterToString(run, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
AutoDiscoveryApiService Execute Nmap job
Execute nmap job. Required parameters: name or job_id
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param run yes to start
 * @param optional nil or *AutoDiscoveryApiPutAutoDiscoverynmapOpts - Optional Parameters:
     * @param "Name" (optional.String) -  name of the job - required if no job_id supplied
     * @param "JobId" (optional.String) -  D42 ID of the job - required if no name supplied

@return interface{}
*/

type AutoDiscoveryApiPutAutoDiscoverynmapOpts struct { 
	Name optional.String
	JobId optional.String
}

func (a *AutoDiscoveryApiService) PutAutoDiscoverynmap(ctx context.Context, run string, localVarOptionals *AutoDiscoveryApiPutAutoDiscoverynmapOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/auto_discovery/nmap/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarFormParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.JobId.IsSet() {
		localVarFormParams.Add("job_id", parameterToString(localVarOptionals.JobId.Value(), ""))
	}
	localVarFormParams.Add("run", parameterToString(run, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
