
/*
 * Device42 API
 *
 * <b><h2>API Overview</h2></b><br>Restful API are supported in Device42 as one of the primary methods of entering, editing and retrieving data.<br><br> The API documentation has samples in curl for now and we will be adding other programming languages in future. You can refer to our github repositories at https://github.com/device42 for some sample code in python.<br><br> The RESTful API's enforce the role-based security that is created with the Device42 app. If you want a user to have access via the API, but not via the UI - deselect 'Staff Status' for that user from UI Tools > Admins & Permissions > Administrators.<br><br>If you'd like to see your changes on our UI, please visit http://swaggerdemo.device42.com and use credentials 'guest:device42_rocks!'. Please be aware that every 30 minutes our database resets and all data entered with POST/PUT calls from this page will be lost.<br><br>If you have any questions/suggestions, please send us a note to support at device42.com below. <br><h2><a id = 'Sample_API_Code'><b>Sample API Code</b></a></h2> <b>Sample Code with API Calls in the Python and .Net Programming Languages.</b><br>The following programs written in the Python programming language are available at <a href= 'https://github.com/device42/Device42-AutoDiscovery-Scripts'>Device42 sample programs</a><br><ul><li>api-sample.py: Runs against a single Windows system and uploads info to device42 appliance.</li><li>ad-sample.py: Can run against Active directory computers, servers or a given list and upload discovered systems’ info to device42 appliance.</li><li>d42_api_linux_upload_sample_script.py: Runs on a single *nix based system and uploads info to device42 appliance.</li><li>sample-script-facter-facts-to-d42: Runs on puppet master and uploads nodes info from facter fact files to device42 appliance.</li><li>d42_api_solaris_sample_script.py: Runs on an individual solaris system and uploads info to device42 appliance.</li></ul>The csv2d42apis.py sample program shows how to create a CSV file of data to import into device42. It reads a CSV file, matches columns to arguments for APIs and sends data to device42 via POST or PUT. This program can be found at: <a href= 'https://github.com/device42/API_Helpers'> Device42 sample CSV importer</a>.<br><br>The Auto Discovery Client source code can be found at Device42 <a href='https://docs.device42.com/auto-discovery/'>Auto Discovery Client</a>. This is a .net program that uses the device42 Restful API’s to load the discovered data.<h2><a id = 'Response_Status_Messages'><b>Response & Status Messages</b></a></h2><b>Responses</b><br>The response to most POST calls will have the following format: <br>{'msg':['PartModel added/updated', 17, 'RAM Acme 123456', true, true], 'code':0}<br><br>Using the example above:<br>'17' = ID of the object<br>'RAM Acme 123456' = representation of the object<br> 'true, true' = object added and is new.<br>'true, false' = object updated.<br>'false, false' = no changes.<br><br><b>Status Codes</b><br><u>Code 0</u><br>Success! e.g. = {'msg': 'device added or updated', <b>code:0</b>}<br><br><u>'HTTP/1.1 200 OK'</u><br>Success! All other responses are errors and will display an error code e.g.: 400, 401, 403, 405, 410, 500, 503. These are explained in each call.<br><br>Please let us know if you notice something odd with a response and we will fix it! :) <h2><a id = 'Get_Limits_Offsets'><b>API Get Limits and Offsets</b></a></h2>In Device42’s global settings we have the option to enforce API GET limits and this setting is recommended for better performance. To set this value from Device42, go to Tools>Settings>Global Settings and the click Edit in the top right. Toward the bottom of the screen you will see the API section. First check the “Enforce API GET Limits” checkbox, then enter a value for API GET Limit. A good limit to start with is 500 or 1000, depending on the performance you experience.<br><br>After setting this limit all GET calls below can have the results augmented via “offset” and “limit” parameters to tell Device42 which value to start returning results from, and how many results to return at maximum.<br>Examples:<br><br>'/?limit=50' returns the first 50 results.<br><br> '/?offset=100' will start at the 101st result. <br><br>'/?offset=42&limit=42' returns 42 results, starting at the 43rd.<br><br> Note that offset is used for paging - that is, the offset is only applied when the total number of objects returned exceeds the limit that is returned.
 *
 * API version: 2.0
 * Contact: support@device42.com
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package swagger

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"fmt"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type PartsManagementApiService service

/* 
PartsManagementApiService Delete Part Model
This API is used to delete the part model with the part model id supplied as the required argument.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id part model id

@return interface{}
*/
func (a *PartsManagementApiService) DeletePartmodels(ctx context.Context, id int32) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/partmodels/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
PartsManagementApiService Delete Part
This API is used to delete the part with the part id supplied as the required argument.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id part id

@return interface{}
*/
func (a *PartsManagementApiService) DeleteParts(ctx context.Context, id int32) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/parts/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
PartsManagementApiService Get all Part Models - introduced in version 5.7.2
Get all Part Models
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *PartsManagementApiGetPartmodelsOpts - Optional Parameters:
     * @param "Name" (optional.String) -  filter by name (Added in v6.0.0)

@return Partmodels
*/

type PartsManagementApiGetPartmodelsOpts struct { 
	Name optional.String
}

func (a *PartsManagementApiService) GetPartmodels(ctx context.Context, localVarOptionals *PartsManagementApiGetPartmodelsOpts) (Partmodels, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Partmodels
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/partmodels/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Partmodels
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
PartsManagementApiService Get all Parts - introduced in version 5.7.2
Get all Parts
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *PartsManagementApiGetPartsOpts - Optional Parameters:
     * @param "Type_" (optional.String) -  type of the partmodel, cpu, mem, hdd for CPU, memory, and Harddisk. For others it must match the type name for part model
     * @param "Device" (optional.String) -  name of the device where part is checked out to
     * @param "DeviceId" (optional.String) -  id of the device where part is checked out to
     * @param "DeviceSerial" (optional.String) -  serial number of the device, where part is checked out to
     * @param "Room" (optional.String) -  name of the room where part is checked out to
     * @param "RoomId" (optional.String) -  id of the room where part is checked out to
     * @param "PartId" (optional.String) -  id of the part (added in v6.3.3)
     * @param "PartmodelId" (optional.String) -  id of the part model (added in v6.3.3)
     * @param "SerialNo" (optional.String) -  serial number of the part
     * @param "LastUpdatedLt" (optional.String) -  last updated less than date YYYY-MM-DD format
     * @param "LastUpdatedGt" (optional.String) -  last updated greater than date YYYY-MM-DD format
     * @param "RackId" (optional.String) -  id of the rack where part is checked out to
     * @param "Rack" (optional.String) -  name of the rack where part is checked out to
     * @param "AssetNo" (optional.String) -  filter by asset # (Added in v6.0.0)
     * @param "CustomFieldsAnd" (optional.String) -  filter by custom fields, and filter, format of key1:value1,key2:value2
     * @param "CustomFieldsOr" (optional.String) -  filter by custom fields, or filter, format of key1:value1,key2:value2
     * @param "Tags" (optional.String) -  filter by tags. comma separated for multiple tags (This is an OR filter, gets all the devices for all comma separated tags)

@return interface{}
*/

type PartsManagementApiGetPartsOpts struct { 
	Type_ optional.String
	Device optional.String
	DeviceId optional.String
	DeviceSerial optional.String
	Room optional.String
	RoomId optional.String
	PartId optional.String
	PartmodelId optional.String
	SerialNo optional.String
	LastUpdatedLt optional.String
	LastUpdatedGt optional.String
	RackId optional.String
	Rack optional.String
	AssetNo optional.String
	CustomFieldsAnd optional.String
	CustomFieldsOr optional.String
	Tags optional.String
}

func (a *PartsManagementApiService) GetParts(ctx context.Context, localVarOptionals *PartsManagementApiGetPartsOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/parts/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarQueryParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Device.IsSet() {
		localVarQueryParams.Add("device", parameterToString(localVarOptionals.Device.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceId.IsSet() {
		localVarQueryParams.Add("device_id", parameterToString(localVarOptionals.DeviceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceSerial.IsSet() {
		localVarQueryParams.Add("device_serial", parameterToString(localVarOptionals.DeviceSerial.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Room.IsSet() {
		localVarQueryParams.Add("room", parameterToString(localVarOptionals.Room.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RoomId.IsSet() {
		localVarQueryParams.Add("room_id", parameterToString(localVarOptionals.RoomId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PartId.IsSet() {
		localVarQueryParams.Add("part_id", parameterToString(localVarOptionals.PartId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PartmodelId.IsSet() {
		localVarQueryParams.Add("partmodel_id", parameterToString(localVarOptionals.PartmodelId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SerialNo.IsSet() {
		localVarQueryParams.Add("serial_no", parameterToString(localVarOptionals.SerialNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedLt.IsSet() {
		localVarQueryParams.Add("last_updated_lt", parameterToString(localVarOptionals.LastUpdatedLt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LastUpdatedGt.IsSet() {
		localVarQueryParams.Add("last_updated_gt", parameterToString(localVarOptionals.LastUpdatedGt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RackId.IsSet() {
		localVarQueryParams.Add("rack_id", parameterToString(localVarOptionals.RackId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Rack.IsSet() {
		localVarQueryParams.Add("rack", parameterToString(localVarOptionals.Rack.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AssetNo.IsSet() {
		localVarQueryParams.Add("asset_no", parameterToString(localVarOptionals.AssetNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CustomFieldsAnd.IsSet() {
		localVarQueryParams.Add("custom_fields_and", parameterToString(localVarOptionals.CustomFieldsAnd.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CustomFieldsOr.IsSet() {
		localVarQueryParams.Add("custom_fields_or", parameterToString(localVarOptionals.CustomFieldsOr.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tags.IsSet() {
		localVarQueryParams.Add("tags", parameterToString(localVarOptionals.Tags.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
PartsManagementApiService Create / Update Part Models - introduced in version 5.7.2
Create / Update Part Models
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *PartsManagementApiPostPartmodelsOpts - Optional Parameters:
     * @param "Type_" (optional.String) -  Part type - new or existing. Must be hdd or harddisk to update HDD model parameters (hddsize, hddtype, etc)
     * @param "Name" (optional.String) -  name of part model - new or existing
     * @param "Description" (optional.String) - 
     * @param "PartmodelId" (optional.String) -  use for updating existing part model
     * @param "Modelno" (optional.String) -  Model # of the part model
     * @param "Partno" (optional.String) -  Part # of the part model
     * @param "Manufacturer" (optional.String) -  name of the hardware/software manufacturer.
     * @param "MediaType" (optional.String) -  Type of media
     * @param "ConnectorType" (optional.String) -  Type of connector, ie rj45
     * @param "Length" (optional.String) -  Cable length
     * @param "Connectivity" (optional.String) -  New or existing (not used for CPU, RAM, HDD)
     * @param "TotalCount" (optional.String) - 
     * @param "Location" (optional.String) -  Location/region of instance deployment
     * @param "Notes" (optional.String) -  Any additional notes
     * @param "Cores" (optional.String) -  number of cores
     * @param "Cpuspeed" (optional.String) -  enter in MHZ, e.g.: 3.5 GHZ use 3500
     * @param "Threads" (optional.String) -  number of threads
     * @param "Ramsize" (optional.String) -  enter in MB, e.g.: 8 GB enter 8192
     * @param "Ramtype" (optional.String) -  e.g.: DDR3
     * @param "Ramspeed" (optional.String) -  e.g.: 1600
     * @param "Hddsize" (optional.String) -  enter in GB, e.g.: 250 GB enter 250
     * @param "Hddtype" (optional.String) -  new or existing
     * @param "Hddrpm" (optional.String) -  new or existing

@return interface{}
*/

type PartsManagementApiPostPartmodelsOpts struct { 
	Type_ optional.String
	Name optional.String
	Description optional.String
	PartmodelId optional.String
	Modelno optional.String
	Partno optional.String
	Manufacturer optional.String
	MediaType optional.String
	ConnectorType optional.String
	Length optional.String
	Connectivity optional.String
	TotalCount optional.String
	Location optional.String
	Notes optional.String
	Cores optional.String
	Cpuspeed optional.String
	Threads optional.String
	Ramsize optional.String
	Ramtype optional.String
	Ramspeed optional.String
	Hddsize optional.String
	Hddtype optional.String
	Hddrpm optional.String
}

func (a *PartsManagementApiService) PostPartmodels(ctx context.Context, localVarOptionals *PartsManagementApiPostPartmodelsOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/partmodels/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarFormParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarFormParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarFormParams.Add("description", parameterToString(localVarOptionals.Description.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PartmodelId.IsSet() {
		localVarFormParams.Add("partmodel_id", parameterToString(localVarOptionals.PartmodelId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Modelno.IsSet() {
		localVarFormParams.Add("modelno", parameterToString(localVarOptionals.Modelno.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Partno.IsSet() {
		localVarFormParams.Add("partno", parameterToString(localVarOptionals.Partno.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Manufacturer.IsSet() {
		localVarFormParams.Add("manufacturer", parameterToString(localVarOptionals.Manufacturer.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MediaType.IsSet() {
		localVarFormParams.Add("media_type", parameterToString(localVarOptionals.MediaType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ConnectorType.IsSet() {
		localVarFormParams.Add("connector_type", parameterToString(localVarOptionals.ConnectorType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Length.IsSet() {
		localVarFormParams.Add("length", parameterToString(localVarOptionals.Length.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Connectivity.IsSet() {
		localVarFormParams.Add("connectivity", parameterToString(localVarOptionals.Connectivity.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TotalCount.IsSet() {
		localVarFormParams.Add("total_count", parameterToString(localVarOptionals.TotalCount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Location.IsSet() {
		localVarFormParams.Add("location", parameterToString(localVarOptionals.Location.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Notes.IsSet() {
		localVarFormParams.Add("notes", parameterToString(localVarOptionals.Notes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cores.IsSet() {
		localVarFormParams.Add("cores", parameterToString(localVarOptionals.Cores.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cpuspeed.IsSet() {
		localVarFormParams.Add("cpuspeed", parameterToString(localVarOptionals.Cpuspeed.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Threads.IsSet() {
		localVarFormParams.Add("threads", parameterToString(localVarOptionals.Threads.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Ramsize.IsSet() {
		localVarFormParams.Add("ramsize", parameterToString(localVarOptionals.Ramsize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Ramtype.IsSet() {
		localVarFormParams.Add("ramtype", parameterToString(localVarOptionals.Ramtype.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Ramspeed.IsSet() {
		localVarFormParams.Add("ramspeed", parameterToString(localVarOptionals.Ramspeed.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Hddsize.IsSet() {
		localVarFormParams.Add("hddsize", parameterToString(localVarOptionals.Hddsize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Hddtype.IsSet() {
		localVarFormParams.Add("hddtype", parameterToString(localVarOptionals.Hddtype.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Hddrpm.IsSet() {
		localVarFormParams.Add("hddrpm", parameterToString(localVarOptionals.Hddrpm.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
PartsManagementApiService Create / Update Parts - introduced in version 5.7.2
Create / Update Parts
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *PartsManagementApiPostPartsOpts - Optional Parameters:
     * @param "Type_" (optional.String) -  Part type - new or existing. Must be hdd or harddisk to update HDD model parameters (hddsize, hddtype, etc)
     * @param "Name" (optional.String) -  name of part model - new or existing
     * @param "Count" (optional.Int32) -  number of parts
     * @param "PartId" (optional.String) -  Use for updating existing part
     * @param "PartmodelId" (optional.String) - 
     * @param "SerialNo" (optional.String) -  Use for updating existing part. Caution: will update first matching serial if multiple parts with same serial exist. Use part_id or partmodel_id to uniquely identify.
     * @param "Firmware" (optional.String) - 
     * @param "Assignment" (optional.String) -  room, device, rma - required if assigning device
     * @param "Room" (optional.String) -  Room name - required if assigned to room
     * @param "Device" (optional.String) -  Room name - required if assigned to device
     * @param "DateChanged" (optional.String) -  Update the Date Changed field, using format YYYY-MM-DD HH:MM:SS
     * @param "Description" (optional.String) - 
     * @param "Cores" (optional.String) -  number of cores
     * @param "Cpuspeed" (optional.String) -  enter in MHZ, e.g.: 3.5 GHZ use 3500
     * @param "Threads" (optional.String) -  number of threads
     * @param "Ramsize" (optional.String) -  enter in MB, e.g.: 8 GB enter 8192
     * @param "Ramtype" (optional.String) -  e.g.: DDR3
     * @param "Ramspeed" (optional.String) -  e.g.: 1600
     * @param "Hddsize" (optional.String) -  enter in GB, e.g.: 250 GB enter 250
     * @param "Hddtype" (optional.String) -  new or existing
     * @param "Hddrpm" (optional.String) -  new or existing
     * @param "RaidType" (optional.String) -  type of RAID
     * @param "RaidGroup" (optional.String) -  RAID group name

@return interface{}
*/

type PartsManagementApiPostPartsOpts struct { 
	Type_ optional.String
	Name optional.String
	Count optional.Int32
	PartId optional.String
	PartmodelId optional.String
	SerialNo optional.String
	Firmware optional.String
	Assignment optional.String
	Room optional.String
	Device optional.String
	DateChanged optional.String
	Description optional.String
	Cores optional.String
	Cpuspeed optional.String
	Threads optional.String
	Ramsize optional.String
	Ramtype optional.String
	Ramspeed optional.String
	Hddsize optional.String
	Hddtype optional.String
	Hddrpm optional.String
	RaidType optional.String
	RaidGroup optional.String
}

func (a *PartsManagementApiService) PostParts(ctx context.Context, localVarOptionals *PartsManagementApiPostPartsOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/parts/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarFormParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarFormParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Count.IsSet() {
		localVarFormParams.Add("count", parameterToString(localVarOptionals.Count.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PartId.IsSet() {
		localVarFormParams.Add("part_id", parameterToString(localVarOptionals.PartId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PartmodelId.IsSet() {
		localVarFormParams.Add("partmodel_id", parameterToString(localVarOptionals.PartmodelId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SerialNo.IsSet() {
		localVarFormParams.Add("serial_no", parameterToString(localVarOptionals.SerialNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Firmware.IsSet() {
		localVarFormParams.Add("firmware", parameterToString(localVarOptionals.Firmware.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Assignment.IsSet() {
		localVarFormParams.Add("assignment", parameterToString(localVarOptionals.Assignment.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Room.IsSet() {
		localVarFormParams.Add("room", parameterToString(localVarOptionals.Room.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Device.IsSet() {
		localVarFormParams.Add("device", parameterToString(localVarOptionals.Device.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DateChanged.IsSet() {
		localVarFormParams.Add("date_changed", parameterToString(localVarOptionals.DateChanged.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarFormParams.Add("description", parameterToString(localVarOptionals.Description.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cores.IsSet() {
		localVarFormParams.Add("cores", parameterToString(localVarOptionals.Cores.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Cpuspeed.IsSet() {
		localVarFormParams.Add("cpuspeed", parameterToString(localVarOptionals.Cpuspeed.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Threads.IsSet() {
		localVarFormParams.Add("threads", parameterToString(localVarOptionals.Threads.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Ramsize.IsSet() {
		localVarFormParams.Add("ramsize", parameterToString(localVarOptionals.Ramsize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Ramtype.IsSet() {
		localVarFormParams.Add("ramtype", parameterToString(localVarOptionals.Ramtype.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Ramspeed.IsSet() {
		localVarFormParams.Add("ramspeed", parameterToString(localVarOptionals.Ramspeed.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Hddsize.IsSet() {
		localVarFormParams.Add("hddsize", parameterToString(localVarOptionals.Hddsize.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Hddtype.IsSet() {
		localVarFormParams.Add("hddtype", parameterToString(localVarOptionals.Hddtype.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Hddrpm.IsSet() {
		localVarFormParams.Add("hddrpm", parameterToString(localVarOptionals.Hddrpm.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RaidType.IsSet() {
		localVarFormParams.Add("raid_type", parameterToString(localVarOptionals.RaidType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RaidGroup.IsSet() {
		localVarFormParams.Add("raid_group", parameterToString(localVarOptionals.RaidGroup.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
PartsManagementApiService Create/update existing custom fields for parts.
Create/updated custom fields for parts.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id ID of part.
 * @param key Can be new or existing. This is the custom field name.
 * @param optional nil or *PartsManagementApiPutCustomFieldPartOpts - Optional Parameters:
     * @param "Type_" (optional.String) -  this is the custom field type. If left blank, default is text. Date should be formatted as YYYY-MM-DD
     * @param "RelatedFieldName" (optional.String) -  Required if type &#x3D; related field.
     * @param "AddToPicklist" (optional.String) -  Comma separated values to add to picklist. If type is picklist and custom field is new, this is a required field. Duplicates will be ignored.
     * @param "Value" (optional.String) -  This will set the value of the custom field for the specific object.
     * @param "ClearValue" (optional.String) -  yes to clear existing value for that field
     * @param "Notes" (optional.String) -  Any additional notes
     * @param "ClearNotes" (optional.String) -  Yes to clear any existing notes.
     * @param "BulkFields" (optional.String) -  comma separated key value pairs, with key and value separated by colon. e.g.key1:value1, key2:value2

@return interface{}
*/

type PartsManagementApiPutCustomFieldPartOpts struct { 
	Type_ optional.String
	RelatedFieldName optional.String
	AddToPicklist optional.String
	Value optional.String
	ClearValue optional.String
	Notes optional.String
	ClearNotes optional.String
	BulkFields optional.String
}

func (a *PartsManagementApiService) PutCustomFieldPart(ctx context.Context, id string, key string, localVarOptionals *PartsManagementApiPutCustomFieldPartOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/custom_fields/part/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("id", parameterToString(id, ""))
	localVarFormParams.Add("key", parameterToString(key, ""))
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarFormParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RelatedFieldName.IsSet() {
		localVarFormParams.Add("related_field_name", parameterToString(localVarOptionals.RelatedFieldName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AddToPicklist.IsSet() {
		localVarFormParams.Add("add_to_picklist", parameterToString(localVarOptionals.AddToPicklist.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Value.IsSet() {
		localVarFormParams.Add("value", parameterToString(localVarOptionals.Value.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ClearValue.IsSet() {
		localVarFormParams.Add("clear_value", parameterToString(localVarOptionals.ClearValue.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Notes.IsSet() {
		localVarFormParams.Add("notes", parameterToString(localVarOptionals.Notes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ClearNotes.IsSet() {
		localVarFormParams.Add("clear_notes", parameterToString(localVarOptionals.ClearNotes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BulkFields.IsSet() {
		localVarFormParams.Add("bulk_fields", parameterToString(localVarOptionals.BulkFields.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
PartsManagementApiService Create/update custom fields for Part Models.
Custom Fields
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id ID of part.
 * @param key Can be new or existing. This is the custom field name.
 * @param optional nil or *PartsManagementApiPutCustomFieldPartmodelOpts - Optional Parameters:
     * @param "Type_" (optional.String) -  this is the custom field type. If left blank, default is text. Date should be formatted as YYYY-MM-DD
     * @param "RelatedFieldName" (optional.String) -  Required if type &#x3D; related field.
     * @param "AddToPicklist" (optional.String) -  Comma separated values to add to picklist. If type is picklist and custom field is new, this is a required field. Duplicates will be ignored.
     * @param "Value" (optional.String) -  This will set the value of the custom field for the specific object.
     * @param "ClearValue" (optional.String) -  yes to clear existing value for that field
     * @param "Notes" (optional.String) -  Any additional notes
     * @param "ClearNotes" (optional.String) -  Yes to clear any existing notes.
     * @param "BulkFields" (optional.String) -  comma separated key value pairs, with key and value separated by colon. e.g.key1:value1, key2:value2

@return interface{}
*/

type PartsManagementApiPutCustomFieldPartmodelOpts struct { 
	Type_ optional.String
	RelatedFieldName optional.String
	AddToPicklist optional.String
	Value optional.String
	ClearValue optional.String
	Notes optional.String
	ClearNotes optional.String
	BulkFields optional.String
}

func (a *PartsManagementApiService) PutCustomFieldPartmodel(ctx context.Context, id string, key string, localVarOptionals *PartsManagementApiPutCustomFieldPartmodelOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/custom_fields/partmodel/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("id", parameterToString(id, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("key", parameterToString(key, ""))
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarFormParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RelatedFieldName.IsSet() {
		localVarFormParams.Add("related_field_name", parameterToString(localVarOptionals.RelatedFieldName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AddToPicklist.IsSet() {
		localVarFormParams.Add("add_to_picklist", parameterToString(localVarOptionals.AddToPicklist.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Value.IsSet() {
		localVarFormParams.Add("value", parameterToString(localVarOptionals.Value.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ClearValue.IsSet() {
		localVarFormParams.Add("clear_value", parameterToString(localVarOptionals.ClearValue.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Notes.IsSet() {
		localVarFormParams.Add("notes", parameterToString(localVarOptionals.Notes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ClearNotes.IsSet() {
		localVarFormParams.Add("clear_notes", parameterToString(localVarOptionals.ClearNotes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BulkFields.IsSet() {
		localVarFormParams.Add("bulk_fields", parameterToString(localVarOptionals.BulkFields.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
