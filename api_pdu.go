
/*
 * Device42 API
 *
 * <b><h2>API Overview</h2></b><br>Restful API are supported in Device42 as one of the primary methods of entering, editing and retrieving data.<br><br> The API documentation has samples in curl for now and we will be adding other programming languages in future. You can refer to our github repositories at https://github.com/device42 for some sample code in python.<br><br> The RESTful API's enforce the role-based security that is created with the Device42 app. If you want a user to have access via the API, but not via the UI - deselect 'Staff Status' for that user from UI Tools > Admins & Permissions > Administrators.<br><br>If you'd like to see your changes on our UI, please visit http://swaggerdemo.device42.com and use credentials 'guest:device42_rocks!'. Please be aware that every 30 minutes our database resets and all data entered with POST/PUT calls from this page will be lost.<br><br>If you have any questions/suggestions, please send us a note to support at device42.com below. <br><h2><a id = 'Sample_API_Code'><b>Sample API Code</b></a></h2> <b>Sample Code with API Calls in the Python and .Net Programming Languages.</b><br>The following programs written in the Python programming language are available at <a href= 'https://github.com/device42/Device42-AutoDiscovery-Scripts'>Device42 sample programs</a><br><ul><li>api-sample.py: Runs against a single Windows system and uploads info to device42 appliance.</li><li>ad-sample.py: Can run against Active directory computers, servers or a given list and upload discovered systems’ info to device42 appliance.</li><li>d42_api_linux_upload_sample_script.py: Runs on a single *nix based system and uploads info to device42 appliance.</li><li>sample-script-facter-facts-to-d42: Runs on puppet master and uploads nodes info from facter fact files to device42 appliance.</li><li>d42_api_solaris_sample_script.py: Runs on an individual solaris system and uploads info to device42 appliance.</li></ul>The csv2d42apis.py sample program shows how to create a CSV file of data to import into device42. It reads a CSV file, matches columns to arguments for APIs and sends data to device42 via POST or PUT. This program can be found at: <a href= 'https://github.com/device42/API_Helpers'> Device42 sample CSV importer</a>.<br><br>The Auto Discovery Client source code can be found at Device42 <a href='https://docs.device42.com/auto-discovery/'>Auto Discovery Client</a>. This is a .net program that uses the device42 Restful API’s to load the discovered data.<h2><a id = 'Response_Status_Messages'><b>Response & Status Messages</b></a></h2><b>Responses</b><br>The response to most POST calls will have the following format: <br>{'msg':['PartModel added/updated', 17, 'RAM Acme 123456', true, true], 'code':0}<br><br>Using the example above:<br>'17' = ID of the object<br>'RAM Acme 123456' = representation of the object<br> 'true, true' = object added and is new.<br>'true, false' = object updated.<br>'false, false' = no changes.<br><br><b>Status Codes</b><br><u>Code 0</u><br>Success! e.g. = {'msg': 'device added or updated', <b>code:0</b>}<br><br><u>'HTTP/1.1 200 OK'</u><br>Success! All other responses are errors and will display an error code e.g.: 400, 401, 403, 405, 410, 500, 503. These are explained in each call.<br><br>Please let us know if you notice something odd with a response and we will fix it! :) <h2><a id = 'Get_Limits_Offsets'><b>API Get Limits and Offsets</b></a></h2>In Device42’s global settings we have the option to enforce API GET limits and this setting is recommended for better performance. To set this value from Device42, go to Tools>Settings>Global Settings and the click Edit in the top right. Toward the bottom of the screen you will see the API section. First check the “Enforce API GET Limits” checkbox, then enter a value for API GET Limit. A good limit to start with is 500 or 1000, depending on the performance you experience.<br><br>After setting this limit all GET calls below can have the results augmented via “offset” and “limit” parameters to tell Device42 which value to start returning results from, and how many results to return at maximum.<br>Examples:<br><br>'/?limit=50' returns the first 50 results.<br><br> '/?offset=100' will start at the 101st result. <br><br>'/?offset=42&limit=42' returns 42 results, starting at the 43rd.<br><br> Note that offset is used for paging - that is, the offset is only applied when the total number of objects returned exceeds the limit that is returned.
 *
 * API version: 2.0
 * Contact: support@device42.com
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package swagger

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"fmt"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type PDUApiService service

/* 
PDUApiService Delete PDU
This API is used to delete the pdu with the pdu id supplied as the required argument.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param iD PDU id

@return interface{}
*/
func (a *PDUApiService) DeletePdus(ctx context.Context, iD int32) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/pdus/{ID}/"
	localVarPath = strings.Replace(localVarPath, "{"+"ID"+"}", fmt.Sprintf("%v", iD), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
PDUApiService Delete PDU from a rack
This API is used to delete from its rack the device with the device id supplied as the required argument. (The device itself is not deleted).
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id device id

@return interface{}
*/
func (a *PDUApiService) DeletePdusRack(ctx context.Context, id string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/pdus/rack/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
PDUApiService GET method retrieves all PDU Models.
Get all PDU Models
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *PDUApiGetPduModelsOpts - Optional Parameters:
     * @param "Name" (optional.String) -  filter by model name
     * @param "PduModelId" (optional.Int32) -  filter by pdu model id

@return interface{}
*/

type PDUApiGetPduModelsOpts struct { 
	Name optional.String
	PduModelId optional.Int32
}

func (a *PDUApiService) GetPduModels(ctx context.Context, localVarOptionals *PDUApiGetPduModelsOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/pdu_models/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PduModelId.IsSet() {
		localVarQueryParams.Add("pdu_model_id", parameterToString(localVarOptionals.PduModelId.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
PDUApiService GET method retrieves all PDUs.
Get all PDUs
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *PDUApiGetPdusOpts - Optional Parameters:
     * @param "Name" (optional.String) -  filter by name
     * @param "Type_" (optional.String) -  filter by type
     * @param "PduModelId" (optional.Int32) -  filter by PDU model ID
     * @param "PduModel" (optional.String) -  filter by PDU model name
     * @param "BuildingId" (optional.Int32) -  filter by building id
     * @param "RoomId" (optional.Int32) -  filter by room id
     * @param "RackId" (optional.Int32) -  filter by rack id
     * @param "SerialNo" (optional.String) -  filter by PDU serial_no
     * @param "DeviceId" (optional.Int32) -  filter by device id

@return interface{}
*/

type PDUApiGetPdusOpts struct { 
	Name optional.String
	Type_ optional.String
	PduModelId optional.Int32
	PduModel optional.String
	BuildingId optional.Int32
	RoomId optional.Int32
	RackId optional.Int32
	SerialNo optional.String
	DeviceId optional.Int32
}

func (a *PDUApiService) GetPdus(ctx context.Context, localVarOptionals *PDUApiGetPdusOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/pdus/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarQueryParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PduModelId.IsSet() {
		localVarQueryParams.Add("pdu_model_id", parameterToString(localVarOptionals.PduModelId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PduModel.IsSet() {
		localVarQueryParams.Add("pdu_model", parameterToString(localVarOptionals.PduModel.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BuildingId.IsSet() {
		localVarQueryParams.Add("building_id", parameterToString(localVarOptionals.BuildingId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RoomId.IsSet() {
		localVarQueryParams.Add("room_id", parameterToString(localVarOptionals.RoomId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RackId.IsSet() {
		localVarQueryParams.Add("rack_id", parameterToString(localVarOptionals.RackId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SerialNo.IsSet() {
		localVarQueryParams.Add("serial_no", parameterToString(localVarOptionals.SerialNo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceId.IsSet() {
		localVarQueryParams.Add("device_id", parameterToString(localVarOptionals.DeviceId.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
PDUApiService Get PDU by ID
Retrieve detailed information about a specific PDU by PDU ID. This also includes end point connections.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param iD The ID of the PDU to retrieve

@return PduById
*/
func (a *PDUApiService) GetPdusID(ctx context.Context, iD int32) (PduById, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PduById
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/pdus/{ID}/"
	localVarPath = strings.Replace(localVarPath, "{"+"ID"+"}", fmt.Sprintf("%v", iD), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v PduById
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
PDUApiService Create / Update PDU Models.
Create / Update PDU Models
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *PDUApiPostPduModelsOpts - Optional Parameters:
     * @param "PduModelId" (optional.String) -  ID of the PDU model you want to update
     * @param "Name" (optional.String) -  Name of the PDU model you want to create or update
     * @param "Manufacturer" (optional.String) -  name of the hardware/software manufacturer.
     * @param "Size" (optional.String) -  Size of the PDU in U
     * @param "SequentialNumberingForPorts" (optional.String) -  Could be “yes” or “no”. Yes if ports are numbered starting from 1.
     * @param "Depth" (optional.String) -  Half depth by default. full to override. Optional.
     * @param "ImgfileId" (optional.String) -  image file id. You can see these from Tools &gt; Import &gt; Hardware Import for now.
     * @param "Imgfile" (optional.String) -  name of the image file (Added in v5.8.2). Use instead of imgfile_id
     * @param "BackImageId" (optional.String) -  back image file id. You can see these from Tools &gt; Import &gt; Hardware Import for now.
     * @param "BackImage" (optional.String) -  name of the back image file. Use instead of back_image_id.

@return interface{}
*/

type PDUApiPostPduModelsOpts struct { 
	PduModelId optional.String
	Name optional.String
	Manufacturer optional.String
	Size optional.String
	SequentialNumberingForPorts optional.String
	Depth optional.String
	ImgfileId optional.String
	Imgfile optional.String
	BackImageId optional.String
	BackImage optional.String
}

func (a *PDUApiService) PostPduModels(ctx context.Context, localVarOptionals *PDUApiPostPduModelsOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/pdu_models/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.PduModelId.IsSet() {
		localVarFormParams.Add("pdu_model_id", parameterToString(localVarOptionals.PduModelId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarFormParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Manufacturer.IsSet() {
		localVarFormParams.Add("manufacturer", parameterToString(localVarOptionals.Manufacturer.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Size.IsSet() {
		localVarFormParams.Add("size", parameterToString(localVarOptionals.Size.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SequentialNumberingForPorts.IsSet() {
		localVarFormParams.Add("sequential_numbering_for_ports", parameterToString(localVarOptionals.SequentialNumberingForPorts.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Depth.IsSet() {
		localVarFormParams.Add("depth", parameterToString(localVarOptionals.Depth.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ImgfileId.IsSet() {
		localVarFormParams.Add("imgfile_id", parameterToString(localVarOptionals.ImgfileId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Imgfile.IsSet() {
		localVarFormParams.Add("imgfile", parameterToString(localVarOptionals.Imgfile.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BackImageId.IsSet() {
		localVarFormParams.Add("back_image_id", parameterToString(localVarOptionals.BackImageId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BackImage.IsSet() {
		localVarFormParams.Add("back_image", parameterToString(localVarOptionals.BackImage.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
PDUApiService Create PDU Model Ports.
Create PDU Model Ports. Required parameters: &lt;ul&gt;&lt;li&gt;pdu_model_id &lt;b&gt;OR&lt;/b&gt; pdu_model_name&lt;/li&gt; &lt;li&gt;count&lt;/li&gt; &lt;li&gt;type&lt;/li&gt;&lt;/ul&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param count number of ports
 * @param type_ Type of the port. If not already existing, a new port type is created.
 * @param optional nil or *PDUApiPostPduModelsPortsOpts - Optional Parameters:
     * @param "PduModelId" (optional.String) -  ID of the PDU model you want to update
     * @param "PduModelName" (optional.String) -  Name of the PDU model you want to add ports to.

@return interface{}
*/

type PDUApiPostPduModelsPortsOpts struct { 
	PduModelId optional.String
	PduModelName optional.String
}

func (a *PDUApiService) PostPduModelsPorts(ctx context.Context, count int32, type_ string, localVarOptionals *PDUApiPostPduModelsPortsOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/pdu_models/ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.PduModelId.IsSet() {
		localVarFormParams.Add("pdu_model_id", parameterToString(localVarOptionals.PduModelId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PduModelName.IsSet() {
		localVarFormParams.Add("pdu_model_name", parameterToString(localVarOptionals.PduModelName.Value(), ""))
	}
	localVarFormParams.Add("count", parameterToString(count, ""))
	localVarFormParams.Add("type", parameterToString(type_, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
PDUApiService This call will create PDUs.
Create PDUs
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name PDU name
 * @param optional nil or *PDUApiPostPdusOpts - Optional Parameters:
     * @param "PduModelId" (optional.String) -  ID of the PDU model you want to update
     * @param "PduModel" (optional.String) -  Name of the PDU model. You can use this instead of the ID above. (Added in v5.8.2)
     * @param "Device" (optional.String) -  If you want to associate asset information with this PDU, use device type &#39;other&#39;
     * @param "Notes" (optional.String) -  Any additional notes
     * @param "Category" (optional.String) -  If multitenancy is on, admin groups that have access to this object are specified here, e.g. Prod_East:no, Corp:yes specifies that the admin groups for this object are Prod_East with view only permission and Corp with change permission. Use for initial insert.

@return interface{}
*/

type PDUApiPostPdusOpts struct { 
	PduModelId optional.String
	PduModel optional.String
	Device optional.String
	Notes optional.String
	Category optional.String
}

func (a *PDUApiService) PostPdus(ctx context.Context, name string, localVarOptionals *PDUApiPostPdusOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/pdus/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("name", parameterToString(name, ""))
	if localVarOptionals != nil && localVarOptionals.PduModelId.IsSet() {
		localVarFormParams.Add("pdu_model_id", parameterToString(localVarOptionals.PduModelId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PduModel.IsSet() {
		localVarFormParams.Add("pdu_model", parameterToString(localVarOptionals.PduModel.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Device.IsSet() {
		localVarFormParams.Add("device", parameterToString(localVarOptionals.Device.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Notes.IsSet() {
		localVarFormParams.Add("notes", parameterToString(localVarOptionals.Notes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Category.IsSet() {
		localVarFormParams.Add("category", parameterToString(localVarOptionals.Category.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
PDUApiService Update PDU Ports w/ no names
Assign a name and/or an object (see below) objects to a pdu port. It will pick the lowest port id # available (or first available port in order created).
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param portType Verbose name of the port type. Must exist already.
 * @param optional nil or *PDUApiPostPdusPortsOpts - Optional Parameters:
     * @param "ParentPduId" (optional.String) -  Available from /api/api/1.0/pdus/ or Tools
     * @param "ParentPdu" (optional.String) -  name of the parent PDU. Must be unique name. Added in v5.8.2
     * @param "Device" (optional.String) -  Name of the device the port points to.
     * @param "DeviceId" (optional.String) -  ID of the device the port points to
     * @param "PduId" (optional.String) -  ID of the PDU the port points to
     * @param "AssetId" (optional.String) -  ID of the asset the port points to
     * @param "Name" (optional.String) -  PDU port name, typically the PDU port number when autodiscovered.
     * @param "OutletName" (optional.String) -  outlet name
     * @param "Watts" (optional.String) -  per power supply
     * @param "PsuLabel" (optional.String) -  typically used when device has multiple power supplies, e.g.: power supply 1, power supply 2, etc.

@return interface{}
*/

type PDUApiPostPdusPortsOpts struct { 
	ParentPduId optional.String
	ParentPdu optional.String
	Device optional.String
	DeviceId optional.String
	PduId optional.String
	AssetId optional.String
	Name optional.String
	OutletName optional.String
	Watts optional.String
	PsuLabel optional.String
}

func (a *PDUApiService) PostPdusPorts(ctx context.Context, portType string, localVarOptionals *PDUApiPostPdusPortsOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/pdus/ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ParentPduId.IsSet() {
		localVarFormParams.Add("parent_pdu_id", parameterToString(localVarOptionals.ParentPduId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ParentPdu.IsSet() {
		localVarFormParams.Add("parent_pdu", parameterToString(localVarOptionals.ParentPdu.Value(), ""))
	}
	localVarFormParams.Add("port_type", parameterToString(portType, ""))
	if localVarOptionals != nil && localVarOptionals.Device.IsSet() {
		localVarFormParams.Add("device", parameterToString(localVarOptionals.Device.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceId.IsSet() {
		localVarFormParams.Add("device_id", parameterToString(localVarOptionals.DeviceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PduId.IsSet() {
		localVarFormParams.Add("pdu_id", parameterToString(localVarOptionals.PduId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AssetId.IsSet() {
		localVarFormParams.Add("asset_id", parameterToString(localVarOptionals.AssetId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarFormParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OutletName.IsSet() {
		localVarFormParams.Add("outlet_name", parameterToString(localVarOptionals.OutletName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Watts.IsSet() {
		localVarFormParams.Add("watts", parameterToString(localVarOptionals.Watts.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PsuLabel.IsSet() {
		localVarFormParams.Add("psu_label", parameterToString(localVarOptionals.PsuLabel.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
PDUApiService This call will add / update PDUs in or around a Rack.
Add / Update PDUs in Racks
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *PDUApiPostPdusRackOpts - Optional Parameters:
     * @param "PduId" (optional.String) -  ID of the PDU to be edited
     * @param "Pdu" (optional.String) -  name of the PDU. only works if the name is unique in the system
     * @param "RackId" (optional.String) -  This is the ID of the rack. It can be obtained from Tools &gt; Import &gt; Import Racked Devices or /api/api/1.0/racks/
     * @param "Building" (optional.String) - 
     * @param "Where" (optional.String) -  Location in a rack. Note: If mounted a size must be provided or available from the hardware model.
     * @param "StartAt" (optional.String) -  Required if adding to rack. U Start location.
     * @param "Orientation" (optional.String) -  orientation of the PDU in rack. back for rear facing, otherwise front is default.
     * @param "XPos" (optional.Int32) -  A number between 0 and 2520 representing the position within the u slot in increments of 252, which is equal to 1/10th of the width of the rack. 0 will place a device flush left, 1260 will place the left side of a device in center.

@return interface{}
*/

type PDUApiPostPdusRackOpts struct { 
	PduId optional.String
	Pdu optional.String
	RackId optional.String
	Building optional.String
	Where optional.String
	StartAt optional.String
	Orientation optional.String
	XPos optional.Int32
}

func (a *PDUApiService) PostPdusRack(ctx context.Context, localVarOptionals *PDUApiPostPdusRackOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/pdus/rack/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.PduId.IsSet() {
		localVarFormParams.Add("pdu_id", parameterToString(localVarOptionals.PduId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Pdu.IsSet() {
		localVarFormParams.Add("pdu", parameterToString(localVarOptionals.Pdu.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RackId.IsSet() {
		localVarFormParams.Add("rack_id", parameterToString(localVarOptionals.RackId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Building.IsSet() {
		localVarFormParams.Add("building", parameterToString(localVarOptionals.Building.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Where.IsSet() {
		localVarFormParams.Add("where", parameterToString(localVarOptionals.Where.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StartAt.IsSet() {
		localVarFormParams.Add("start_at", parameterToString(localVarOptionals.StartAt.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Orientation.IsSet() {
		localVarFormParams.Add("orientation", parameterToString(localVarOptionals.Orientation.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.XPos.IsSet() {
		localVarFormParams.Add("x_pos", parameterToString(localVarOptionals.XPos.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
PDUApiService Update PDUs
This call will update existing PDUs. PDU ID or name required.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Use instead of PDU ID. Must be unique
 * @param optional nil or *PDUApiPutPdusOpts - Optional Parameters:
     * @param "PduId" (optional.String) -  ID of the PDU to be edited
     * @param "NewName" (optional.String) -  Use to change name of object.
     * @param "PduModelId" (optional.String) -  ID of the PDU model you want to update
     * @param "PduModel" (optional.String) -  Name of the PDU model. You can use this instead of the ID above. (Added in v5.8.2)
     * @param "Type_" (optional.String) -  Type of power unit (pdu, ups, ats)
     * @param "Device" (optional.String) -  If you want to associate asset information with this PDU, use device type &#39;other&#39;
     * @param "PortNumber" (optional.String) -  port number
     * @param "OutletName" (optional.String) -  outlet name
     * @param "Notes" (optional.String) -  Any additional notes
     * @param "RatedPower" (optional.String) - 
     * @param "ObjectCategory" (optional.String) - 
     * @param "StorageRoomId" (optional.String) -  ID of storage room to assign power unit to
     * @param "StorageRoom" (optional.String) -  Name of storage room to apply power unit to
     * @param "Category" (optional.String) -  If multitenancy is on, admin groups that have access to this category, will have access to the power unit. If this parameter is present with no value, all categories are deleted.

@return interface{}
*/

type PDUApiPutPdusOpts struct { 
	PduId optional.String
	NewName optional.String
	PduModelId optional.String
	PduModel optional.String
	Type_ optional.String
	Device optional.String
	PortNumber optional.String
	OutletName optional.String
	Notes optional.String
	RatedPower optional.String
	ObjectCategory optional.String
	StorageRoomId optional.String
	StorageRoom optional.String
	Category optional.String
}

func (a *PDUApiService) PutPdus(ctx context.Context, name string, localVarOptionals *PDUApiPutPdusOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/pdus/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.PduId.IsSet() {
		localVarFormParams.Add("pdu_id", parameterToString(localVarOptionals.PduId.Value(), ""))
	}
	localVarFormParams.Add("name", parameterToString(name, ""))
	if localVarOptionals != nil && localVarOptionals.NewName.IsSet() {
		localVarFormParams.Add("new_name", parameterToString(localVarOptionals.NewName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PduModelId.IsSet() {
		localVarFormParams.Add("pdu_model_id", parameterToString(localVarOptionals.PduModelId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PduModel.IsSet() {
		localVarFormParams.Add("pdu_model", parameterToString(localVarOptionals.PduModel.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarFormParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Device.IsSet() {
		localVarFormParams.Add("device", parameterToString(localVarOptionals.Device.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PortNumber.IsSet() {
		localVarFormParams.Add("port_number", parameterToString(localVarOptionals.PortNumber.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OutletName.IsSet() {
		localVarFormParams.Add("outlet_name", parameterToString(localVarOptionals.OutletName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Notes.IsSet() {
		localVarFormParams.Add("notes", parameterToString(localVarOptionals.Notes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RatedPower.IsSet() {
		localVarFormParams.Add("rated_power", parameterToString(localVarOptionals.RatedPower.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ObjectCategory.IsSet() {
		localVarFormParams.Add("object_category", parameterToString(localVarOptionals.ObjectCategory.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StorageRoomId.IsSet() {
		localVarFormParams.Add("storage_room_id", parameterToString(localVarOptionals.StorageRoomId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StorageRoom.IsSet() {
		localVarFormParams.Add("storage_room", parameterToString(localVarOptionals.StorageRoom.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Category.IsSet() {
		localVarFormParams.Add("category", parameterToString(localVarOptionals.Category.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
PDUApiService Update PDU Ports w/ names
This call requires the name of an existing pdu port and enables you to add new or edit existing values for that particular PDU port. Requires parent_pdu_id or parent_pdu
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name name of the existing PDU port
 * @param optional nil or *PDUApiPutPdusPortsOpts - Optional Parameters:
     * @param "ParentPduId" (optional.String) -  Available from /api/api/1.0/pdus/ or Tools
     * @param "ParentPdu" (optional.String) -  name of the parent PDU. Must be unique name. Added in v5.8.2
     * @param "OutletName" (optional.String) -  outlet name
     * @param "Device" (optional.String) -  Name of the device the port points to.
     * @param "DeviceId" (optional.String) -  ID of the device the port points to
     * @param "PduId" (optional.String) -  ID of the PDU the port points to
     * @param "AssetId" (optional.String) -  ID of the asset the port points to
     * @param "Watts" (optional.String) -  per power supply
     * @param "PsuLabel" (optional.String) -  typically used when device has multiple power supplies, e.g.: power supply 1, power supply 2, etc.

@return interface{}
*/

type PDUApiPutPdusPortsOpts struct { 
	ParentPduId optional.String
	ParentPdu optional.String
	OutletName optional.String
	Device optional.String
	DeviceId optional.String
	PduId optional.String
	AssetId optional.String
	Watts optional.String
	PsuLabel optional.String
}

func (a *PDUApiService) PutPdusPorts(ctx context.Context, name string, localVarOptionals *PDUApiPutPdusPortsOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/pdus/ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ParentPduId.IsSet() {
		localVarFormParams.Add("parent_pdu_id", parameterToString(localVarOptionals.ParentPduId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ParentPdu.IsSet() {
		localVarFormParams.Add("parent_pdu", parameterToString(localVarOptionals.ParentPdu.Value(), ""))
	}
	localVarFormParams.Add("name", parameterToString(name, ""))
	if localVarOptionals != nil && localVarOptionals.OutletName.IsSet() {
		localVarFormParams.Add("outlet_name", parameterToString(localVarOptionals.OutletName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Device.IsSet() {
		localVarFormParams.Add("device", parameterToString(localVarOptionals.Device.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceId.IsSet() {
		localVarFormParams.Add("device_id", parameterToString(localVarOptionals.DeviceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PduId.IsSet() {
		localVarFormParams.Add("pdu_id", parameterToString(localVarOptionals.PduId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AssetId.IsSet() {
		localVarFormParams.Add("asset_id", parameterToString(localVarOptionals.AssetId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Watts.IsSet() {
		localVarFormParams.Add("watts", parameterToString(localVarOptionals.Watts.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PsuLabel.IsSet() {
		localVarFormParams.Add("psu_label", parameterToString(localVarOptionals.PsuLabel.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
