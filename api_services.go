
/*
 * Device42 API
 *
 * <b><h2>API Overview</h2></b><br>Restful API are supported in Device42 as one of the primary methods of entering, editing and retrieving data.<br><br> The API documentation has samples in curl for now and we will be adding other programming languages in future. You can refer to our github repositories at https://github.com/device42 for some sample code in python.<br><br> The RESTful API's enforce the role-based security that is created with the Device42 app. If you want a user to have access via the API, but not via the UI - deselect 'Staff Status' for that user from UI Tools > Admins & Permissions > Administrators.<br><br>If you'd like to see your changes on our UI, please visit http://swaggerdemo.device42.com and use credentials 'guest:device42_rocks!'. Please be aware that every 30 minutes our database resets and all data entered with POST/PUT calls from this page will be lost.<br><br>If you have any questions/suggestions, please send us a note to support at device42.com below. <br><h2><a id = 'Sample_API_Code'><b>Sample API Code</b></a></h2> <b>Sample Code with API Calls in the Python and .Net Programming Languages.</b><br>The following programs written in the Python programming language are available at <a href= 'https://github.com/device42/Device42-AutoDiscovery-Scripts'>Device42 sample programs</a><br><ul><li>api-sample.py: Runs against a single Windows system and uploads info to device42 appliance.</li><li>ad-sample.py: Can run against Active directory computers, servers or a given list and upload discovered systems’ info to device42 appliance.</li><li>d42_api_linux_upload_sample_script.py: Runs on a single *nix based system and uploads info to device42 appliance.</li><li>sample-script-facter-facts-to-d42: Runs on puppet master and uploads nodes info from facter fact files to device42 appliance.</li><li>d42_api_solaris_sample_script.py: Runs on an individual solaris system and uploads info to device42 appliance.</li></ul>The csv2d42apis.py sample program shows how to create a CSV file of data to import into device42. It reads a CSV file, matches columns to arguments for APIs and sends data to device42 via POST or PUT. This program can be found at: <a href= 'https://github.com/device42/API_Helpers'> Device42 sample CSV importer</a>.<br><br>The Auto Discovery Client source code can be found at Device42 <a href='https://docs.device42.com/auto-discovery/'>Auto Discovery Client</a>. This is a .net program that uses the device42 Restful API’s to load the discovered data.<h2><a id = 'Response_Status_Messages'><b>Response & Status Messages</b></a></h2><b>Responses</b><br>The response to most POST calls will have the following format: <br>{'msg':['PartModel added/updated', 17, 'RAM Acme 123456', true, true], 'code':0}<br><br>Using the example above:<br>'17' = ID of the object<br>'RAM Acme 123456' = representation of the object<br> 'true, true' = object added and is new.<br>'true, false' = object updated.<br>'false, false' = no changes.<br><br><b>Status Codes</b><br><u>Code 0</u><br>Success! e.g. = {'msg': 'device added or updated', <b>code:0</b>}<br><br><u>'HTTP/1.1 200 OK'</u><br>Success! All other responses are errors and will display an error code e.g.: 400, 401, 403, 405, 410, 500, 503. These are explained in each call.<br><br>Please let us know if you notice something odd with a response and we will fix it! :) <h2><a id = 'Get_Limits_Offsets'><b>API Get Limits and Offsets</b></a></h2>In Device42’s global settings we have the option to enforce API GET limits and this setting is recommended for better performance. To set this value from Device42, go to Tools>Settings>Global Settings and the click Edit in the top right. Toward the bottom of the screen you will see the API section. First check the “Enforce API GET Limits” checkbox, then enter a value for API GET Limit. A good limit to start with is 500 or 1000, depending on the performance you experience.<br><br>After setting this limit all GET calls below can have the results augmented via “offset” and “limit” parameters to tell Device42 which value to start returning results from, and how many results to return at maximum.<br>Examples:<br><br>'/?limit=50' returns the first 50 results.<br><br> '/?offset=100' will start at the 101st result. <br><br>'/?offset=42&limit=42' returns 42 results, starting at the 43rd.<br><br> Note that offset is used for paging - that is, the offset is only applied when the total number of objects returned exceeds the limit that is returned.
 *
 * API version: 2.0
 * Contact: support@device42.com
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package swagger

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"fmt"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type ServicesApiService service

/* 
ServicesApiService Delete Ignored Service By ID
This API is used to delete the ignored service with the ignored service id supplied as the required argument. Note: You will only be able to delete the service if the supplied username has the correct permissions.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id service id

@return interface{}
*/
func (a *ServicesApiService) DeleteIgnoredServiceByID(ctx context.Context, id int32) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/2.0/ignored_service/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ServicesApiService Delete Scheduled Task by ID
Used to delete the scheduled task with the service schedule ID as the required argument. Note: You will only be able to delete the scheduled task if the supplied username has the correct permissions.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id service schedule id

@return interface{}
*/
func (a *ServicesApiService) DeleteScheduledTasksByID(ctx context.Context, id int32) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/2.0/scheduled_tasks/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ServicesApiService This API is used to delete the service detail with the service detail id supplied as the required argument. Note: You will only be able to delete the service if the supplied username has the correct permissions.
Delete Service detail
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id service detail id

@return interface{}
*/
func (a *ServicesApiService) DeleteServiceDetails(ctx context.Context, id string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/service_detail/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ServicesApiService Delete Service Instances By ID
This API is used to delete the service detail with the service detail id supplied as the required argument. Note - You will only be able to delete the service if the supplied username has the correct permissions.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id service id

@return interface{}
*/
func (a *ServicesApiService) DeleteServiceInstancesByID(ctx context.Context, id int32) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/2.0/service_instances/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ServicesApiService This API is used to delete the service port with the service port id supplied as the required argument. Note: You will only be able to delete the service port if the supplied username has the correct permissions.
Delete Service port
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id service port id

@return interface{}
*/
func (a *ServicesApiService) DeleteServicePorts(ctx context.Context, id string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/service_ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ServicesApiService This API is used to delete the service with the service id supplied as the required argument. Note: You will only be able to delete the service if the supplied username has the correct permissions.
Delete Service
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id service id

@return interface{}
*/
func (a *ServicesApiService) DeleteServices(ctx context.Context, id string) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/services/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ServicesApiService Delete Services By ID
This API is used to delete the service with the service id supplied as the required argument. Note: You will only be able to delete the service if the supplied username has the correct permissions. (Added in v6.3.4)
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id service id

@return interface{}
*/
func (a *ServicesApiService) DeleteServicesByID(ctx context.Context, id int32) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/2.0/services/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ServicesApiService Get Ignored Service
Retrieve list of Ignored Services; filter ignored service details by following parameters in query string
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ServicesApiGetIgnoredServiceOpts - Optional Parameters:
     * @param "IgnoredId" (optional.Int32) -  service id

@return interface{}
*/

type ServicesApiGetIgnoredServiceOpts struct { 
	IgnoredId optional.Int32
}

func (a *ServicesApiService) GetIgnoredService(ctx context.Context, localVarOptionals *ServicesApiGetIgnoredServiceOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/2.0/ignored_service/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.IgnoredId.IsSet() {
		localVarQueryParams.Add("ignored_id", parameterToString(localVarOptionals.IgnoredId.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ServicesApiService
Get Listener Connection Statistics
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param port child is optional assuming you have a parent created (see examples)
 * @param optional nil or *ServicesApiGetListenerConnectionStatsOpts - Optional Parameters:
     * @param "ListenerDeviceName" (optional.String) -  Name of device with listening services

@return interface{}
*/

type ServicesApiGetListenerConnectionStatsOpts struct { 
	ListenerDeviceName optional.String
}

func (a *ServicesApiService) GetListenerConnectionStats(ctx context.Context, port string, localVarOptionals *ServicesApiGetListenerConnectionStatsOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/listener_connection_stats/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.ListenerDeviceName.IsSet() {
		localVarQueryParams.Add("listener_device_name", parameterToString(localVarOptionals.ListenerDeviceName.Value(), ""))
	}
	localVarQueryParams.Add("port", parameterToString(port, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ServicesApiService Retrieve listener connection statistics by service port ID
Get Listener Connection Statistics By ID
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id service port id

@return ListenerConnectionStatsId
*/
func (a *ServicesApiService) GetListenerConnectionStatsByID(ctx context.Context, id int32) (ListenerConnectionStatsId, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ListenerConnectionStatsId
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/2.0/listener_connection_stats/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v ListenerConnectionStatsId
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ServicesApiService Retrieve all listener connection statistics
Get Listener Connection Statistics
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ServicesApiGetListenerConnectionStats_1Opts - Optional Parameters:
     * @param "Port" (optional.String) -  child is optional assuming you have a parent created (see examples)
     * @param "DeviceName" (optional.String) -  the name of the device
     * @param "ListenerDeviceName" (optional.String) -  Name of device with listening services
     * @param "DiscoveredService" (optional.String) -  the name of the discovered service listening on this IP/port
     * @param "MappedService" (optional.String) -  the name of the mapped service listening on this IP/port
     * @param "ServiceInstanceId" (optional.Int32) -  filter by id of the service instance in use

@return ListenerConnectionStats
*/

type ServicesApiGetListenerConnectionStats_1Opts struct { 
	Port optional.String
	DeviceName optional.String
	ListenerDeviceName optional.String
	DiscoveredService optional.String
	MappedService optional.String
	ServiceInstanceId optional.Int32
}

func (a *ServicesApiService) GetListenerConnectionStats_1(ctx context.Context, localVarOptionals *ServicesApiGetListenerConnectionStats_1Opts) (ListenerConnectionStats, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ListenerConnectionStats
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/2.0/listener_connection_stats/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Port.IsSet() {
		localVarQueryParams.Add("port", parameterToString(localVarOptionals.Port.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceName.IsSet() {
		localVarQueryParams.Add("device_name", parameterToString(localVarOptionals.DeviceName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ListenerDeviceName.IsSet() {
		localVarQueryParams.Add("listener_device_name", parameterToString(localVarOptionals.ListenerDeviceName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DiscoveredService.IsSet() {
		localVarQueryParams.Add("discovered_service", parameterToString(localVarOptionals.DiscoveredService.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MappedService.IsSet() {
		localVarQueryParams.Add("mapped_service", parameterToString(localVarOptionals.MappedService.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ServiceInstanceId.IsSet() {
		localVarQueryParams.Add("service_instance_id", parameterToString(localVarOptionals.ServiceInstanceId.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v ListenerConnectionStats
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ServicesApiService
Get Network Shares
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().

@return interface{}
*/
func (a *ServicesApiService) GetNetworkShares(ctx context.Context) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/network_shares/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ServicesApiService Retreive information about all Scheduled Tasks
Get Scheduled Tasks
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ServicesApiGetScheduledTasksOpts - Optional Parameters:
     * @param "Id" (optional.Int32) -  filter results by Service schedule ID
     * @param "DeviceId" (optional.Int32) -  device id
     * @param "Device" (optional.String) -  device
     * @param "UserId" (optional.String) -  user id

@return interface{}
*/

type ServicesApiGetScheduledTasksOpts struct { 
	Id optional.Int32
	DeviceId optional.Int32
	Device optional.String
	UserId optional.String
}

func (a *ServicesApiService) GetScheduledTasks(ctx context.Context, localVarOptionals *ServicesApiGetScheduledTasksOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/2.0/scheduled_tasks/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceId.IsSet() {
		localVarQueryParams.Add("device_id", parameterToString(localVarOptionals.DeviceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Device.IsSet() {
		localVarQueryParams.Add("device", parameterToString(localVarOptionals.Device.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UserId.IsSet() {
		localVarQueryParams.Add("user_id", parameterToString(localVarOptionals.UserId.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ServicesApiService Retrieve Scheduled Task by Service Schedule ID
Get scheduled task By ID
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id service schedule id

@return ServiceSchedule
*/
func (a *ServicesApiService) GetScheduledTasksByID(ctx context.Context, id int32) (ServiceSchedule, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ServiceSchedule
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/2.0/scheduled_tasks/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v ServiceSchedule
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ServicesApiService Get Service Client Connection information by Service Detail ID
Get Service Client Connections
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id service id

@return ServiceClientConnections
*/
func (a *ServicesApiService) GetServiceClientConnections(ctx context.Context, id int32) (ServiceClientConnections, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ServiceClientConnections
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/2.0/service_client_connections/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v ServiceClientConnections
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ServicesApiService
Get Service details
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param deviceId Device ID
 * @param optional nil or *ServicesApiGetServiceDetailsOpts - Optional Parameters:
     * @param "Device" (optional.String) -  Device name
     * @param "ServiceId" (optional.String) -  filter by id of the service
     * @param "ServiceDetailId" (optional.String) -  filter by id of the service in use
     * @param "UserId" (optional.String) -  filter by id of the user

@return interface{}
*/

type ServicesApiGetServiceDetailsOpts struct { 
	Device optional.String
	ServiceId optional.String
	ServiceDetailId optional.String
	UserId optional.String
}

func (a *ServicesApiService) GetServiceDetails(ctx context.Context, deviceId string, localVarOptionals *ServicesApiGetServiceDetailsOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/service_details/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("device_id", parameterToString(deviceId, ""))
	if localVarOptionals != nil && localVarOptionals.Device.IsSet() {
		localVarQueryParams.Add("device", parameterToString(localVarOptionals.Device.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ServiceId.IsSet() {
		localVarQueryParams.Add("service_id", parameterToString(localVarOptionals.ServiceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ServiceDetailId.IsSet() {
		localVarQueryParams.Add("service_detail_id", parameterToString(localVarOptionals.ServiceDetailId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UserId.IsSet() {
		localVarQueryParams.Add("user_id", parameterToString(localVarOptionals.UserId.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ServicesApiService Get Service Instances
You can filter service details by following parameters in the query string
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ServicesApiGetServiceInstancesOpts - Optional Parameters:
     * @param "DeviceId" (optional.Int32) -  filter by id of the device
     * @param "Device" (optional.String) -  filter by name of the device
     * @param "ServiceId" (optional.Int32) -  filter by id of the service
     * @param "ServiceDetailId" (optional.Int32) -  filter by id of the service in use
     * @param "UserId" (optional.String) -  filter by id of the user

@return interface{}
*/

type ServicesApiGetServiceInstancesOpts struct { 
	DeviceId optional.Int32
	Device optional.String
	ServiceId optional.Int32
	ServiceDetailId optional.Int32
	UserId optional.String
}

func (a *ServicesApiService) GetServiceInstances(ctx context.Context, localVarOptionals *ServicesApiGetServiceInstancesOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/2.0/service_instances/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.DeviceId.IsSet() {
		localVarQueryParams.Add("device_id", parameterToString(localVarOptionals.DeviceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Device.IsSet() {
		localVarQueryParams.Add("device", parameterToString(localVarOptionals.Device.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ServiceId.IsSet() {
		localVarQueryParams.Add("service_id", parameterToString(localVarOptionals.ServiceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ServiceDetailId.IsSet() {
		localVarQueryParams.Add("service_detail_id", parameterToString(localVarOptionals.ServiceDetailId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UserId.IsSet() {
		localVarQueryParams.Add("user_id", parameterToString(localVarOptionals.UserId.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ServicesApiService Retrieve Service Instance information by Service Instance ID
Get Service Instances By ID
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id service instance id

@return ServiceInstance
*/
func (a *ServicesApiService) GetServiceInstancesByID(ctx context.Context, id int32) (ServiceInstance, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ServiceInstance
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/2.0/service_instances/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v ServiceInstance
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ServicesApiService Get Service Listener Ports
You can filter service ports by following parameters in the query string
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ServicesApiGetServiceListenerPortsOpts - Optional Parameters:
     * @param "Port" (optional.String) -  port
     * @param "DeviceName" (optional.String) -  the name of the device
     * @param "ListenerDeviceName" (optional.String) -  Name of device with listening services
     * @param "DiscoveredService" (optional.String) -  the name of the discovered service listening on this IP/port
     * @param "MappedService" (optional.String) -  the name of the mapped service listening on this IP/port
     * @param "ServiceInstanceId" (optional.Int32) -  filter by id of the service instance in use

@return ServiceListenerPorts
*/

type ServicesApiGetServiceListenerPortsOpts struct { 
	Port optional.String
	DeviceName optional.String
	ListenerDeviceName optional.String
	DiscoveredService optional.String
	MappedService optional.String
	ServiceInstanceId optional.Int32
}

func (a *ServicesApiService) GetServiceListenerPorts(ctx context.Context, localVarOptionals *ServicesApiGetServiceListenerPortsOpts) (ServiceListenerPorts, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ServiceListenerPorts
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/2.0/service_listener_ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Port.IsSet() {
		localVarQueryParams.Add("port", parameterToString(localVarOptionals.Port.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceName.IsSet() {
		localVarQueryParams.Add("device_name", parameterToString(localVarOptionals.DeviceName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ListenerDeviceName.IsSet() {
		localVarQueryParams.Add("listener_device_name", parameterToString(localVarOptionals.ListenerDeviceName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DiscoveredService.IsSet() {
		localVarQueryParams.Add("discovered_service", parameterToString(localVarOptionals.DiscoveredService.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MappedService.IsSet() {
		localVarQueryParams.Add("mapped_service", parameterToString(localVarOptionals.MappedService.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ServiceInstanceId.IsSet() {
		localVarQueryParams.Add("service_instance_id", parameterToString(localVarOptionals.ServiceInstanceId.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v ServiceListenerPorts
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ServicesApiService Retrieve Service Listener port information by Service Port ID
Get Service Listener Ports By ID
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id service port id

@return ServiceListenerPort
*/
func (a *ServicesApiService) GetServiceListenerPortsByID(ctx context.Context, id int32) (ServiceListenerPort, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ServiceListenerPort
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/2.0/service_listener_ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v ServiceListenerPort
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ServicesApiService
Get Service ports
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ServicesApiGetServicePortsOpts - Optional Parameters:
     * @param "Id" (optional.String) -  filter by id of the service port

@return interface{}
*/

type ServicesApiGetServicePortsOpts struct { 
	Id optional.String
}

func (a *ServicesApiService) GetServicePorts(ctx context.Context, localVarOptionals *ServicesApiGetServicePortsOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/service_ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ServicesApiService
Get Services
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param serviceId D42 ID of the service
 * @param optional nil or *ServicesApiGetServicesOpts - Optional Parameters:
     * @param "Name" (optional.String) -  filter by name (Added in v6.0.0)
     * @param "Category" (optional.String) -  name of the category
     * @param "Vendor" (optional.String) -  The cloud vendor

@return interface{}
*/

type ServicesApiGetServicesOpts struct { 
	Name optional.String
	Category optional.String
	Vendor optional.String
}

func (a *ServicesApiService) GetServices(ctx context.Context, serviceId string, localVarOptionals *ServicesApiGetServicesOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/services/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("service_id", parameterToString(serviceId, ""))
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Category.IsSet() {
		localVarQueryParams.Add("category", parameterToString(localVarOptionals.Category.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Vendor.IsSet() {
		localVarQueryParams.Add("vendor", parameterToString(localVarOptionals.Vendor.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ServicesApiService Get list of all Services
You can filter services by following parameters in the query string
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ServicesApiGetServices2Opts - Optional Parameters:
     * @param "Id" (optional.Int32) -  D42 ID of the service
     * @param "Displayname" (optional.String) -  name of the service
     * @param "Category" (optional.String) -  name of the category
     * @param "Vendor" (optional.String) -  vendor name

@return interface{}
*/

type ServicesApiGetServices2Opts struct { 
	Id optional.Int32
	Displayname optional.String
	Category optional.String
	Vendor optional.String
}

func (a *ServicesApiService) GetServices2(ctx context.Context, localVarOptionals *ServicesApiGetServices2Opts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/2.0/services/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Displayname.IsSet() {
		localVarQueryParams.Add("displayname", parameterToString(localVarOptionals.Displayname.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Category.IsSet() {
		localVarQueryParams.Add("category", parameterToString(localVarOptionals.Category.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Vendor.IsSet() {
		localVarQueryParams.Add("vendor", parameterToString(localVarOptionals.Vendor.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ServicesApiService Create / Update Ignored Service
Post Ignored Service
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param ignoredLevel ignored level - 1 for Service Name, 2 for Service Instance Args
 * @param ignoredText ignored text
 * @param active active flag

@return interface{}
*/
func (a *ServicesApiService) PostIgnoredService(ctx context.Context, ignoredLevel int32, ignoredText string, active bool) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/2.0/ignored_service/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormParams.Add("ignored_level", parameterToString(ignoredLevel, ""))
	localVarFormParams.Add("ignored_text", parameterToString(ignoredText, ""))
	localVarFormParams.Add("active", parameterToString(active, ""))
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ServicesApiService Create / Update Scheduled Tasks
Post Scheduled Tasks. 3 parameters are required: &lt;ul&gt;&lt;li&gt;schedule_name &lt;b&gt;OR&lt;/b&gt; service_name &lt;b&gt;OR&lt;/b&gt; name&lt;/li&gt; &lt;li&gt;device_id &lt;b&gt;OR&lt;/b&gt; device&lt;/li&gt; &lt;li&gt;caption&lt;/li&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param caption caption
 * @param optional nil or *ServicesApiPostScheduledTasksOpts - Optional Parameters:
     * @param "ScheduleId" (optional.Int32) -  schedule id
     * @param "ServiceDetailId" (optional.Int32) -  filter by id of the service in use
     * @param "ScheduleName" (optional.String) -  schedule name
     * @param "ServiceName" (optional.String) -  The executable name of the service
     * @param "Name" (optional.String) -  name
     * @param "Device" (optional.String) -  The device that this service runs on
     * @param "DeviceId" (optional.Int32) -  The ID of the device that this service runs on
     * @param "UserId" (optional.String) -  end user id
     * @param "SchedDescription" (optional.String) -  schedule description
     * @param "Arguments" (optional.String) -  arguments
     * @param "Status" (optional.String) -  status
     * @param "InstallDate" (optional.String) -  (note capital D for schedules) only for schedule based services where startmode &#x3D; &#39;Scheduled&#39;
     * @param "AtLogon" (optional.String) -  only for schedule based services where startmode &#x3D; &#39;Scheduled&#39;
     * @param "AtStartup" (optional.String) -  only for schedule based services where startmode &#x3D; &#39;Scheduled&#39;
     * @param "EventBased" (optional.String) -  only for schedule based services where startmode &#x3D; &#39;Scheduled&#39;
     * @param "IdleTime" (optional.String) -  only for schedule based services where startmode &#x3D; &#39;Scheduled&#39;
     * @param "OtherTrigger" (optional.String) -  only for schedule based services where startmode &#x3D; &#39;Scheduled&#39;
     * @param "OtherType" (optional.String) -  only for schedule based services where startmode &#x3D; &#39;Scheduled&#39;
     * @param "Minutes" (optional.String) -  only for schedule based services where startmode &#x3D; &#39;Scheduled&#39;
     * @param "Hours" (optional.String) -  only for schedule based services where startmode &#x3D; &#39;Scheduled&#39;
     * @param "Days" (optional.String) -  only for schedule based services where startmode &#x3D; &#39;Scheduled&#39;
     * @param "Weeks" (optional.String) -  only for schedule based services where startmode &#x3D; &#39;Scheduled&#39;
     * @param "DayOfMonth" (optional.String) -  only for schedule based services where startmode &#x3D; &#39;Scheduled&#39;
     * @param "MonthOfYear" (optional.String) -  only for schedule based services where startmode &#x3D; &#39;Scheduled&#39;
     * @param "DayOfWeek" (optional.String) -  only for schedule based services where startmode &#x3D; &#39;Scheduled&#39;

@return interface{}
*/

type ServicesApiPostScheduledTasksOpts struct { 
	ScheduleId optional.Int32
	ServiceDetailId optional.Int32
	ScheduleName optional.String
	ServiceName optional.String
	Name optional.String
	Device optional.String
	DeviceId optional.Int32
	UserId optional.String
	SchedDescription optional.String
	Arguments optional.String
	Status optional.String
	InstallDate optional.String
	AtLogon optional.String
	AtStartup optional.String
	EventBased optional.String
	IdleTime optional.String
	OtherTrigger optional.String
	OtherType optional.String
	Minutes optional.String
	Hours optional.String
	Days optional.String
	Weeks optional.String
	DayOfMonth optional.String
	MonthOfYear optional.String
	DayOfWeek optional.String
}

func (a *ServicesApiService) PostScheduledTasks(ctx context.Context, caption string, localVarOptionals *ServicesApiPostScheduledTasksOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/2.0/scheduled_tasks/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ScheduleId.IsSet() {
		localVarFormParams.Add("schedule_id", parameterToString(localVarOptionals.ScheduleId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ServiceDetailId.IsSet() {
		localVarFormParams.Add("service_detail_id", parameterToString(localVarOptionals.ServiceDetailId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScheduleName.IsSet() {
		localVarFormParams.Add("schedule_name", parameterToString(localVarOptionals.ScheduleName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ServiceName.IsSet() {
		localVarFormParams.Add("service_name", parameterToString(localVarOptionals.ServiceName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarFormParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Device.IsSet() {
		localVarFormParams.Add("device", parameterToString(localVarOptionals.Device.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceId.IsSet() {
		localVarFormParams.Add("device_id", parameterToString(localVarOptionals.DeviceId.Value(), ""))
	}
	localVarFormParams.Add("caption", parameterToString(caption, ""))
	if localVarOptionals != nil && localVarOptionals.UserId.IsSet() {
		localVarFormParams.Add("user_id", parameterToString(localVarOptionals.UserId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SchedDescription.IsSet() {
		localVarFormParams.Add("sched_description", parameterToString(localVarOptionals.SchedDescription.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Arguments.IsSet() {
		localVarFormParams.Add("arguments", parameterToString(localVarOptionals.Arguments.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Status.IsSet() {
		localVarFormParams.Add("status", parameterToString(localVarOptionals.Status.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InstallDate.IsSet() {
		localVarFormParams.Add("install_Date", parameterToString(localVarOptionals.InstallDate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AtLogon.IsSet() {
		localVarFormParams.Add("at_logon", parameterToString(localVarOptionals.AtLogon.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AtStartup.IsSet() {
		localVarFormParams.Add("at_startup", parameterToString(localVarOptionals.AtStartup.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventBased.IsSet() {
		localVarFormParams.Add("event_based", parameterToString(localVarOptionals.EventBased.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IdleTime.IsSet() {
		localVarFormParams.Add("idle_time", parameterToString(localVarOptionals.IdleTime.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OtherTrigger.IsSet() {
		localVarFormParams.Add("other_trigger", parameterToString(localVarOptionals.OtherTrigger.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OtherType.IsSet() {
		localVarFormParams.Add("other_type", parameterToString(localVarOptionals.OtherType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Minutes.IsSet() {
		localVarFormParams.Add("minutes", parameterToString(localVarOptionals.Minutes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Hours.IsSet() {
		localVarFormParams.Add("hours", parameterToString(localVarOptionals.Hours.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Days.IsSet() {
		localVarFormParams.Add("days", parameterToString(localVarOptionals.Days.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Weeks.IsSet() {
		localVarFormParams.Add("weeks", parameterToString(localVarOptionals.Weeks.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DayOfMonth.IsSet() {
		localVarFormParams.Add("day_of_month", parameterToString(localVarOptionals.DayOfMonth.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MonthOfYear.IsSet() {
		localVarFormParams.Add("month_of_year", parameterToString(localVarOptionals.MonthOfYear.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DayOfWeek.IsSet() {
		localVarFormParams.Add("day_of_week", parameterToString(localVarOptionals.DayOfWeek.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ServicesApiService
Create / Update service details
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param serviceName The executable name of the service
 * @param serviceDisplayName The user freindly display name of the service
 * @param optional nil or *ServicesApiPostServiceDetailsOpts - Optional Parameters:
     * @param "Vendor" (optional.String) -  The cloud vendor
     * @param "Description" (optional.String) - 
     * @param "ServiceType" (optional.String) -  could be ignored or tracked. Default is tracked.
     * @param "Category" (optional.String) -  name of the category
     * @param "Startmode" (optional.String) -  The start mode of this service - valid values are ‘Automatic’, ‘Manual’, ‘Disabled’ and ‘Unknown’
     * @param "State" (optional.String) -  The current running state of this service. Valid values are ‘Running’, ‘Started’, ‘Paused’, ‘Stopped’ and ‘Unknown’
     * @param "Device" (optional.String) -  Device name
     * @param "User" (optional.String) -  enduser name
     * @param "Appcomp" (optional.String) -  The application component that depends on this service
     * @param "InstallDate" (optional.String) -  The date that the software was installed
     * @param "Status" (optional.String) -  Instance status (ie, running, stopped)
     * @param "AtLogon" (optional.String) -  only for schedule based services where startmode &#x3D; ‘Scheduled’
     * @param "AtStartup" (optional.String) -  only for schedule based services where startmode &#x3D; ‘Scheduled’
     * @param "EventBased" (optional.String) -  only for schedule based services where startmode &#x3D; ‘Scheduled’
     * @param "IdleTime" (optional.String) -  only for schedule based services where startmode &#x3D; ‘Scheduled’
     * @param "OtherTrigger" (optional.String) -  only for schedule based services where startmode &#x3D; ‘Scheduled’
     * @param "OtherType" (optional.String) -  only for schedule based services where startmode &#x3D; ‘Scheduled’
     * @param "Minutes" (optional.String) -  only for schedule based services where startmode &#x3D; ‘Scheduled’
     * @param "Hours" (optional.String) -  only for schedule based services where startmode &#x3D; ‘Scheduled’
     * @param "Days" (optional.String) -  only for schedule based services where startmode &#x3D; ‘Scheduled’
     * @param "Weeks" (optional.String) -  only for schedule based services where startmode &#x3D; ‘Scheduled’
     * @param "DayOfMonth" (optional.String) -  only for schedule based services where startmode &#x3D; ‘Scheduled’
     * @param "MonthOfYear" (optional.String) -  only for schedule based services where startmode &#x3D; ‘Scheduled’
     * @param "DayOfWeek" (optional.String) -  only for schedule based services where startmode &#x3D; ‘Scheduled’

@return interface{}
*/

type ServicesApiPostServiceDetailsOpts struct { 
	Vendor optional.String
	Description optional.String
	ServiceType optional.String
	Category optional.String
	Startmode optional.String
	State optional.String
	Device optional.String
	User optional.String
	Appcomp optional.String
	InstallDate optional.String
	Status optional.String
	AtLogon optional.String
	AtStartup optional.String
	EventBased optional.String
	IdleTime optional.String
	OtherTrigger optional.String
	OtherType optional.String
	Minutes optional.String
	Hours optional.String
	Days optional.String
	Weeks optional.String
	DayOfMonth optional.String
	MonthOfYear optional.String
	DayOfWeek optional.String
}

func (a *ServicesApiService) PostServiceDetails(ctx context.Context, serviceName string, serviceDisplayName string, localVarOptionals *ServicesApiPostServiceDetailsOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/service_details/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("service_name", parameterToString(serviceName, ""))
	localVarQueryParams.Add("service_display_name", parameterToString(serviceDisplayName, ""))
	if localVarOptionals != nil && localVarOptionals.ServiceType.IsSet() {
		localVarQueryParams.Add("service_type", parameterToString(localVarOptionals.ServiceType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Category.IsSet() {
		localVarQueryParams.Add("category", parameterToString(localVarOptionals.Category.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Startmode.IsSet() {
		localVarQueryParams.Add("startmode", parameterToString(localVarOptionals.Startmode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.State.IsSet() {
		localVarQueryParams.Add("state", parameterToString(localVarOptionals.State.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Device.IsSet() {
		localVarQueryParams.Add("device", parameterToString(localVarOptionals.Device.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Appcomp.IsSet() {
		localVarQueryParams.Add("appcomp", parameterToString(localVarOptionals.Appcomp.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AtLogon.IsSet() {
		localVarQueryParams.Add("at_logon", parameterToString(localVarOptionals.AtLogon.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AtStartup.IsSet() {
		localVarQueryParams.Add("at_startup", parameterToString(localVarOptionals.AtStartup.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventBased.IsSet() {
		localVarQueryParams.Add("event_based", parameterToString(localVarOptionals.EventBased.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IdleTime.IsSet() {
		localVarQueryParams.Add("idle_time", parameterToString(localVarOptionals.IdleTime.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OtherTrigger.IsSet() {
		localVarQueryParams.Add("other_trigger", parameterToString(localVarOptionals.OtherTrigger.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OtherType.IsSet() {
		localVarQueryParams.Add("other_type", parameterToString(localVarOptionals.OtherType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Minutes.IsSet() {
		localVarQueryParams.Add("minutes", parameterToString(localVarOptionals.Minutes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Hours.IsSet() {
		localVarQueryParams.Add("hours", parameterToString(localVarOptionals.Hours.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Days.IsSet() {
		localVarQueryParams.Add("days", parameterToString(localVarOptionals.Days.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Weeks.IsSet() {
		localVarQueryParams.Add("weeks", parameterToString(localVarOptionals.Weeks.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DayOfMonth.IsSet() {
		localVarQueryParams.Add("day_of_month", parameterToString(localVarOptionals.DayOfMonth.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MonthOfYear.IsSet() {
		localVarQueryParams.Add("month_of_year", parameterToString(localVarOptionals.MonthOfYear.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DayOfWeek.IsSet() {
		localVarQueryParams.Add("day_of_week", parameterToString(localVarOptionals.DayOfWeek.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Vendor.IsSet() {
		localVarFormParams.Add("vendor", parameterToString(localVarOptionals.Vendor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarFormParams.Add("description", parameterToString(localVarOptionals.Description.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.User.IsSet() {
		localVarFormParams.Add("user", parameterToString(localVarOptionals.User.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InstallDate.IsSet() {
		localVarFormParams.Add("install_date", parameterToString(localVarOptionals.InstallDate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Status.IsSet() {
		localVarFormParams.Add("status", parameterToString(localVarOptionals.Status.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ServicesApiService Create / Update service instances
Post Service Instances. Required parameters are either: &lt;ul&gt;&lt;li&gt;service_name &lt;b&gt;OR&lt;/b&gt; service_display_name &lt;b&gt;OR&lt;/b&gt; service_id&lt;/li&gt; &lt;li&gt; device &lt;b&gt;OR&lt;/b&gt; device_id&lt;/li&gt;&lt;p&gt;------ OR ------&lt;li&gt;service_detail_id&lt;/li&gt;&lt;/ul&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ServicesApiPostServiceInstancesOpts - Optional Parameters:
     * @param "ServiceDetailId" (optional.Int32) -  service detail id
     * @param "Device" (optional.String) -  The device that this service runs on
     * @param "DeviceId" (optional.Int32) -  id of the device
     * @param "ListeningIp" (optional.String) -  the local IP address that listening on this port
     * @param "Port" (optional.Int32) -  the listening port on this device
     * @param "Loadbalancer" (optional.String) -  loadbalancer
     * @param "ServiceName" (optional.String) -  The executable name of the service
     * @param "ServiceDisplayName" (optional.String) -  The user freindly display name of the service
     * @param "ServiceId" (optional.Int32) -  service id
     * @param "UserId" (optional.String) -  id of the user
     * @param "RemoveAppcompIds" (optional.Int32) -  comma separated list of application components IDs to remove
     * @param "ClearAppcomps" (optional.String) -  Set to &#39;yes&#39; to clear associated application components
     * @param "Appcomps" (optional.String) -  comma separated list of application components to associated with service instance
     * @param "ServicePath" (optional.String) -  service path
     * @param "InstallDate" (optional.String) -  install date
     * @param "State" (optional.String) -  The current running state of this service. Valid values are &#39;Running&#39;, &#39;Started&#39;, &#39;Paused&#39;, &#39;Stopped&#39; and &#39;Unknown&#39;
     * @param "IgnoreClientConnections" (optional.String) - 
     * @param "Startmode" (optional.String) -  The start mode of this service - valid values are &#39;Automatic&#39;, &#39;Manual&#39;, &#39;Disabled&#39; and &#39;Unknown&#39;
     * @param "Pinned" (optional.String) -  pinned
     * @param "TopologyStatus" (optional.String) -  topology status

@return interface{}
*/

type ServicesApiPostServiceInstancesOpts struct { 
	ServiceDetailId optional.Int32
	Device optional.String
	DeviceId optional.Int32
	ListeningIp optional.String
	Port optional.Int32
	Loadbalancer optional.String
	ServiceName optional.String
	ServiceDisplayName optional.String
	ServiceId optional.Int32
	UserId optional.String
	RemoveAppcompIds optional.Int32
	ClearAppcomps optional.String
	Appcomps optional.String
	ServicePath optional.String
	InstallDate optional.String
	State optional.String
	IgnoreClientConnections optional.String
	Startmode optional.String
	Pinned optional.String
	TopologyStatus optional.String
}

func (a *ServicesApiService) PostServiceInstances(ctx context.Context, localVarOptionals *ServicesApiPostServiceInstancesOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/2.0/service_instances/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ServiceDetailId.IsSet() {
		localVarFormParams.Add("service_detail_id", parameterToString(localVarOptionals.ServiceDetailId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Device.IsSet() {
		localVarFormParams.Add("device", parameterToString(localVarOptionals.Device.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceId.IsSet() {
		localVarFormParams.Add("device_id", parameterToString(localVarOptionals.DeviceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ListeningIp.IsSet() {
		localVarFormParams.Add("listening_ip", parameterToString(localVarOptionals.ListeningIp.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Port.IsSet() {
		localVarFormParams.Add("port", parameterToString(localVarOptionals.Port.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Loadbalancer.IsSet() {
		localVarFormParams.Add("loadbalancer", parameterToString(localVarOptionals.Loadbalancer.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ServiceName.IsSet() {
		localVarFormParams.Add("service_name", parameterToString(localVarOptionals.ServiceName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ServiceDisplayName.IsSet() {
		localVarFormParams.Add("service_display_name", parameterToString(localVarOptionals.ServiceDisplayName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ServiceId.IsSet() {
		localVarFormParams.Add("service_id", parameterToString(localVarOptionals.ServiceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UserId.IsSet() {
		localVarFormParams.Add("user_id", parameterToString(localVarOptionals.UserId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RemoveAppcompIds.IsSet() {
		localVarFormParams.Add("remove_appcomp_ids", parameterToString(localVarOptionals.RemoveAppcompIds.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ClearAppcomps.IsSet() {
		localVarFormParams.Add("clear_appcomps", parameterToString(localVarOptionals.ClearAppcomps.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Appcomps.IsSet() {
		localVarFormParams.Add("appcomps", parameterToString(localVarOptionals.Appcomps.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ServicePath.IsSet() {
		localVarFormParams.Add("service_path", parameterToString(localVarOptionals.ServicePath.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InstallDate.IsSet() {
		localVarFormParams.Add("install_date", parameterToString(localVarOptionals.InstallDate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.State.IsSet() {
		localVarFormParams.Add("state", parameterToString(localVarOptionals.State.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IgnoreClientConnections.IsSet() {
		localVarFormParams.Add("ignore_client_connections", parameterToString(localVarOptionals.IgnoreClientConnections.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Startmode.IsSet() {
		localVarFormParams.Add("startmode", parameterToString(localVarOptionals.Startmode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Pinned.IsSet() {
		localVarFormParams.Add("pinned", parameterToString(localVarOptionals.Pinned.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TopologyStatus.IsSet() {
		localVarFormParams.Add("topology_status", parameterToString(localVarOptionals.TopologyStatus.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ServicesApiService Create / Update service ports
Post Service Listener Ports. Required parameters: &lt;ul&gt; &lt;li&gt;id&lt;/li&gt;&lt;/ul&gt; &lt;b&gt;---------- OR ----------&lt;/b&gt; &lt;ul&gt; &lt;li&gt;port&lt;/li&gt; &lt;li&gt;device_name &lt;b&gt;OR&lt;/b&gt; device_id&lt;/li&gt; &lt;li&gt;listening_ip &lt;b&gt;OR&lt;/b&gt; remote_ips&lt;/li&gt; &lt;/ul&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ServicesApiPostServiceListenerPortsOpts - Optional Parameters:
     * @param "Id" (optional.Int32) -  service port id
     * @param "Port" (optional.Int32) -  the listening port on this device
     * @param "DeviceName" (optional.String) -  the name of the device
     * @param "DeviceId" (optional.Int32) -  device id
     * @param "ListeningIp" (optional.String) -  the name of the device
     * @param "RemoteIps" (optional.String) -  the comma separated list of remote IPs that are connected to this listening IP/port
     * @param "DiscoveredServiceId" (optional.Int32) -  device service id
     * @param "DiscoveredService" (optional.String) -  the name of the discovered service listening on this IP/port
     * @param "DiscoveredServiceDisplayName" (optional.String) -  discovered service display name
     * @param "DiscoveredProcess" (optional.String) -  the process name that has a handle to the port
     * @param "DiscoveredProcessDisplayName" (optional.String) -  discovered process display name
     * @param "MappedService" (optional.String) -  the name of the mapped service listening on this IP/port
     * @param "MappedServiceDisplayName" (optional.String) -  mapped service display name
     * @param "Protocol" (optional.String) -  the transport protocol, ie TCP
     * @param "RemotePortTime" (optional.String) -  remote port time

@return interface{}
*/

type ServicesApiPostServiceListenerPortsOpts struct { 
	Id optional.Int32
	Port optional.Int32
	DeviceName optional.String
	DeviceId optional.Int32
	ListeningIp optional.String
	RemoteIps optional.String
	DiscoveredServiceId optional.Int32
	DiscoveredService optional.String
	DiscoveredServiceDisplayName optional.String
	DiscoveredProcess optional.String
	DiscoveredProcessDisplayName optional.String
	MappedService optional.String
	MappedServiceDisplayName optional.String
	Protocol optional.String
	RemotePortTime optional.String
}

func (a *ServicesApiService) PostServiceListenerPorts(ctx context.Context, localVarOptionals *ServicesApiPostServiceListenerPortsOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/2.0/service_listener_ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarFormParams.Add("id", parameterToString(localVarOptionals.Id.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Port.IsSet() {
		localVarFormParams.Add("port", parameterToString(localVarOptionals.Port.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceName.IsSet() {
		localVarFormParams.Add("device_name", parameterToString(localVarOptionals.DeviceName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceId.IsSet() {
		localVarFormParams.Add("device_id", parameterToString(localVarOptionals.DeviceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ListeningIp.IsSet() {
		localVarFormParams.Add("listening_ip", parameterToString(localVarOptionals.ListeningIp.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RemoteIps.IsSet() {
		localVarFormParams.Add("remote_ips", parameterToString(localVarOptionals.RemoteIps.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DiscoveredServiceId.IsSet() {
		localVarFormParams.Add("discovered_service_id", parameterToString(localVarOptionals.DiscoveredServiceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DiscoveredService.IsSet() {
		localVarFormParams.Add("discovered_service", parameterToString(localVarOptionals.DiscoveredService.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DiscoveredServiceDisplayName.IsSet() {
		localVarFormParams.Add("discovered_service_display_name", parameterToString(localVarOptionals.DiscoveredServiceDisplayName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DiscoveredProcess.IsSet() {
		localVarFormParams.Add("discovered_process", parameterToString(localVarOptionals.DiscoveredProcess.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DiscoveredProcessDisplayName.IsSet() {
		localVarFormParams.Add("discovered_process_display_name", parameterToString(localVarOptionals.DiscoveredProcessDisplayName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MappedService.IsSet() {
		localVarFormParams.Add("mapped_service", parameterToString(localVarOptionals.MappedService.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MappedServiceDisplayName.IsSet() {
		localVarFormParams.Add("mapped_service_display_name", parameterToString(localVarOptionals.MappedServiceDisplayName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Protocol.IsSet() {
		localVarFormParams.Add("protocol", parameterToString(localVarOptionals.Protocol.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RemotePortTime.IsSet() {
		localVarFormParams.Add("remote_port_time", parameterToString(localVarOptionals.RemotePortTime.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ServicesApiService
Create / Update service ports
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param port child is optional assuming you have a parent created (see examples)
 * @param optional nil or *ServicesApiPostServicePortsOpts - Optional Parameters:
     * @param "DeviceName" (optional.String) -  required if switchport ID not used
     * @param "ListeningIp" (optional.String) -  the name of the device
     * @param "Description" (optional.String) -  matching description (added in v7.2.0)
     * @param "DiscoveredService" (optional.String) -  the name of the discovered service listening on this IP/port
     * @param "DiscoveredProcess" (optional.String) -  the process name that has a handle to the port
     * @param "MappedService" (optional.String) -  the name of the mapped service listening on this IP/port
     * @param "RemoteIps" (optional.String) -  the comma separated list of remote IPs that are connected to this listening IP/port

@return interface{}
*/

type ServicesApiPostServicePortsOpts struct { 
	DeviceName optional.String
	ListeningIp optional.String
	Description optional.String
	DiscoveredService optional.String
	DiscoveredProcess optional.String
	MappedService optional.String
	RemoteIps optional.String
}

func (a *ServicesApiService) PostServicePorts(ctx context.Context, port string, localVarOptionals *ServicesApiPostServicePortsOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/service_ports/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("port", parameterToString(port, ""))
	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarQueryParams.Add("description", parameterToString(localVarOptionals.Description.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DiscoveredService.IsSet() {
		localVarQueryParams.Add("discovered_service", parameterToString(localVarOptionals.DiscoveredService.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MappedService.IsSet() {
		localVarQueryParams.Add("mapped_service", parameterToString(localVarOptionals.MappedService.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.DeviceName.IsSet() {
		localVarFormParams.Add("device_name", parameterToString(localVarOptionals.DeviceName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ListeningIp.IsSet() {
		localVarFormParams.Add("listening_ip", parameterToString(localVarOptionals.ListeningIp.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DiscoveredProcess.IsSet() {
		localVarFormParams.Add("discovered_process", parameterToString(localVarOptionals.DiscoveredProcess.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RemoteIps.IsSet() {
		localVarFormParams.Add("remote_ips", parameterToString(localVarOptionals.RemoteIps.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ServicesApiService
Create / Update Services
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param displayName if not provided, the name is used as display name
 * @param optional nil or *ServicesApiPostServicesOpts - Optional Parameters:
     * @param "Name" (optional.String) -  filter by name (Added in v6.0.0)
     * @param "Category" (optional.String) -  name of the category
     * @param "ServiceType" (optional.String) -  could be ignored or tracked. Default is tracked.
     * @param "Vendor" (optional.String) -  The cloud vendor
     * @param "Description" (optional.String) - 
     * @param "Notes" (optional.String) -  Any additional notes

@return interface{}
*/

type ServicesApiPostServicesOpts struct { 
	Name optional.String
	Category optional.String
	ServiceType optional.String
	Vendor optional.String
	Description optional.String
	Notes optional.String
}

func (a *ServicesApiService) PostServices(ctx context.Context, displayName string, localVarOptionals *ServicesApiPostServicesOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/1.0/services/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	localVarQueryParams.Add("display_name", parameterToString(displayName, ""))
	if localVarOptionals != nil && localVarOptionals.Category.IsSet() {
		localVarQueryParams.Add("category", parameterToString(localVarOptionals.Category.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ServiceType.IsSet() {
		localVarQueryParams.Add("service_type", parameterToString(localVarOptionals.ServiceType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Notes.IsSet() {
		localVarQueryParams.Add("notes", parameterToString(localVarOptionals.Notes.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Vendor.IsSet() {
		localVarFormParams.Add("vendor", parameterToString(localVarOptionals.Vendor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarFormParams.Add("description", parameterToString(localVarOptionals.Description.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ServicesApiService Create / Update Services
Post a Service. Required parameters: &lt;ul&gt; &lt;li&gt;name &lt;b&gt;OR&lt;/b&gt; display_name&lt;/li&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ServicesApiPostServices2Opts - Optional Parameters:
     * @param "Name" (optional.String) -  name for service
     * @param "DisplayName" (optional.String) -  if not provided, the name is used as display name
     * @param "Vendor" (optional.String) -  Names of vendor
     * @param "Description" (optional.String) -  description of service
     * @param "Notes" (optional.String) -  notes
     * @param "Category" (optional.String) -  Name of category

@return interface{}
*/

type ServicesApiPostServices2Opts struct { 
	Name optional.String
	DisplayName optional.String
	Vendor optional.String
	Description optional.String
	Notes optional.String
	Category optional.String
}

func (a *ServicesApiService) PostServices2(ctx context.Context, localVarOptionals *ServicesApiPostServices2Opts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/2.0/services/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarFormParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DisplayName.IsSet() {
		localVarFormParams.Add("display_name", parameterToString(localVarOptionals.DisplayName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Vendor.IsSet() {
		localVarFormParams.Add("vendor", parameterToString(localVarOptionals.Vendor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarFormParams.Add("description", parameterToString(localVarOptionals.Description.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Notes.IsSet() {
		localVarFormParams.Add("notes", parameterToString(localVarOptionals.Notes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Category.IsSet() {
		localVarFormParams.Add("category", parameterToString(localVarOptionals.Category.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ServicesApiService Create / Update service ports
Currently, in order to update a service port, id (path), device_name/device_id, and listening_ip/remote_ips are needed even if they are staying the same - we use those fields to identify the port.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id service port id
 * @param optional nil or *ServicesApiPutServiceListenerPortsOpts - Optional Parameters:
     * @param "Port" (optional.Int32) -  the listening port on this device
     * @param "DeviceName" (optional.String) -  the name of the device
     * @param "DeviceId" (optional.Int32) -  device id
     * @param "ListeningIp" (optional.String) -  the name of the device
     * @param "RemoteIps" (optional.String) -  the comma separated list of remote IPs that are connected to this listening IP/port
     * @param "DiscoveredServiceId" (optional.Int32) -  device service id
     * @param "DiscoveredService" (optional.String) -  the name of the discovered service listening on this IP/port
     * @param "DiscoveredServiceDisplayName" (optional.String) -  discovered service display name
     * @param "DiscoveredProcess" (optional.String) -  the process name that has a handle to the port
     * @param "DiscoveredProcessDisplayName" (optional.String) -  discovered process display name
     * @param "MappedService" (optional.String) -  the name of the mapped service listening on this IP/port
     * @param "MappedServiceDisplayName" (optional.String) -  mapped service display name
     * @param "Protocol" (optional.String) -  the transport protocol, ie TCP
     * @param "RemotePortTime" (optional.String) -  remote port time

@return interface{}
*/

type ServicesApiPutServiceListenerPortsOpts struct { 
	Port optional.Int32
	DeviceName optional.String
	DeviceId optional.Int32
	ListeningIp optional.String
	RemoteIps optional.String
	DiscoveredServiceId optional.Int32
	DiscoveredService optional.String
	DiscoveredServiceDisplayName optional.String
	DiscoveredProcess optional.String
	DiscoveredProcessDisplayName optional.String
	MappedService optional.String
	MappedServiceDisplayName optional.String
	Protocol optional.String
	RemotePortTime optional.String
}

func (a *ServicesApiService) PutServiceListenerPorts(ctx context.Context, id int32, localVarOptionals *ServicesApiPutServiceListenerPortsOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/2.0/service_listener_ports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.Port.IsSet() {
		localVarFormParams.Add("port", parameterToString(localVarOptionals.Port.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceName.IsSet() {
		localVarFormParams.Add("device_name", parameterToString(localVarOptionals.DeviceName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceId.IsSet() {
		localVarFormParams.Add("device_id", parameterToString(localVarOptionals.DeviceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ListeningIp.IsSet() {
		localVarFormParams.Add("listening_ip", parameterToString(localVarOptionals.ListeningIp.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RemoteIps.IsSet() {
		localVarFormParams.Add("remote_ips", parameterToString(localVarOptionals.RemoteIps.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DiscoveredServiceId.IsSet() {
		localVarFormParams.Add("discovered_service_id", parameterToString(localVarOptionals.DiscoveredServiceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DiscoveredService.IsSet() {
		localVarFormParams.Add("discovered_service", parameterToString(localVarOptionals.DiscoveredService.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DiscoveredServiceDisplayName.IsSet() {
		localVarFormParams.Add("discovered_service_display_name", parameterToString(localVarOptionals.DiscoveredServiceDisplayName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DiscoveredProcess.IsSet() {
		localVarFormParams.Add("discovered_process", parameterToString(localVarOptionals.DiscoveredProcess.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DiscoveredProcessDisplayName.IsSet() {
		localVarFormParams.Add("discovered_process_display_name", parameterToString(localVarOptionals.DiscoveredProcessDisplayName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MappedService.IsSet() {
		localVarFormParams.Add("mapped_service", parameterToString(localVarOptionals.MappedService.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MappedServiceDisplayName.IsSet() {
		localVarFormParams.Add("mapped_service_display_name", parameterToString(localVarOptionals.MappedServiceDisplayName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Protocol.IsSet() {
		localVarFormParams.Add("protocol", parameterToString(localVarOptionals.Protocol.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RemotePortTime.IsSet() {
		localVarFormParams.Add("remote_port_time", parameterToString(localVarOptionals.RemotePortTime.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
